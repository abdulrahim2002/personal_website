[{"content":"For each possible word, we ask the question: What possible queries can lead to this word?.\nFor example consider the word: abd. Below are the possible (prefix, suffix) queries that can return abd\n1 2 3 4 5 6 7 8 9 10 (prefix, suffix) a abd a bd a d ab abd ab bd ab d abd abd abd bd abd d Now, given word.length \u0026lt;= 7. Each word can at maximum generate 7*7=49 such pairs. Can we store all of them in a hashmap? Yes, because the total storage = 49 * number of words = O(n) Which is acceptable for this problem.\nWhat if there is already a value for (prefix,suffix) in current word. Shall we override it. We need the latest index right?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class WordFilter: def __init__(self, words: List[str]): self.map = {} for widx, w in enumerate(words): for i in range( len(w) ): prefix = w[:i+1] for j in range( len(w) ): suffix = w[j:] # for all possible prefix suffix queries that might route # to current word. We set it in dictionary overriding previously # inserted values to get the maximum index key = prefix + \u0026#39;|\u0026#39; + suffix self.map[key] = widx def f(self, pref: str, suff: str) -\u0026gt; int: key = pref + \u0026#39;|\u0026#39; + suff return self.map.get(key, -1) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_745_prefix_and_suffix_search_solution/","summary":"\u003cp\u003eFor each possible word, we ask the question: \u003cstrong\u003eWhat possible queries can lead to this word?\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor example consider the word: \u003ccode\u003eabd\u003c/code\u003e. Below are the possible (prefix, suffix) queries that can return \u003ccode\u003eabd\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(prefix, suffix)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    d\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  d\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  d\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eNow, given word.length \u0026lt;= 7. Each word can at maximum generate \u003ccode\u003e7*7=49\u003c/code\u003e such pairs. Can we store all of them in a hashmap? Yes, because the total storage = \u003ccode\u003e49 * number of words = O(n)\u003c/code\u003e Which is acceptable for this problem.\u003c/p\u003e","title":"Leetcode 745: prefix and suffix search solution"},{"content":"This problem is very similar to lc543, which is about finding the longest edge path in a tree. You can just copy over that code, and add 2 lines in it.\nHere we are doing the same thing as in lc543, however, when we encounter a non-matching child. We treat it as null.\nFor example, here the longest path at root node is highlighted below in red with 6 edges.\nOur algorithm views the tree like this. The longest path of 3 edges is highlighted in red.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int edges( struct TreeNode* node ); int longest_path; int longestUnivaluePath(struct TreeNode* root) { longest_path = 0; edges(root); return longest_path; } int edges( struct TreeNode* node ) { if ( !node ) return -1; int left = edges(node-\u0026gt;left), right = edges(node-\u0026gt;right); // treat child as null if it doesn\u0026#39;t match parent left = (node-\u0026gt;left \u0026amp;\u0026amp; node-\u0026gt;val == node-\u0026gt;left-\u0026gt;val) ? left : -1; right = (node-\u0026gt;right \u0026amp;\u0026amp; node-\u0026gt;val == node-\u0026gt;right-\u0026gt;val) ? right : -1; longest_path = fmax(longest_path, 1+left + 1+right); return 1 + fmax( left, right); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution: def __init__(self): self.ans = 0 def longestUnivaluePath(self, root: Optional[TreeNode]) -\u0026gt; int: self.edges( root ) return self.ans def edges(self, node: Optional[TreeNode]) -\u0026gt; int: if not node: return -1 left, right = self.edges( node.left ), self.edges( node.right ) # if the child is illegitimate. Discard it if not node.left or node.left.val != node.val: left = -1 # treat as null if not node.right or node.right.val != node.val: right = -1 self.ans = max( self.ans, ( 1+left ) + ( 1 + right ) ) return 1 + max( left, right ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function longestUnivaluePath(root: TreeNode | null): number { let ans = 0; const edges = ( node: TreeNode|null ): number =\u0026gt; { if ( !node ) return -1; let left = edges( node.left ), right = edges( node.right ); // if child value doesn\u0026#39;t match -\u0026gt; treat as null left = (node.left \u0026amp;\u0026amp; node.val == node.left.val) ? left : -1; right = (node.right \u0026amp;\u0026amp; node.val == node.right.val) ? right : -1; ans = Math.max( ans, (1 + left) + (1 + right) ); return 1 + Math.max( left, right ); } edges( root ); return ans; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function longestUnivaluePath(root) { let ans = 0; const edges = ( node ) =\u0026gt; { if ( !node ) return -1; let left = edges( node.left ), right = edges( node.right ); // if child value doesn\u0026#39;t match -\u0026gt; treat as null left = (node.left \u0026amp;\u0026amp; node.val == node.left.val) ? left : -1; right = (node.right \u0026amp;\u0026amp; node.val == node.right.val) ? right : -1; ans = Math.max( ans, (1 + left) + (1 + right) ); return 1 + Math.max( left, right ); } edges( root ); return ans; }; ","permalink":"http://localhost:45763/personal_website/posts/solution_to_leetcode_687_longest_univalue_path/","summary":"\u003cp\u003eThis problem is very similar to\n\u003ca href=\"https://leetcode.com/problems/diameter-of-binary-tree/solutions/6824338/solution-for-dummies-by-abdulrahim2002-yzrs/\"\u003elc543\u003c/a\u003e,\nwhich is about finding the longest edge path in a tree. You can just\ncopy over that code, and add 2 lines in it.\u003c/p\u003e\n\u003cp\u003eHere we are doing the same thing as in lc543, however, when we encounter a non-matching child. We treat it as null.\u003c/p\u003e\n\u003cp\u003eFor example, here the longest path at root node is highlighted below in red with 6 edges.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/148ffbfd-0ead-48cd-b45d-8c2575bafd11_1751999234.494938.png\"\u003e\u003c/p\u003e","title":"Solution to Leetcode 687: Longest Univalue Path"},{"content":"I keep track of the top k elements in sorted list. The kth largest element is the smallest of the top k elements.\ne.g. top k(=6) elements: [3,5,7,10,42,56] in sorted order. The kth largest element = 6th largest element = smallest element in above list.\nWhen I insert an element, I simply check if it can make it\u0026rsquo;s place among k largest elements already present in the list. Which it can, if it can defeat the smallest element in our list.\nFor example, we cannot add 2 in the array above since it fails to defeat 3.\nHowever, A number like 15 can be inserted. In which case, we remove the smallest element i.e. 3, to keep the list length=k\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class KthLargest: def __init__(self, k: int, nums: List[int]): self.scores = SortedList() self.limit = k for num in nums: self.add(num) def add(self, val: int) -\u0026gt; int: # if the current element can make space in top k elements if len(self.scores) \u0026lt; self.limit or self.scores[0] \u0026lt; val: self.scores.add(val) # remove smallest if len(self.scores) \u0026gt; self.limit: self.scores.pop(0) # return smallest return self.scores[0] ","permalink":"http://localhost:45763/personal_website/posts/leetcode_703_kth_largest_element_in_a_stream/","summary":"\u003cp\u003eI keep track of the top k elements in sorted list.\nThe kth largest element is the \u003cstrong\u003esmallest of the top k elements\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003ee.g. top k(=6) elements: \u003ccode\u003e[3,5,7,10,42,56]\u003c/code\u003e in sorted order.\nThe kth largest element = 6th largest element = smallest element in above list.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/070564ea-afa3-4108-92e6-7fa76c2fb981_1752504996.0140414.png\"\u003e\u003c/p\u003e\n\u003cp\u003eWhen I insert an element, I simply check if it can make it\u0026rsquo;s place among k largest elements already present in the list. Which it can, if it can defeat the smallest element in our list.\u003c/p\u003e","title":"Leetcode 703: kth largest element in a stream solution in python"},{"content":"When numbers from $$\\in$$ [0,n-1] are sorted in an array of size n. Their sorted position is equal to their index.\nSubset of numbers in array[i:j] can form a partition, if all elements in [i,j) are available in array[i:j].\nFor example [2,0,1] can form a partition, since they are at index 0, 1, 2 respectively. Sorted will involving swapping them at their correct position.\nThe basic idea behind this solution is that we try to identify such partitions, where all elements required to be sorted in [i, j] are available in current partition.\nHere\u0026rsquo;s the visualization of the algorithm, i points to the start of the group and j iterates through the group and checks if the current group needs to be expanded. e points to the end of the current group.\nSince, array[j]=1, we found a number greater than current boundaries. We need to expand the boundary. Hence, new group end is e = array[j].\nIncrement j. We find that array[1] = 0 which is \u0026lt; current end. Increment j again, j=2, Hence, no we exhaust the current group and we move forward to finding the next partition. Increase, current group ending, and reinitialize i=e/\nIn the second group, we have array[j]=2 and we are at index 2. Hence, we do not need to expand this group, since 2 is at right position.\nSimilarly we find the next 2 partitions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int maxChunksToSorted(int* arr, int arrSize) { int cur_gp_end = 0, cnt_gps = 0, i = 0; while ( i \u0026lt; arrSize ) { int j = i; // try to terminate the current group while ( j \u0026lt;= cur_gp_end ) { cur_gp_end = fmax( cur_gp_end, arr[j] ); j++; } i = ++cur_gp_end; cnt_gps++; } return cnt_gps; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_769_max_chunks_to_make_sorted/","summary":"\u003cp\u003eWhen numbers from $$\\in$$ \u003ccode\u003e[0,n-1]\u003c/code\u003e are sorted in an array of size n. Their sorted position is equal to their index.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/07a3b1d2-9478-486f-9f62-3a67e6dde1b3_1752513551.205261.png\"\u003e\u003c/p\u003e\n\u003cp\u003eSubset of numbers in \u003ccode\u003earray[i:j]\u003c/code\u003e can form a partition, if all elements in \u003ccode\u003e[i,j)\u003c/code\u003e are available in \u003ccode\u003earray[i:j]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFor example \u003ccode\u003e[2,0,1]\u003c/code\u003e can form a partition, since they are at index \u003ccode\u003e0, 1, 2\u003c/code\u003e respectively. Sorted will involving swapping them at their correct position.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/77d9235f-d72a-416a-bd77-d8802d7567b0_1752513786.651974.png\"\u003e\u003c/p\u003e\n\u003cp\u003eThe basic idea behind this solution is that we try to identify such partitions, where all elements required to be sorted in \u003ccode\u003e[i, j]\u003c/code\u003e are available in current partition.\u003c/p\u003e","title":"Leetcode 769: Max chunks to make sorted solution"},{"content":"For each word, we basically store all versions of it after removal of 1 character. For example,\n1 2 3 4 5 6 hello -\u0026gt; ello -\u0026gt; removed h@0 hllo -\u0026gt; removed e@1 helo -\u0026gt; removed l@2 helo -\u0026gt; removed l@3 hell -\u0026gt; removed o@4 We can store: wordAfterRemoval,indexOfRemoval in hashmap. So whenever we search for a word like: hexlo then we can try removing it\u0026rsquo;s 2nd index and search: helo,2 in the map, which we will find.\nIn the value we can store the removed character. For example, store key=helo,2 with value=l to indicate that l was removed.\nSo when you match a word like hexlo. Try to search helo,2 in the hashmap. It gives value=l which is !='x' i.e. the removed character in hexlo.\nHowever, there is one problem with this approach. When you add 2 words like: hello and hallo in the map. Then hllo,1 will give e in the first insertion and a in the second. The second overides the first so hello is forgetten by the structure. To avoid this issue, we store both of them (e, a) in a list.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class MagicDictionary { private map = new Map\u0026lt;string,string[]\u0026gt;(); buildDict(dictionary: string[]): void { for ( const word of dictionary ) { for ( let i=0; i \u0026lt; word.length; i++ ) { const wordAfterRemoval = word.slice(0, i) + word.slice(i+1); // key stores wordAfterRemoval,indexOfRemoval as value const key = `${wordAfterRemoval},${i}`; if ( !this.map.has(key) ) this.map.set(key,[]); // values have the removed character this.map.get(key).push( word[i] ) } } } search(word: string): boolean { for ( let i=0; i \u0026lt; word.length; i++ ) { const wordAfterRemoval = word.slice(0, i) + word.slice(i+1); const key = `${wordAfterRemoval},${i}`; if ( !this.map.has(key) ) continue; const removedChars = this.map.get(key); // If there was a word with removed character != word[i] for ( let j=0; j \u0026lt; removedChars.length; j++ ) { if ( removedChars[j] !== word[i] ) return true; } } return false; } } You can also embed the index information by replacing the removed word with _ like in this pyton version:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class MagicDictionary: def __init__(self): self.map = {} def buildDict(self, dictionary: List[str]) -\u0026gt; None: for word in dictionary: for i in range(len(word)): key = word[0:i] + \u0026#39;_\u0026#39; + word[i+1:] if not key in self.map: self.map[key] = [] self.map[key].append(word[i]) def search(self, searchWord: str) -\u0026gt; bool: for i in range(len(searchWord)): key = searchWord[0:i] + \u0026#39;_\u0026#39; + searchWord[i+1:] if key not in self.map: continue for c in self.map[key]: if c != searchWord[i]: return True return False # Your MagicDictionary object will be instantiated and called as such: # obj = MagicDictionary() # obj.buildDict(dictionary) # param_2 = obj.search(searchWord) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_676_magic_dictionary/","summary":"\u003cp\u003eFor each word, we basically store all versions of it after removal of 1 character. For example,\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehello -\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eello -\u0026gt; removed h@0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehllo -\u0026gt; removed e@1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehelo -\u0026gt; removed l@2\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehelo -\u0026gt; removed l@3\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehell -\u0026gt; removed o@4\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eWe can store: \u003ccode\u003ewordAfterRemoval,indexOfRemoval\u003c/code\u003e in hashmap. So whenever we search for a word like: \u003ccode\u003ehexlo\u003c/code\u003e then we can try removing it\u0026rsquo;s 2nd index and search: \u003ccode\u003ehelo,2\u003c/code\u003e in the map, which we will find.\u003c/p\u003e","title":"Leetcode 676: magic dictionary"},{"content":"consider the word \u0026ldquo;catsdogcats\u0026rdquo;. We have the dictionary: [\u0026quot;cat\u0026quot;,\u0026quot;cats\u0026quot;,\u0026quot;catsdogcats\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;dogcatsdog\u0026quot;,\u0026quot;hippopotamuses\u0026quot;,\u0026quot;rat\u0026quot;,\u0026quot;ratcatdogcat\u0026quot;]\nWe iterate over the word: catsdogcats and at each iteration, we ask if the prefix is contained in dictionary.\nIf the prefix is in the dictionary, we recursively call the function on the remaining word (excluding matched prefix)\nis c in dictionary ? is ca in dictionary ? is cat in dictionary ? -\u0026gt; YES call( sdogcats ) \u0026ndash;[1] Prefix cat matched so recursively call with sdogcats\nis s in dictionary ? is sd in dictionary ? \u0026hellip;. is sdogcats in dictionary ? NO We exhausted the word so we return false. Nothing was matched\nBack at the first call, this time we try to match cats Return to [1]\nis cats in dictionary -\u0026gt; YES recursively call on dogcats\nis d in dictionary ?\nis do in dictionary ?\nis dog in dictionary ? -\u0026gt; YES, recursively call on cats\nis c in dictionary ?\nis ca in dictionary ?\nis cat in dictionary ? YES , recursively call(s) \u0026ndash;[2]\nis s in dictionary ? NO -\u0026gt; word exhausted, return false;\nBack at recursive call [2]\nis cats in dictionary ? YES recursively call(``) i.e. empty string When we reach empty string, it means whole of string can be constructed using words in dictionary. Hence return true.\nImport considerations:\nThe dictionary has all the words, which means that catsdogcats will match with itself completely. To avoid words matching with themselves, we tell the function to ignore the catsdogcats word to avoid matching it with itself. Also, we can memoize the results since, dictionary remains the same, only target word and ignore word changes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function findAllConcatenatedWordsInADict(words: string[]): string[] { const dict = new Set\u0026lt;string\u0026gt;( words ); return words.filter( curWord =\u0026gt; canChunk( curWord, curWord, dict ) ); }; function canChunk( target: string, ignore: string, dict: Set\u0026lt;string\u0026gt;, memo = new Map\u0026lt;string, boolean\u0026gt;() ): boolean { if ( !target.length ) return true; const key = target + ignore; if ( memo.has( key ) ) return memo.get( key ); for ( let i=1; i \u0026lt;= target.length; i++ ) { const prefix = target.slice( 0, i ); if ( prefix !== ignore \u0026amp;\u0026amp; dict.has( prefix ) \u0026amp;\u0026amp; canChunk( target.slice( i ), ignore, dict, memo ) ) { memo.set( key, true ); return true; } } memo.set( key, false ); return false; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_472_concatenated_words/","summary":"\u003cp\u003econsider the word \u0026ldquo;catsdogcats\u0026rdquo;. We have the dictionary: \u003ccode\u003e[\u0026quot;cat\u0026quot;,\u0026quot;cats\u0026quot;,\u0026quot;catsdogcats\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;dogcatsdog\u0026quot;,\u0026quot;hippopotamuses\u0026quot;,\u0026quot;rat\u0026quot;,\u0026quot;ratcatdogcat\u0026quot;]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWe iterate over the word: \u003ccode\u003ecatsdogcats\u003c/code\u003e and at each iteration, we ask if the prefix is contained in dictionary.\u003c/p\u003e\n\u003cp\u003eIf the prefix is in the dictionary, we recursively call the function on the remaining word (excluding matched prefix)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eis \u003ccode\u003ec\u003c/code\u003e in dictionary ?\u003c/li\u003e\n\u003cli\u003eis \u003ccode\u003eca\u003c/code\u003e in dictionary ?\u003c/li\u003e\n\u003cli\u003eis \u003ccode\u003ecat\u003c/code\u003e in dictionary ? -\u0026gt; YES       call( \u003ccode\u003esdogcats\u003c/code\u003e ) \u0026ndash;[1]\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePrefix \u003ccode\u003ecat\u003c/code\u003e matched so recursively call with \u003ccode\u003esdogcats\u003c/code\u003e\u003c/p\u003e","title":"Leetcode 472: Concatenated words"},{"content":"The task is to find a subarray with sum of elements = k\nTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\nThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\n$$ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k] $$\nNow we are looking for sub of subarray = T(target). Therefore:\n$$ sum\\ of\\ subarray = prefix\\ [j]\\ -\\ prefix\\ [i-1] = T\\ \\ prefix\\ [i-1] = prefix\\ [j]\\ - T $$\nTherefore, we iterate the prefix array. And at each prefix[j], we search for a previously inserted prefix[i-1] such that prefix[i-1] = prefix[j] - T. We also need the count of such subarrays. At a particular j the number of subarrays where sum=T is the number of i that occured previously such that prefix[i-1] = prefix[j] - T. Index j will form a subarray with each of such previous i\u0026rsquo;s.\nWe must store the mapping: ( prefix[x], count ) in a map.\nSo far so good. But what happens when $$i=0$$. In this case, sum of subarray between indices [0, j] is defined as:\n$$ prefix\\ [j] = \\sum_{k=0}^j nums\\ [k] = T $$\nAt each index j, the code will try to look for prefix[j] - T in the map. When prefix[j]=T itself, then it would look for T-T=0 into the map. Therefore we must keep prefix= 0, count= 1 into the map to account for subarrays starting at index 0.\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 function subarraySum(nums: number[], k: number): number { const map = new Map\u0026lt;number, number\u0026gt;([ [0, 1] ]); let sumk = 0; for ( let j=0; j \u0026lt; nums.length; j++ ) { nums[j] = ( j==0 ) ? nums[j] : nums[j-1] + nums[j]; sumk += map.get( nums[j] - k ) ?? 0; map.set( nums[j], ( map.get(nums[j]) ?? 0 ) + 1 ); } return sumk; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_560_subarray_sub_equal_k_solution/","summary":"\u003cp\u003eThe task is to find a subarray with \u003ccode\u003esum of elements = k\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\u003c/p\u003e\n\u003cp\u003eThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\u003c/p\u003e\n\u003cp\u003e$$\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k]\n$$\u003c/p\u003e","title":"Leetcode 560: Subarray sum equals k"},{"content":"Consider the array: [0,1,1,0,0,1,1,0,1,1] The idea is to turn the 0\u0026rsquo;s into -1\u0026rsquo;s\narray: [-1,1,1,-1,-1,1,1,-1,1,1]\nNow, the task is to find a subarray with sum of elements = 0\nTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\nThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\n$$ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k] $$\nAnd the length of the subarray between indices $$[i,j]$$ is defined as: $$length(i,j) = j-i+1 = j-(i-1) $$\nNow we are looking for sub of subarray = 0. Therefore:\n$$ sum\\ of\\ subarray = prefix\\ [j]\\ -\\ prefix\\ [i-1] = 0\\ prefix\\ [j]\\ =\\ prefix\\ [i-1] $$\nTherefore, we iterate the prefix array. And at each prefix[j], we search for a previously inserted prefix[i-1] such that prefix[j]=prefix[i-1]. We record the length of the current subarray as: length = j-(i-1).\nWe must store the mapping: ( prefix[k], k ) in a map to achieve this.\nSo far so good. But what happens when $$i=0$$. In this case, sum of subarray between indices [0, j] is defined as:\n$$ prefiix\\ [j] = \\sum_{k=0}^j nums\\ [k] $$\nAnd the length of the subarray [0,j] is: $$j+1 = j-(-1)$$\nTherefore we keep a superficial (prefix = 0, index = -1) in the map.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function findMaxLength(nums: number[]): number { const map = new Map\u0026lt;number, number\u0026gt;( [ [0, -1], ] ); let maxLen = 0; for ( let j=0; j \u0026lt; nums.length; j++ ) { let cur = ( nums[j] == 1 ) ? 1 : -1; nums[j] = ( j==0 ) ? cur : cur + nums[j-1]; // prefix sum occured previously at i. Length = j-i if ( map.has( nums[j] ) ) { let i = map.get( nums[j] ); maxLen = Math.max( maxLen, j - i ); } // put the current prefix sum into map if ( !map.has( nums[j] ) ) map.set( nums[j], j ); } return maxLen; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_525_contiguous_array/","summary":"\u003cp\u003eConsider the array: \u003ccode\u003e[0,1,1,0,0,1,1,0,1,1] \u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe idea is to turn the 0\u0026rsquo;s into -1\u0026rsquo;s\u003c/p\u003e\n\u003cp\u003earray: \u003ccode\u003e[-1,1,1,-1,-1,1,1,-1,1,1]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eNow, the task is to find a subarray with \u003ccode\u003esum of elements = 0\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\u003c/p\u003e\n\u003cp\u003eThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\u003c/p\u003e\n\u003cp\u003e$$\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k]\n$$\u003c/p\u003e","title":"Leetcode_525_contiguous_array"},{"content":"The idea is to keep 2 pointers. trail pointer and cur pointer. The list is build in recursive function build(trail, cur) which returns last node of the list we build.\nbuild works as follows:\nwhen there is no child node: simply connect trail and cur and advance both when there is a child node, then recursively call itself with build( trail = cur, cur = cur.child ). The call would connect cur node with the list in the next level. It would return the last node in next level. Then we assign trail = last node in next level and cur = cur.next in current level. This ensures that the next iteration would connect last node in next level to next node in current level. when cur becomes null trail is the last node in current level. return trail Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function flatten(head: _Node | null): _Node | null { const save: _Node = new _Node( -1 ); build( save, head ); if ( save.next ) save.next.prev = null; return save.next; }; function build( trail: _Node | null, cur: _Node | null ): _Node | null { while ( cur ) { if ( !cur.child ) { trail.next = cur; cur.prev = trail; trail = trail.next; cur = cur.next; } else { trail.next = cur; cur.prev = trail; const saveNext = cur.next; const lastNodeFromChildList = build( cur, cur.child ); cur.child = null; cur = saveNext; trail = lastNodeFromChildList; } } return trail; } Complexity Time complexity: $$O(n)$$\nSpace complexity: $$O(n)$$ {recursion stack}\n","permalink":"http://localhost:45763/personal_website/posts/leetcode_430_flattening_multilevel_linked_list/","summary":"\u003cp\u003eThe idea is to keep 2 pointers. \u003ccode\u003etrail\u003c/code\u003e pointer and \u003ccode\u003ecur\u003c/code\u003e pointer. The\nlist is build in recursive function \u003ccode\u003ebuild(trail, cur)\u003c/code\u003e which returns\nlast node of the list we build.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebuild\u003c/code\u003e works as follows:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ewhen there is no \u003ccode\u003echild\u003c/code\u003e node: simply connect \u003ccode\u003etrail\u003c/code\u003e and \u003ccode\u003ecur\u003c/code\u003e and advance both\u003c/li\u003e\n\u003cli\u003ewhen there is a \u003ccode\u003echild\u003c/code\u003e node, then recursively call itself with \u003ccode\u003ebuild( trail = cur, cur = cur.child )\u003c/code\u003e. The call would connect \u003ccode\u003ecur\u003c/code\u003e node with the \u003ccode\u003elist in the next level\u003c/code\u003e. It would return the last node in next level. Then we assign \u003ccode\u003etrail = last node in next level\u003c/code\u003e and \u003ccode\u003ecur = cur.next in current level\u003c/code\u003e. This ensures that the next iteration would connect \u003ccode\u003elast node in next level\u003c/code\u003e to \u003ccode\u003enext node in current level\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003ewhen \u003ccode\u003ecur\u003c/code\u003e becomes \u003ccode\u003enull\u003c/code\u003e \u003ccode\u003etrail\u003c/code\u003e is the last node in current level. \u003ccode\u003ereturn trail\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"code\"\u003eCode\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003eflatten\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ehead\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kr\"\u003econst\u003c/span\u003e   \u003cspan class=\"nx\"\u003esave\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ehead\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003esaveNext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003elastNodeFromChildList\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003esaveNext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003elastNodeFromChildList\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"complexity\"\u003eComplexity\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTime complexity:  $$O(n)$$\u003c/p\u003e","title":"Leetcode 430: Flattening a multilevel linked list"},{"content":"Below is my solution for the leetcode 154: Find minimum in rotated sorted array problem\nIntuition Fact is, that you cannot solve this question in O(log n) time. The reason is because of duplicates.\nConsider a situation like:\n$$ [2,2,2,2,1,2,2] $$\nwhere mid is at 3 and the minium number here is clearly $$1$$. But our binary search algorithm will not be able to figure out in which direction it should go, since starting, ending and middle values are all same. In this case the best we can do is increment mid which makes the worst running time: O(n)\nHowever, it is possible to solve this problem in O(n/2) as explain below.\nApproach We will make use of the fact that a sorted array follows the (min) heap property i.e. in a sorted array, at all parent nodes are smaller than their children.\nAnd if this sorted array is rotated, then the place at which the first violation occurs is the subtree where the answer will be found.\nComplexity Time complexity: $$O(n/2)$$ Space complexity: $$O(1)$$ Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 var findMin = function(a) { /** Approach: You cannot solve this problem in O(log n) since it contains duplicate values. But you can actually solve this problem in O(n/2) by using the fact that a sorted array follows heap property. And if a sorted array is rotated then the heap property no longer holds. to find the minium element traverse the array, and find the first subtree where the heap property does not hold. the minium of the 2 values where the heap property does not satisfy is also minium in the array. Time: O(n/2) Space: O(1) */ let A = a.length; let i = 0; while ( i \u0026lt;= Math.floor(A/2)-1 ) { let root = i; let lc = 2*i + 1; let rc = 2*i + 2; let smallest = root; if ( lc \u0026lt; A \u0026amp;\u0026amp; a[lc] \u0026lt; a[smallest] ) smallest = lc; if ( rc \u0026lt; A \u0026amp;\u0026amp; a[rc] \u0026lt; a[smallest] ) smallest = rc; if ( smallest != root ) /* violation found. the value at smallest is minium */ return a[smallest]; i++; } /* no violation found. Either the array is sorted ar there it is all duplicates, in either case, return the first element. */ return a[0]; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_154_find_minimum_in_rotated_sorted_array/","summary":"\u003cp\u003eBelow is my solution for the \u003ca href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/\"\u003eleetcode 154: Find minimum in rotated\nsorted array problem\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"intuition\"\u003eIntuition\u003c/h1\u003e\n\u003c!-- Describe your first thoughts on how to solve this problem. --\u003e\n\u003cp\u003eFact is, that you \u003cstrong\u003ecannot\u003c/strong\u003e solve this question in \u003cstrong\u003eO(log n)\u003c/strong\u003e time. The reason is because of duplicates.\u003c/p\u003e\n\u003cp\u003eConsider a situation like:\u003c/p\u003e\n\u003cp\u003e$$\n[2,2,2,2,1,2,2]\n$$\u003c/p\u003e\n\u003cp\u003ewhere mid is at 3 and the minium number here is clearly $$1$$. But our binary search algorithm will not be able to figure out in which direction it should go, since starting, ending and middle values are all same. In this case the best we can do is increment mid which makes the worst running time: \u003cstrong\u003eO(n)\u003c/strong\u003e\u003c/p\u003e","title":"Leetcode 154: Find minimum in rotated sorted array"},{"content":"Here\u0026rsquo;s my solution to the Leetcode 315: Count of Smaller Numbers After Self problem using standard merge sort. I just change one line to count while merge procedure.\nSolution Let\u0026rsquo;s build the solution step by step.\nInput: nums = $$[5,2,6,1]$$\nFirst, turn the numbers into [number, index] tuple. So it looks like:\narray = $$ [ [ 5, 0 ], [ 2, 1 ], [ 6, 2 ], [ 1, 3 ] ] $$\nSecond, just write standard merge sort algorithm and sort the array in ascending order by first values.\nThe output is: $$ [ [ 1, 3 ], [ 2, 1 ], [ 5, 0 ], [ 6, 2 ] ] $$\nHere\u0026rsquo;s the trace of the algorithm:\nSimple merge sort implemented 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { tmp.push( a[j] ); j++; } else { tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); merge_sort( array, 0, array.length-1 ); }; So far so good.\nNow let\u0026rsquo;s get back to the question. The question is asking: For each index $$i$$, count all numbers at index $$j$$ such that $$i \u0026lt; j$$ and $$a[i] \u0026gt; a[j]$$. Or, simply put: for each number, find all numbers that appear after it and are smaller than it.\nNow, look at the visualization again, pay attention to the merge procedure (in magenta colour) and observe the following:\nat each merge procedure, we merge 2 consecutive partitions. all numbers in the left partition appear before numbers in right partition in the original array. The partitions are sorted in increasing order. Now, suppose we are merging 2 partitions where, the pointer of left partition is at $$x$$ and pointer of right partition is at $$y$$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [....a,b,c, x ,d,e,f....] [...h,i,j, y, k,l,m....] ^ ^ i j Suppose x \u0026gt; y It follows from observation 2 that: y is one of the numbers that appear to the right of x and is smaller than x ---(1) Also, since partitions are sorted (observation 3): d, e, f .... (i.e. all number that appear to the right of x) are greater than x. ----(2) From (1) and (2) we can conclude that: x, d, e, f, ... (i.e. all numbers to the right of x including x) appear before y. And y is smaller than all these numbers. Hence, required condition satisfied! Now, we just need a counter for each variable, and whenever the condition same as above occurs, we increment the counter for each x,d,e,\u0026hellip;\n1 2 3 4 5 6 7 [....a,b,c, x ,d,e,f....] [...h,i,j, y, k,l,m....] ^ ^ i j while merging: if x \u0026gt; y increment the counters of x, d, e, f, ... Single line changed in standard merge sort algorithm We can use the index at the second position to access the counter of that particular number.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 let counts; const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { /* ____(x \u0026gt; y) so increment counters of x,d,e,...____*/ for ( let p=i; p\u0026lt;=mid; p++ ) counts[ a[p][1] ]++; /*_______________INSERT THIS LINE_____________________*/ tmp.push( a[j] ); j++; } else { tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); counts = new Array(nums.length).fill(0); merge_sort( array, 0, array.length-1 ); return counts; }; That is the whole idea behind this question. Now the above implementation won\u0026rsquo;t work because at each iteration, we are updating whole left partition after i. Making it O(n^2) Optimize To avoid updating the whole partition, we keep a running counter cnt.\nFinal implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 let counts; const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; let cnt = 0; // keep running counter while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { cnt++; // increment counter tmp.push( a[j] ); j++; } else { counts[ a[i][1] ] += cnt; // no more numbers that are // smaller than i tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { counts[ a[i][1] ] += cnt; // if left partition is not over // update left over number counts tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); counts = nums; counts.fill(0); merge_sort( array, 0, array.length-1 ); return counts; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def countSmaller(nums): counts = [0] * len(nums) array = [(num, i) for i, num in enumerate(nums)] def merge_sort(start, end): if start == end: return mid = (start + end) // 2 merge_sort(start, mid) merge_sort(mid + 1, end) merge(start, mid, end) def merge(start, mid, end): temp = [] i, j = start, mid + 1 cnt = 0 while i \u0026lt;= mid and j \u0026lt;= end: if array[i][0] \u0026gt; array[j][0]: cnt += 1 temp.append(array[j]) j += 1 else: counts[array[i][1]] += cnt temp.append(array[i]) i += 1 while i \u0026lt;= mid: counts[array[i][1]] += cnt temp.append(array[i]) i += 1 while j \u0026lt;= end: temp.append(array[j]) j += 1 for i in range(len(temp)): array[start + i] = temp[i] merge_sort(0, len(nums) - 1) return counts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; countSmaller(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; counts(nums.size(), 0); vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; array; for (int i = 0; i \u0026lt; nums.size(); i++) { array.emplace_back(nums[i], i); } function\u0026lt;void(int, int)\u0026gt; merge_sort = [\u0026amp;](int start, int end) { if (start == end) return; int mid = start + (end - start) / 2; merge_sort(start, mid); merge_sort(mid + 1, end); merge(start, mid, end); }; function\u0026lt;void(int, int, int)\u0026gt; merge = [\u0026amp;](int start, int mid, int end) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; temp; int i = start, j = mid + 1; int cnt = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end) { if (array[i].first \u0026gt; array[j].first) { cnt++; temp.push_back(array[j]); j++; } else { counts[array[i].second] += cnt; temp.push_back(array[i]); i++; } } while (i \u0026lt;= mid) { counts[array[i].second] += cnt; temp.push_back(array[i]); i++; } while (j \u0026lt;= end) { temp.push_back(array[j]); j++; } for (int k = 0; k \u0026lt; temp.size(); k++) { array[start + k] = temp[k]; } }; merge_sort(0, nums.size() - 1); return counts; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import java.util.*; class Solution { private int[] counts; private int[][] array; public List\u0026lt;Integer\u0026gt; countSmaller(int[] nums) { counts = new int[nums.length]; array = new int[nums.length][2]; for (int i = 0; i \u0026lt; nums.length; i++) { array[i][0] = nums[i]; array[i][1] = i; } mergeSort(0, nums.length - 1); List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (int count : counts) { result.add(count); } return result; } private void mergeSort(int start, int end) { if (start == end) return; int mid = start + (end - start) / 2; mergeSort(start, mid); mergeSort(mid + 1, end); merge(start, mid, end); } private void merge(int start, int mid, int end) { List\u0026lt;int[]\u0026gt; temp = new ArrayList\u0026lt;\u0026gt;(); int i = start, j = mid + 1; int cnt = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end) { if (array[i][0] \u0026gt; array[j][0]) { cnt++; temp.add(array[j]); j++; } else { counts[array[i][1]] += cnt; temp.add(array[i]); i++; } } while (i \u0026lt;= mid) { counts[array[i][1]] += cnt; temp.add(array[i]); i++; } while (j \u0026lt;= end) { temp.add(array[j]); j++; } for (int k = 0; k \u0026lt; temp.size(); k++) { array[start + k] = temp.get(k); } } } Time: $$O(n\\ log\\ n)$$ Space: $$O(n)$$ ","permalink":"http://localhost:45763/personal_website/posts/leetcode_315_count_of_smaller_numbers_after_self/","summary":"\u003cp\u003eHere\u0026rsquo;s my solution to the \u003ca href=\"https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/\"\u003eLeetcode 315: Count of Smaller Numbers After\nSelf problem\u003c/a\u003e using standard merge sort. I just change one line to\ncount while merge procedure.\u003c/p\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\n\u003cp\u003eLet\u0026rsquo;s build the solution step by step.\u003c/p\u003e\n\u003cp\u003eInput: nums = $$[5,2,6,1]$$\u003c/p\u003e\n\u003cp\u003eFirst, turn the numbers into \u003cstrong\u003e[number, index]\u003c/strong\u003e tuple. So it looks like:\u003c/p\u003e\n\u003cp\u003earray = $$ [ [ 5, 0 ], [ 2, 1 ], [ 6, 2 ], [ 1, 3 ] ] $$\u003c/p\u003e","title":"Leetcode 315: Count of Smaller Numbers After Self"},{"content":"Here\u0026rsquo;s my explanation for the leetcode 306: Additive Number problem\nAdditive Number Problem Problem Recap An additive number is a string of digits where the sequence of numbers formed by splitting the string satisfies the condition that each number (after the first two) is the sum of the two preceding numbers.\nExamples: \u0026quot;112358\u0026quot; is additive because the sequence is 1, 1, 2, 3, 5, 8, and:\n1 + 1 = 2 1 + 2 = 3 2 + 3 = 5 3 + 5 = 8 \u0026quot;199100199\u0026quot; is additive because the sequence is 1, 99, 100, 199, and:\n1 + 99 = 100 99 + 100 = 199 Solution Approach The solution uses a backtracking approach to try all possible splits of the string into sequences of numbers and checks if any of these sequences form an additive sequence.\nDetailed Explanation Helper Function isValid This recursive function checks if the remaining part of the string s forms a valid additive sequence given the first two numbers a and b.\nBase Case: If the remaining string s is empty, it means we\u0026rsquo;ve successfully formed an additive sequence, so return true.\nRecursive Step:\nCompute the sum of a and b and convert it to a string sum. Check if the remaining string s starts with sum: If not, the sequence is invalid  return false. If yes, recursively check the next part of the string with the new pair (b, sum) and the remaining string after removing sum. Main Function isAdditiveNumber Initialization: Get the length of the input string num. Nested Loops: The outer loop (i) determines the end index of the first number a (from index 0 to i). The inner loop (j) determines the end index of the second number b (from index i to j). Leading Zero Check: Skip any splits where a or b have leading zeros unless they are exactly \u0026quot;0\u0026quot;. Example: \u0026quot;02\u0026quot; is invalid, but \u0026quot;0\u0026quot; is valid. Validation: For each valid pair (a, b), call isValid to check if the remaining part of the string forms a valid additive sequence starting with a and b. If isValid returns true, immediately return true from the main function. Final Check: If no valid sequence is found after all possible splits, return false. Example Walkthrough Let\u0026rsquo;s walk through the example num = \u0026quot;112358\u0026quot;:\nFirst Iteration (i = 1, j = 2): a = \u0026quot;1\u0026quot;, b = \u0026quot;1\u0026quot;. No leading zeros  proceed. isValid(1, 1, \u0026quot;2358\u0026quot;): Sum of 1 + 1 = 2. Check if \u0026quot;2358\u0026quot; starts with \u0026quot;2\u0026quot;  Yes. Recursively call isValid(1, 2, \u0026quot;358\u0026quot;): Sum of 1 + 2 = 3. Check if \u0026quot;358\u0026quot; starts with \u0026quot;3\u0026quot;  Yes. Recursively call isValid(2, 3, \u0026quot;58\u0026quot;): Sum of 2 + 3 = 5. Check if \u0026quot;58\u0026quot; starts with \u0026quot;5\u0026quot;  Yes. Recursively call isValid(3, 5, \u0026quot;8\u0026quot;): Sum of 3 + 5 = 8. Check if \u0026quot;8\u0026quot; starts with \u0026quot;8\u0026quot;  Yes. Recursively call isValid(5, 8, \u0026quot;\u0026quot;): Empty string  return true. Since isValid returned true, the main function returns true. Edge Cases Leading Zeros: Correctly skips invalid splits (e.g., \u0026quot;02\u0026quot; unless it\u0026rsquo;s \u0026quot;0\u0026quot;). Single Digit: If input length \u0026lt; 3, returns false. Large Numbers: Uses parseInt, but BigInt is better for very large numbers to avoid precision issues. Time Complexity Nested loops: O(n), where n is the string length. isValid function: O(n) per pair (a, b). Overall: O(n), feasible for reasonably sized strings. Space Complexity O(n) due to recursion stack in the worst case. Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var isAdditiveNumber = function(num) { const isValid = (a, b, s) =\u0026gt; { if (s.length === 0) return true; const sum = (a + b).toString(); return s.startsWith(sum) \u0026amp;\u0026amp; isValid(b, parseInt(sum), s.slice(sum.length)); }; const n = num.length; for (let i = 1; i \u0026lt; n; i++) { for (let j = i + 1; j \u0026lt; n; j++) { const a = num.slice(0, i); const b = num.slice(i, j); if ((a.startsWith(\u0026#39;0\u0026#39;) \u0026amp;\u0026amp; a.length \u0026gt; 1) || (b.startsWith(\u0026#39;0\u0026#39;) \u0026amp;\u0026amp; b.length \u0026gt; 1)) continue; if (isValid(parseInt(a), parseInt(b), num.slice(j))) return true; } } return false; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 var isAdditiveNumber = function(num) { let N = num.length; let check = ( a ) =\u0026gt; { /** check if numbers in an array form fibonacci seqence **/ let A = a.length; if ( A \u0026lt; 3 ) return false; for ( let i=2; i \u0026lt; A; i++ ) if ( Number(a[i]) != Number(a[i-1]) + Number(a[i-2]) || ( a[i].length \u0026gt; 1 \u0026amp;\u0026amp; a[i].startsWith(\u0026#39;0\u0026#39;) ) || ( a[i-1].length \u0026gt; 1 \u0026amp;\u0026amp; a[i-1].startsWith(\u0026#39;0\u0026#39;) ) || ( a[i-2].length \u0026gt; 1 \u0026amp;\u0026amp; a[i-2].startsWith(\u0026#39;0\u0026#39;) ) ) return false; return true; }; let bt_search = ( i, cur = [] ) =\u0026gt; { if ( i \u0026gt; N ) return false; if ( i === N \u0026amp;\u0026amp; check(cur) ) return true; // num[i] starts a new number, explore path cur.push( num[i] ); let new_start = bt_search( i+1, cur ); if ( new_start ) return true; // backtrack, num[i] continues the previous number cur.pop(); if ( i \u0026gt; 0 ) { cur[ cur.length-1 ] += num[i]; let add_prev = bt_search( i+1, cur ); if ( add_prev ) return true; } return false; }; return bt_search( 0 ); }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_306_additive_number/","summary":"\u003cp\u003eHere\u0026rsquo;s my explanation for the \u003ca href=\"https://leetcode.com/problems/additive-number/description/\"\u003eleetcode 306: Additive Number problem\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"additive-number-problem\"\u003eAdditive Number Problem\u003c/h2\u003e\n\u003ch3 id=\"problem-recap\"\u003eProblem Recap\u003c/h3\u003e\n\u003cp\u003eAn \u003cstrong\u003eadditive number\u003c/strong\u003e is a string of digits where the sequence of numbers formed by splitting the string satisfies the condition that each number (after the first two) is the sum of the two preceding numbers.\u003c/p\u003e\n\u003ch4 id=\"examples\"\u003eExamples:\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026quot;112358\u0026quot;\u003c/code\u003e is additive because the sequence is \u003ccode\u003e1, 1, 2, 3, 5, 8\u003c/code\u003e, and:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e1 + 1 = 2\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e1 + 2 = 3\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e2 + 3 = 5\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e3 + 5 = 8\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026quot;199100199\u0026quot;\u003c/code\u003e is additive because the sequence is \u003ccode\u003e1, 99, 100, 199\u003c/code\u003e, and:\u003c/p\u003e","title":"Leetcode 306: Additive number"},{"content":"Here are all possible solutions I could come up with for the longest increasing subsequence problem. leetcode 300\nApproach 1: Generate all possible increasing subsequences We will keep track of a subsequence in an array named cur_subsequence or cur_sub. For each element (a[i]) we have the following 2 options:\nAdd the element to the end of current subsequence.\nNote: The current element can only be included if either the current subsequence is empty or the last element of the current subsequence is smaller than the current element. This is important to maintain the increasing subsequence property.\nIgnore the current element and explore without a[i]\nTime complexity: $$ O(2^N) $$ Space complexity: $$ O(N) $$ // recursion stack + auxilary array 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 var lengthOfLIS = function(a) { let A = a.length; // maximum length of a subsequence seen so far let max_len = 1; let bt_search = ( i, cur_sub = [] ) =\u0026gt; { if ( i \u0026gt;= A ) { max_len = Math.max( max_len, cur_sub.length ); return; } // either select the ith element, or ignore it. // a[i] can be taken when either subsequencee is empty or // last inserted element is smaller if ( !cur_sub.length || cur_sub[ cur_sub.length-1 ] \u0026lt; a[i] ) { cur_sub.push( a[i] ); bt_search( i+1, cur_sub ); cur_sub.pop(); // backtrack } // explore without a[i] included bt_search( i+1, cur_sub ); }; bt_search(0); return max_len; } Approach 2 (Version 1) : Generating all possible subsequences, but change the structure of the recursion to allow memoization Currently, we are keeping track of the current subsequence in an array cur_sub which makes it difficult for us to implement memoization. Notice that we only need previously selected element (to compare if current element is larger) and current length (to find the subsequence length). Hence, we will only use 3 variables: index, previous element index, current length.\nTime complexity: $$ O( N^2 ) $$ Space complexity: $$O( N^3 )$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 var lengthOfLIS = function(a) { /** Write a recurrence relation. Either you take the element @i or your ignore it. In either case, your pick the maximum length. generating all possible increasing subsequences, but not storing the subsequence and using only 3 variables. for each call(index, prev_selected, cur_length) we try to find the maximum length we can form by either selecting or rejecting a[i] This configuration is easy to memoize. **/ let A = a.length; let memo = new Map(); let bt_search = ( i, prev, cur_len = 0 ) =\u0026gt; { // inputs of the function are memoized by turning // them into a String `key` let key = JSON.stringify( [i, prev, cur_len] ); if (memo.has(key)) return memo.get(key); if ( i \u0026gt;= A ) return cur_len; let take = -1, not_take = -1; // a[i] can be taken if prev=null / cur_len=0 // or prev \u0026lt; a[i] if ( cur_len == 0 || prev \u0026lt; a[i] ) take = bt_search( i+1, a[i], cur_len+1 ); // backtrack. do not take a[i] not_take = bt_search( i+1, prev, cur_len ); let res = Math.max( take, not_take ); memo.set(key, res); return memo.get(key); }; return bt_search(0); } Approach 2 (Version 2): Yet another recursive solution, but with better memoization This solution memoizes using only: index of current element (i), index of previously selected element (prev_i).\nThe memoization is done in a matrix of size $$N$$X$$(N+1)$$.\nTime complexity: $$ O( N^2 ) $$ Space complexity: $$O( N^2 )$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 var lengthOfLIS = function(a) { /** Approach 2 (version 2): Instead of storing 3 variables, just store 2 variables. This will enable memoization table to be an NxN matrix. **/ let A = a.length; let memo = new Array( A ).fill(null).map( () =\u0026gt; new Array( A+1 ).fill( null ) ); let bt_search = ( i, prev_i = -1 ) =\u0026gt; { // y is remapped since prev_i is in range [-1,n-1] // but our array ranges is in range [0, n] let x = i, y = prev_i + 1; if ( i \u0026gt;= A ) return 0; if ( memo[x][y] !== null ) return memo[x][y]; let take = -1, not_take = -1; // a[i] can be taken if prev_i = -1 / cur_len=0 or // a[prev_i] \u0026lt; a[i] if ( prev_i == -1 || a[prev_i] \u0026lt; a[i] ) take = 1 + bt_search( i+1, i ); // backtrack. do not take a[i]. The length remains same not_take = bt_search( i+1, prev_i ); let res = Math.max( take, not_take ); memo[x][y] = res; return memo[x][y]; }; return bt_search(0); } Approach 3: Dynamic programming Declare a lis(longest increasing subsequence) array, where lis[i] denotes the length of longest increasing subsequence starting at i and ending at the end of the array. Fill this table from second last element towards first element.\nTo find lis[i] for an element a[i] use the following algorithm:\nFor each i \u0026lt;- n-2 - 0 // find if index i can form an increasing subsequence // with any element on the right of it max_len = 1 For each j \u0026lt;- i+1 - n if ( a[i] \u0026lt; a[j] ) // a[j] is a potential connection point max_len = MAX( max_len, 1 + lis[j] ) lis[i] = max_len The basic intuition behind it is, that we explore all elements to the right of a[i] which can connect with a[i] to form an increasing subsequence. The length of such a subsequence is given by:\n1 (length of a[i]) + length of longest subsequence from a[j] up until the end of the array\nwhich is same as: 1 + lcs[j]\nTime: $$O(n^2)$$ Space: $$O(n)$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 let MAX = Math.max; var lengthOfLIS = function(a) { /** Appraoch 3: Build the dp table manually using loops **/ let A = a.length; let lis = new Array( A ).fill(1); // global maximum, subsequence length from a[i] until end let gmax = 1; for ( let i = A-2; i \u0026gt;= 0; i-- ) { let max_len = 1; for ( let j = i+1; j \u0026lt; A; j++ ) { if ( a[i] \u0026lt; a[j] ) max_len = MAX( max_len, 1+lis[j] ); } lis[i] = max_len; gmax = MAX( max_len, gmax ); } return gmax; } Approach 4: Build an auxilary array, such that the minium elements are always at the end of it Here, we are basically trying to kick out large elements and inserting small elements whereever possible, so that new incoming elements feel welcome attaching themselves to the existing subsequence.\nBuild a auxilary array using the following algorithm:\nsubsequence = [] For each i \u0026lt;- 0 to A-1 if subsequence.last_element \u0026lt; a[i] subsequence.push( a[i] ) else { replace the largest element smaller than or equal to a[i] in subsequence using binary search. } the length of the subsequence is the length of the largest increasing subsequence. Time: $$O(n\\ log n)$$ // n for iteration, and for each iteration binary search O(log n) Space: $$O(n)$$ // auxilary array Note that the array that we actually build here does not represent a valid increasing subsequence. Nor is it the longest increasing subsequence, we just insert the elements using a particularly methodology which ensures its validity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 let MAX = Math.max; let FLOOR = Math.floor; var b_search = ( a, target ) =\u0026gt; { // return the index pf the number \u0026gt;= target let i = 0, j = a.length-1; while ( i \u0026lt;= j ) { let mid = i + FLOOR( (j-i)/2 ); if ( a[mid] == target ) return mid; else if ( a[mid] \u0026lt; target ) i = mid+1; else j = mid-1; } return i; }; var lengthOfLIS = function(a) { /** Approach 4: The idea is to keep the minium elements, such that validity of lis(longest increasing subsequence) for new incoming elements can be calculated quickly **/ let A = a.length; let sub = [ a[0] ]; for ( let i=1; i \u0026lt; A; i++ ) { let lst = sub.length-1; if ( sub[ lst ] \u0026lt; a[i] ) sub.push( a[i] ); else { // find a \u0026#34;write index\u0026#34; where we replace a[i] let wi = b_search( sub, a[i] ); sub[wi] = a[i]; } } return sub.length; } Approach 5: In place algorithm for approach 4 Time: $$O(n\\ logn)$$ Space: $$O(1)$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 let MAX = Math.max; let FLOOR = Math.floor; /* this version is for searching within the same array starting and ending position are requirede */ var b_search = ( a, start, end, target ) =\u0026gt; { // return the index pf the number \u0026gt;= target let i = start, j = end; while ( i \u0026lt;= j ) { let mid = i + FLOOR( (j-i)/2 ); if ( a[mid] == target ) return mid; else if ( a[mid] \u0026lt; target ) i = mid+1; else j = mid-1; } return i; }; var lengthOfLIS = function(a) { /*** Approach 5: Same as the above approach, but in place Hence saving auxilary space. The idea is to keep a variable to mark the end of the subsequence in a itself. **/ let A = a.length; let S = 1; // variable to mark the end of the subsequence for ( let i=1; i \u0026lt; A; i++ ) { if ( a[S-1] \u0026lt; a[i] ) { a[S] = a[i]; S++; } else { // find a \u0026#34;write index\u0026#34; where we replace a[i] let wi = b_search( a, 0, S-1, a[i] ); a[wi] = a[i]; } } return S; } ","permalink":"http://localhost:45763/personal_website/posts/all_possible_solutions_to_longest_increasing_subsequence_problem_leetcode_300/","summary":"\u003cp\u003eHere are all possible solutions I could come up with for the longest\nincreasing subsequence problem. \u003ca href=\"https://leetcode.com/problems/factorial-trailing-zeroes/description/\"\u003eleetcode\n300\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"approach-1-generate-all-possible-increasing-subsequences\"\u003eApproach 1: Generate all possible increasing subsequences\u003c/h1\u003e\n\u003cp\u003eWe will keep track of a subsequence in an array named \u003ccode\u003ecur_subsequence\u003c/code\u003e\nor \u003ccode\u003ecur_sub\u003c/code\u003e. For each element (\u003ccode\u003ea[i]\u003c/code\u003e)  we have the following 2\noptions:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eAdd the element to the end of current subsequence.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eNote: The current element can only be included if\neither the current subsequence is empty or the last\nelement of the current subsequence is smaller than\nthe current element. This is important to maintain\nthe increasing subsequence property.\u003c/em\u003e\u003c/p\u003e","title":"All possible solutions to longest increasing subsequence problem: leetcode 300"},{"content":"Problem link: leetcode 70: climbing stairs\nIntuition You need to climb n stairs, taking 1 or 2 stairs at a time.\nIf n = 2, you can climb like:\n$$1+1 = 2\\times (1) + 0 \\times(2)$$ $$2 = 0 \\times (1) + 1\\times(2) $$ if n = 3, you can climb like:\n$$1+1+1 = 3\\times(1) + 0\\times(2)$$ $$1+2 = 1\\times(1) + 1\\times(2)$$ $$2+1 = 1\\times(1) + 1\\times(2) $$ Basically you first need to decide how many steps of size 1 will you take and how many of size 2 do you need:\nHence, your first task is to solve the equation:\n$$ x \\times 1 + y \\times 2 = n $$\nTo decide the number of 1s and 2s. After you decide upon x and y then you will have calculate $$ \\frac{(x + y)!}{x! , y!} $$\nWhich is nothing but ways of chosing how exactly you will proceed. This is because we are trying to adjust x identical objects and y identical objects in x+y positions. Think of the number of ways you can arrange x men and y women in x + y positions.\nAs an example $$n=3, x=1 $$ and $$y=1$$\nThen you will have $$\\frac{(1 + 1)!}{1! , 1!} =2$$. see above, they are: $$ 1+2 \\ 2+1 $$\nApproach $$ y \\in [0, n/2] $$\nFor each , calculate the corresponding values of $$x$$ using the equation: $$ x \\times 1 + y \\times 2 = n \\ x = n - (2 \\times y ) $$\nthen calculate $$ \\frac{(x + y)!}{x! , y!} $$\nand add this to your counter variable.\nreturn counter.\nComplexity Time complexity: Time: O($$n^2$$)\nSpace: O(1)\nBut it can be reduced, if you can store calculated factorials. Hence, making the time complexity of calculating $$ \\frac{(x + y)!}{x! , y!} $$ -\u0026gt; O(1) and Space complexity O(n)\nTime complexity: O(n) Space complexity: O(n)\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 var permute = (x,y) =\u0026gt; { /* compute (x+y)! / x! y! without computing factorials */ /* which is basically computing x+y x+y-1 x+y-2 .. y+1 / x! */ var denom = 1; for (var i=1; i \u0026lt;= x; i++) denom *= i; var numi = 1; for (var i = y+1; i \u0026lt;= x+y; i++) numi *= i; return numi/denom; }; var climbStairs = function(n) { /* The number of ways in which we can get n by adding only 1 and 2 Let, 1x + 2y = n ---(1) then we need to find the number of integer solutions to this equation. that is S = {x,y | x,y in integers} we need to return |S| i.e. the number of elements in this solution set. from (1) it implies x = n - 2y ---(2) y in range [0,n/2] i.e. consequently x in range [0,n] hence, iterate over y from 0 to n/2 such that y is integer. we find the corrosponding solution using equation 2 */ let n_solutions = 0 ; for (var y=0; y \u0026lt;= Math.floor(n/2); y++ ) { var x = n - (2 * y); n_solutions += permute(x,y); } return (n_solutions); }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_70/","summary":"\u003cp\u003eProblem link: \u003ca href=\"https://leetcode.com/problems/climbing-stairs/description/\"\u003eleetcode 70: climbing stairs\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"intuition\"\u003eIntuition\u003c/h1\u003e\n\u003c!-- Describe your first thoughts on how to solve this problem. --\u003e\n\u003cp\u003eYou need to climb \u003ccode\u003en\u003c/code\u003e stairs, taking 1 or 2 stairs at a time.\u003c/p\u003e\n\u003cp\u003eIf n = 2, you can climb like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$$1+1 = 2\\times (1) + 0 \\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$2 = 0 \\times (1) + 1\\times(2) $$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eif n = 3, you can climb like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$$1+1+1 =  3\\times(1) + 0\\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$1+2   =  1\\times(1) + 1\\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$2+1   =  1\\times(1) + 1\\times(2) $$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBasically you first need to decide how many steps of size 1 will you take and how many of size 2 do you need:\u003c/p\u003e","title":"Leetcode 70: Climbing Stairs"},{"content":"Below is my C solution for the Leetcode problem candy.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 static inline void previous_kids_started_crying(int* kid, int continous_decrease_start, int continous_decrease_end, int* candy) { /* * To satisfy the condition that each child with higher rating than * it\u0026#39;s neighbors must get more candies. We give all children in range * [continous_decrease_start, continous_decrease_end] an extra candy * if the he has candies lower or equal to the kid after it. * * Note that we do not bother the kid before it, since it is known * that the kid before it has more rating than this kid */ if (continous_decrease_start == -1) { exit(1); } for (int i = continous_decrease_end; i \u0026gt;= continous_decrease_start; i--) { if (kid[i] \u0026lt;= kid[i+1]) { int before = kid[i]; kid[i]++; int after = kid[i]; *candy += after - before;; } else { /* chain is broken. We found a satisfied non protesting kid the kids before it must also be non-protesting */ return; } } } int candy(int* kid, int n) { /* * Few things to take care of: * * 1. At a time take a look at 2 children. i.e. iterate the children * in window of 2. * * 2. Each time a candy is given, check if previous child has more * rating, since he will start crying. He/she will protest that the * kid in front of him has less rating than him/her and still got * more/equal candies than him/her. It might even trigger a chain * where the kid previous to the previous kid might also see this * changed state, and if he had a rating more then the kid after him. * then he will also start asking more candies. And the kid behind * that and so on. * * The algorithm runs in linear time, however, if the children are * arranged in decreasing order of rating, then at each iteration all * previous children will start crying. Hence, everybofy needs to be * given more candies. In that case it becomes quadratic * * Space required is constant. * * Best case: * Time: O(n) * Space: O(1) * * Worst Case: * Time: O(n^2) * Space: O(1) */ int candies = 0; int continous_decrease_from = -1; /* First child gets a candy, but save his rating first */ int previous_child_rating = kid[0]; kid[0] = 1; candies++; for (int i = 1; i \u0026lt; n; i++) { if (kid[i] \u0026gt; previous_child_rating) { /* Since this child has more rating than the previous child, this child gets 1 more candy than previous child */ previous_child_rating = kid[i]; kid[i] = kid[i-1]+1; candies += kid[i]; continous_decrease_from = -1; } else if (kid[i] == previous_child_rating){ /* Since this child has equal rating than the previous child, give him 1 candy */ previous_child_rating = kid[i]; kid[i] = 1; candies++; continous_decrease_from = -1; } else { /* Previous child has more rating. Give this child one candy, and after giving : if the previous child had less candy, then we must initiate a chain reaction to do justice to all previous kids to previous children the problem here is that if this child has less rating then his predecessor then he will also start crying. And, the predecesor of this child also has more score then he will also start crying. Hence, we must give candies to them as well to maintain rule. Hence, check if the rule is disturbed, */ if (continous_decrease_from == -1) { /* A period of continous decrease started */ /* Hence, give this child 1 candy and if the previous child will also get 1 candy if he gets */ continous_decrease_from = i-1; previous_child_rating = kid[i]; kid[i] = 1; if (kid[i-1] \u0026gt; kid[i]) { candies ++; } else { kid[i-1] = kid[i] + 1; candies += 2; } } else { /* Give this child a candy, but mind the children behind this child */ previous_child_rating = kid[i]; kid[i] = 1; candies++; previous_kids_started_crying(kid, continous_decrease_from, i-1, \u0026amp;candies); } } } return candies; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_135/","summary":"\u003cp\u003eBelow is my C solution for the Leetcode problem \u003ca href=\"https://leetcode.com/problems/climbing-stairs/description/\"\u003ecandy\u003c/a\u003e.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e  1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 35\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 36\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 37\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 38\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 39\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 40\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 41\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 42\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 43\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 44\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 45\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 46\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 47\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 48\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 49\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 50\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 51\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 52\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 53\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 54\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 55\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 56\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 57\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 58\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 59\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 60\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 61\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 62\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 63\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 64\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 65\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 66\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 67\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 68\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 69\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 70\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 71\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 72\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 73\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 74\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 75\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 76\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 77\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 78\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 79\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 80\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 81\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 82\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 83\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 84\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 85\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 86\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 87\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 88\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 89\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 90\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 91\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 92\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 93\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 94\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 95\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 96\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 97\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 98\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 99\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e100\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e101\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e102\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e103\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e104\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e105\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e106\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e107\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e108\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e109\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e110\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e111\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e112\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e113\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e114\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e115\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e116\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e117\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e118\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e119\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e120\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e121\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e122\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e123\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e124\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e125\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e126\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e127\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e128\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e129\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e130\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e131\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e132\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e133\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e134\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kr\"\u003einline\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eprevious_kids_started_crying\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_end\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ecandy\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * To satisfy the condition that each child with higher rating than\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * it\u0026#39;s neighbors must get more candies. We give all children in range\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * [continous_decrease_start, continous_decrease_end] an extra candy\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * if the he has candies lower or equal to the kid after it.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Note that we do not bother the kid before it, since it is known\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * that the kid before it has more rating than this kid\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e        */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nf\"\u003eexit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_end\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ebefore\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eafter\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ecandy\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003eafter\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ebefore\u003c/span\u003e\u003cspan class=\"p\"\u003e;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* chain is broken. We found a satisfied non protesting kid\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                          the kids before it must also be non-protesting */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ecandy\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Few things to take care of:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * 1. At a time take a look at 2 children. i.e. iterate the children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * in window of 2.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * 2. Each time a candy is given, check if previous child has more\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * rating, since he will start crying. He/she will protest that the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * kid in front of him has less rating than him/her and still got\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * more/equal candies than him/her. It might even trigger a chain\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * where the kid previous to the previous kid might also see this\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * changed state, and if he had a rating more then the kid after him.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * then he will also start asking more candies. And the kid behind\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * that and so on.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * The algorithm runs in linear time, however, if the children are\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * arranged in decreasing order of rating, then at each iteration all\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * previous children will start crying. Hence, everybofy needs to be\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * given more candies. In that case it becomes quadratic\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space required is constant.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Best case:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Time: O(n)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space: O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Worst Case:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Time: O(n^2)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space: O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e         */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/* First child gets a candy, but save his rating first */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Since this child has more rating than the previous\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         child, this child gets 1 more candy than previous\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         child */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Since this child has equal rating than the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         previous child, give him 1 candy */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Previous child has more rating. Give this child one\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candy, and after giving : if the previous child had less\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candy, then we must initiate a chain reaction to do\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        justice to all previous kids to previous children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        the problem here is that if this child has less rating\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        then his predecessor then he will also start crying.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        And, the predecesor of this child also has more score\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        then he will also start crying. Hence, we must give\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candies to them as well to maintain rule. Hence, check\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        if the rule is disturbed,\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* A period of continous decrease started */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* Hence, give this child 1 candy and if the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                                   previous child will also get 1 candy if he gets  */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* Give this child a candy, but mind the children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                                  behind this child */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"nf\"\u003eprevious_kids_started_crying\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Leetcode 135: Candy"},{"content":"Introduction Linux is the kernel that powers the modern computing world. Its everywherefrom all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isnt about why Linux dominates the tech world; its about how I started contributing to the Linux Kerneland how you can too.\nHow Kernel Development Works Kernel development thrives on the Linux Kernel Mailing List (LKML), the nerve center of Linuxs open-source ecosystem. The beauty of open source? Anyone can contribute. Your task is to send patches (essentially the output of git diff refurbushed into an email).\nIf your patch solves a real problem or adds value, experienced developers will jump in with questions about your intent and rationale. Heres a pro tip: dont explain the how of your code; let the code speak for itself. Instead, focus on explaining why your change is needed.\nThe LKML community is incredibly supportive \u0026ndash; theyll critique your code, point out mistakes, and suggest improvements. Sure, it might feel overwhelming initially, but resources like the LFD103 course can guide you through the basics: generating patches, submitting them to LKML, compiling, and booting the kernel.\nFor me, just setting up my mail client and understanding LKML discussions took about a month. But once you clear these initial hurdles, things get easier. If youre struggling, feel free to check out my notesthey might save you some time.\nMy Background For years, kernel developers seemed like magicians to medoing impossibly cool things with computers. My fascination started after I stumbled upon a video of someone working on the kernel. It was mesmerizing!\nIn my second semester, I discovered the book The C Programming Language, and it sparked my love for C. The control C offers is unmatched, but it comes with its fair share of challengesbugs galore!\nSurprisingly, I wasnt a Linux user until recently. When I finally switched from Windows to Linux, everything just clicked. Concepts that once felt abstract suddenly made sense. On Windows, troubleshooting often felt like solving a mystery even Microsoft couldnt decode. On Linux, it felt like someone handed me the keys to the entire system.\nWhile working on kernel contributions, I read Linux Device Drivers, a book authored by seasoned kernel developers. It gave me a deeper understanding of the kernels inner workings. If youre serious about kernel development or writing drivers, this book is a must-read.\nWhat to Contribute The hardest part of contributing to the Linux Kernel is figuring out what to work on. The kernel is vasttheres everything from GPU drivers to network stack development.\nSince the kernels primary job is managing hardware, driver development is a hotspot of activity. New devices constantly hit the market, and they need drivers. If you have an electronics background and access to hardware, driver development is an excellent starting point.\nIf hardware isnt your thing (like in my case), here are some alternatives:\nkselftest: A testing framework for kernel functionality. Core subsystems: The backbone of the kernela great way to learn the essentials. syzbot reports: A kernel fuzzer that uncovers bugs by feeding the kernel random data. These reports are a goldmine for learning about common mistakes. Another beginner-friendly option is upgrading deprecated APIs. These updates are highly appreciated because they improve the kernels maintainability and security. Its not always a simple find-and-replaceyoull need to understand the codebut its a rewarding way to start.\nAnd dont underestimate fixing spelling and grammar errors in the documentation or comments. While it might sound trivial, its a fantastic way to learn the workflow: creating patches, submitting them, and receiving feedback. Tools like codespell can help you automate finding these errors.\nMy first-ever patch was a simple typo fix, but I made the classic rookie mistake of introducing two changes while documenting only one. Lesson learned!\nOnce you start contributing, youll notice issues everywhere. Even just following discussions on LKML can teach you a ton about how seasoned developers think and work.\nConclusion Kernel development might seem intimidating at first, but trust me, its worth the effort. Youll not only become a stronger developer but also gain a deep understanding of how computers work. Youll build expertise in both kernel and userspace development, and your Git skills will level up immenselya must-have for any programmer.\nThe learning opportunities in kernel development are unparalleled, often rivaling (or even exceeding) those at top tech companies. So if youre considering it, dont hesitatedive in! You might be surprised by how much youll grow.\nGood Luck!\nReferences ","permalink":"http://localhost:45763/personal_website/posts/highlights_from_linux_kernel_mentorship_program_2024/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux is the kernel that powers the modern computing world. Its everywherefrom all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isnt about \u003cem\u003ewhy\u003c/em\u003e Linux dominates the tech world; its about how I started contributing to the Linux Kerneland how you can too.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"how-kernel-development-works\"\u003eHow Kernel Development Works\u003c/h2\u003e\n\u003cp\u003eKernel development thrives on the Linux Kernel Mailing List (LKML), the\nnerve center of Linuxs open-source ecosystem. The beauty of open\nsource? Anyone can contribute. Your task is to send patches (essentially\nthe output of \u003ccode\u003egit diff\u003c/code\u003e refurbushed into an email).\u003c/p\u003e","title":"Highlights from Linux Kernel Mentorship Program 2024 by Abdul Rahim"},{"content":"Introduction Computer memory is usually implemented as a file system. While tampering with data is easy to detect, unauthorized access to memory is a more complex task falling within the domain of Intrusion Detection Systems (IDS). Most intrusion detection systems focus on analyzing network traffic or using machine learning techniques to identify suspicious patterns, we explore if we can employ merkel trees for this task.\nIf unauthorized memory access cannot be detected, users would never know that the system was compromised. Detecting tampered files is straightforward: you can hash the contents of a file, and if the hash changes you might conclude that the file changed. However, detecting memory access is more complicated. Although Linux keeps track of the last access timestamp, available via the stat command1, it only tracks file accesses that use the read() syscall2.\nMerkel Trees Merkle trees are a data structure in which hashes are stored rather than data. Leaf nodes store hashes of particular data blocks, while other nodes store hashes of their children. Merkle trees are widely used in blockchains for their ability to detect data tampering. They provide a robust mechanism to detect tampering in multiple distinct data items. If any data item in a leaf node changes, the whole tree becomes invalidated because it changes the hashes of all nodes up the tree.\nFig. 1: A Merkle tree is a data structure in which each node contains a hash. All non-leaf nodes contain hashes of their children, and all leaf nodes contain hashes of the underlying data.\nMerkel tree as directory tree Now, what we want to do is to augment the directory tree as a merkel tree. To be exact the inode structure (See inode doc for more details).\nDoing this would make us have hashes for children in directory tree. And the benefit of that is whenever the child inodes change, the current inode would change. And there\u0026rsquo;s 2 fields that each node would contain, the last seen hash (expected hash) of it\u0026rsquo;s child and the current hash of the same child. And when the current hash changes to a different value from expected hash, then we can imply that the child inode changed.\nBut one question is that if memory can be accessed bare metal, then the protections done in software doesn\u0026rsquo;t really make any sense. One possible solution to this problem is employing encryption.\nThe encryption should be performed in hardware, and the memory access system calls should define protocols for decrypting the underlying memory. The same system call would update necessary variables of the file in question, such as access time. The memory access system call needs to be implemented so that when one accesses memory, the data is decrypted and other functions are performed.\nBelow is a detailed description.\nArchitecture File system in most operating systems follow a hierarchical structure. We augment this with a Merkle tree, where a node is attached to each file in the file system. These nodes form a Merkle tree, where each node contains the hash of its children (in the case of non-leaf nodes) or the hash of the file data (in the case of files). Additionally, a pollution flag is attached to each node to detect illegal access.\nEach node will also has an expected hash, which is the hash of the node when the subtree below that node was last valid.\nWorking The pollution flag is set if expected_hash != hash, which occurs only on illegal access. I will explain this in a moment.\nWhen a user or process requests memory, it will go through the memory access system call, requiring authentication. Once the authentication is successful, the underlying data is decrypted and returned, the access time is updated, and all the hashes up to the root are updated along with the expected hash (note that the expected hash changes on authorized access). The tree remains valid.\nIf the authentication fails, the memory is not returned, but the access time changes. Consequently, when the tree is re-evaluated, the hash of this node changes since it incorporates the access time, but the expected hash remains the same, setting the pollution flag for this node.\nSince the parent of this node uses its hash, the parent\u0026rsquo;s hash also changes. However, its expected hash remains the same, leading to its invalidation. This process continues up the tree, invalidating the whole tree.\nThe benefit of this approach is that all other nodes remain valid. If one tries to determine which file was accessed and the timestamp, it is easy to identify the exact file by following the invalid nodes from top to bottom.\nRefrences stat man page\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nread syscall\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:45763/personal_website/posts/merkel_trees_and_computer_memory/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003c!-- mine\nComputer memory is usually implemented as a file system. While tampering\nof data is easy to detect, unauthorised access to memory is a more\ncomplex task. A problem that lies in the domain of Intrusion Detection\nSystems. While, most intrusion detection focus on analyzing network\ntraffic, or machine learning techniques to identify suspicious patterns.\nWe propose a method that works within the system, providing robust\naccess detection.\n--\u003e\n\u003cp\u003eComputer memory is usually implemented as a file system. While tampering\nwith data is easy to detect, unauthorized access to memory is a more\ncomplex task falling within the domain of Intrusion Detection Systems\n(IDS). Most intrusion detection systems focus on analyzing network traffic or\nusing machine learning techniques to identify suspicious patterns, we\nexplore if we can employ merkel trees for this task.\u003c/p\u003e","title":"Merkel Trees and computer memory"},{"content":"Introduction When you install vim, a usual requirement as with all text editors is the ability to copy to/from system clipboard so you can lets say, copy something into your vim session from firefox or vice versa, however copy pasting in terminal editors is not as straight forward as with GUI editors. In vim if you want to copy something into an auxilary space (anticipating it would be used later, so you can paste from this auxilary space) is achieved by registers.\nThe register that represents system clipboard is + register. Anything that you copy into this register is available in system clipboard.\nHow to use registers to copy/paste To copy a text into a register, select it in visual mode and press \u0026quot;\u0026lt;register_name\u0026gt;y to yank the contents into the given register. And to paste the contents of a particular register at current position, use \u0026quot;\u0026lt;register_name\u0026gt;p.\nTo use system clipboard, you just have to substitute \u0026ldquo;+\u0026rdquo; for register name in the above commands.\nclipboard support But the + register wont work unless you have clipboard support with your vim installation. By default there is no clipboard support in vim.\nTo check if your vim installation has clipboard support use:\n1 2 3 $ vim --version | grep clipboard +clipboard +keymap +printer +vertsplit +ex_extra +mouse_netterm +syntax +xterm_clipboard or inside of vim, you can run the command:\n1 :echo has(\u0026#39;clipboard\u0026#39;) If the output is 0, your installation doesnt have clipboard support.\nCompiling vim Now there are 2 solutions to this problem:\nEither install gvim: Or compile vim from sources with clipboard support Let\u0026rsquo;s see how each of them can be done.\nInstall gvim To install gvim run:\nOn Debian:\n1 sudo apt install vim-gtk On Fedora\n1 sudo dnf install gvim To compile vim with clipboard support Below are the simple steps:\nStep 1: Grab the sources Clone the repository:\n1 2 git clone https://github.com/vim/vim.git vim cd vim Step 2: Install dependencies Install the required libraries and tools to build vim, for example gcc, x11 etc. Note that you only need them to compile vim and you are free to delete them once you are done.\nOn Debian:\n1 sudo apt install build-essential libx11-dev libncurses5-dev On Fedora:\n1 2 3 4 sudo dnf groupinstall \u0026#34;Development Tools\u0026#34; sudo yum install gcc sudo yum groupinstall \u0026#34;X Software Development\u0026#34; sudo dnf install libX11-devel ncurses-devel Also, you need to remove the existing installation(if any).\nOn Debian\n1 sudo apt remove vim On Fedora\n1 sudo dnf remove vim gvim Step 3: Configure and Compile Configure vim with features of your choice\n1 2 3 4 5 6 7 ./configure \\\\ --enable-cscope \\\\ --enable-gui=auto \\\\ --enable-gtk2-check \\\\ --enable-gnome-check \\\\ --with-features=huge \\\\ --with-x Then compile and install with:\n1 2 make sudo make install Conclusion In this article we learned how can we compile vim with clipboard support, you can also tweak configuration according to your requirements. There are many configuration options available.\n","permalink":"http://localhost:45763/personal_website/posts/how_to_compile_vim_with_clipboard_support/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eWhen you install vim, a usual requirement as with all text editors is\nthe ability to copy to/from system clipboard so you can lets say, copy\nsomething into your vim session from firefox or vice versa, however copy\npasting in terminal editors is not as straight forward as with GUI\neditors. In vim if you want to copy something into an auxilary space\n(anticipating it would be used later, so you can paste from this\nauxilary space) is achieved by \u003cstrong\u003eregisters\u003c/strong\u003e.\u003c/p\u003e","title":"How to compile vim with clipboard support"},{"content":" Introduction I had an unused phone lying around for some time, and I began contemplating how I could repurpose it. This led me to reflect on the impressive performance of modern smartphones and consider whether they could be utilized as servers.\nSmartphones are equipped with ARM-based processors and run on Android, which is itself built on the Linux kernel. ARM processors are renowned for their energy efficiency1 and have recently found applications in the server space2.\nAs someone who enjoys exploring the full potential of devices, I embarked on a journey to discover how I could leverage the full potential of smartphones.\nSetup Although, you would like to run your programs on phones, but programming on phones typing on screen is a horrifying idea. Fortunately, you dont have to type on your phone, what you can do is you can access its terminal, using protocols like ssh/telnet etc.\nSo, firstly you would need a terminal to control a machine remotely. Unfortunately, there are not, alot of choices available in phone space when it comes to terminal emulators. Termux is one of the few available options.\nAfter you manage to open a terminal remotely, then from there its pretty frictionless. You can install the software of your choice and write, compile and run your programs. You might also find it helpful to root your phone for root privilages, which will help you run all commands. But please beware that rooting can null your warrenty, check with local expert. If termux does\u0026rsquo;nt work for you then there are also other options like kali net hunter.\nSo, in total, we need to install termux, then we would setup ssh.\nTermux Termux is an open source terminal emulator for android. In essence, it provides you with a linux environment, within android, The only difference between actual linux environment and termex is that it is not FHS(File System Hierarcy) compliant, i.e. it does not strictly follow linux file system conventions. The consequences of that are that #! /usr/bin/sh may not work, so you have to watch out the paths. Other than that, it supports almost all commands on linux.\nMoreover, It is an app that does\u0026rsquo;nt interfere with your system so you can run your android as normal, moreover it runs without root privilages. It comes with a large repository of software found at packages.termux.dev.\nBelow are the steps to setup ssh in termux Step 1: Download texmux on playstore, f-droid or from github releases\nStep 2: Update using pkg:\n1 2 pkg update # update the repositories pkg upgrade # upgrade all to latest versions Run this commands\nStep 3: Install ssh 1 pkg install ssh install ssh\nStep 4: Set a password Setup a password that you will use to login\n1 passwd set password and note username\nStep 5: Note your username You will require username and ip address when logging in using ssh, hence note them. Run the command whoami the know your username. This will generally start with \u0026ldquo;a0_\u0026rdquo;\n1 whoami Step 6: Note your IP address You can check your IP address in:\n1 2 3 settings \u0026gt; Wi-Fi \u0026gt; click on the (i) button, on the wifi you are connected to and Look for IPv4 address Step 7: Run ssh doemon in termux On your phone, run the ssh daemon using\n1 sshd Step 8: Login form your computer On your computer, use the following command to login into your phone and access its terminal\n1 ssh \u0026lt;user_name\u0026gt;@\u0026lt;IP_address\u0026gt; -p 8022 The username and IP address we already determined in step 5 and 6 resp. Note that it will promt you for password\nAftermath You can use scp command to transfer files between your computer and phone. In case you want to do development, there are a number of programming packages available in termux, you can find rust, nodejs, python, C/C++ and tools for many other programming languages.\nConclusion So, now you have successfully installed ssh in your android phone. You might find it useful to install vim, git, gcc etc. There is a large repository of packages in termux, which covers pretty much everything your would need.\nFurther Reads Simili, Emanuele, et al. \u0026ldquo;Power Efficiency in HEP (x86 vs. arm).\u0026rdquo; Power (W) 350.400 (2023): 450\u0026#160;\u0026#x21a9;\u0026#xfe0e;\narm_server\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:45763/personal_website/posts/how_to_turn_your_old_smartphone_into_a_home_server/","summary":"\u003c!--\n---\ndate: '2025-07-15T22:33:11+05:30'\ndate: ''\ntitle: 'How_to_turn_your_old_smartphone_into_a_home_server'\n---\n--\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eI had an unused phone lying around for some time, and I began\ncontemplating how I could repurpose it. This led me to reflect on the\nimpressive performance of modern smartphones and consider whether they\ncould be utilized as servers.\u003c/p\u003e\n\u003cp\u003eSmartphones are equipped with ARM-based processors and run on Android,\nwhich is itself built on the Linux kernel. ARM processors are renowned\nfor their energy efficiency\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e and have recently found\napplications in the server space\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e","title":"How to turn your old smartphone into a home server"},{"content":"For each possible word, we ask the question: What possible queries can lead to this word?.\nFor example consider the word: abd. Below are the possible (prefix, suffix) queries that can return abd\n1 2 3 4 5 6 7 8 9 10 (prefix, suffix) a abd a bd a d ab abd ab bd ab d abd abd abd bd abd d Now, given word.length \u0026lt;= 7. Each word can at maximum generate 7*7=49 such pairs. Can we store all of them in a hashmap? Yes, because the total storage = 49 * number of words = O(n) Which is acceptable for this problem.\nWhat if there is already a value for (prefix,suffix) in current word. Shall we override it. We need the latest index right?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class WordFilter: def __init__(self, words: List[str]): self.map = {} for widx, w in enumerate(words): for i in range( len(w) ): prefix = w[:i+1] for j in range( len(w) ): suffix = w[j:] # for all possible prefix suffix queries that might route # to current word. We set it in dictionary overriding previously # inserted values to get the maximum index key = prefix + \u0026#39;|\u0026#39; + suffix self.map[key] = widx def f(self, pref: str, suff: str) -\u0026gt; int: key = pref + \u0026#39;|\u0026#39; + suff return self.map.get(key, -1) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_745_prefix_and_suffix_search_solution/","summary":"\u003cp\u003eFor each possible word, we ask the question: \u003cstrong\u003eWhat possible queries can lead to this word?\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor example consider the word: \u003ccode\u003eabd\u003c/code\u003e. Below are the possible (prefix, suffix) queries that can return \u003ccode\u003eabd\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(prefix, suffix)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    d\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  d\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  d\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eNow, given word.length \u0026lt;= 7. Each word can at maximum generate \u003ccode\u003e7*7=49\u003c/code\u003e such pairs. Can we store all of them in a hashmap? Yes, because the total storage = \u003ccode\u003e49 * number of words = O(n)\u003c/code\u003e Which is acceptable for this problem.\u003c/p\u003e","title":"Leetcode 745: prefix and suffix search solution"},{"content":"This problem is very similar to lc543, which is about finding the longest edge path in a tree. You can just copy over that code, and add 2 lines in it.\nHere we are doing the same thing as in lc543, however, when we encounter a non-matching child. We treat it as null.\nFor example, here the longest path at root node is highlighted below in red with 6 edges.\nOur algorithm views the tree like this. The longest path of 3 edges is highlighted in red.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int edges( struct TreeNode* node ); int longest_path; int longestUnivaluePath(struct TreeNode* root) { longest_path = 0; edges(root); return longest_path; } int edges( struct TreeNode* node ) { if ( !node ) return -1; int left = edges(node-\u0026gt;left), right = edges(node-\u0026gt;right); // treat child as null if it doesn\u0026#39;t match parent left = (node-\u0026gt;left \u0026amp;\u0026amp; node-\u0026gt;val == node-\u0026gt;left-\u0026gt;val) ? left : -1; right = (node-\u0026gt;right \u0026amp;\u0026amp; node-\u0026gt;val == node-\u0026gt;right-\u0026gt;val) ? right : -1; longest_path = fmax(longest_path, 1+left + 1+right); return 1 + fmax( left, right); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution: def __init__(self): self.ans = 0 def longestUnivaluePath(self, root: Optional[TreeNode]) -\u0026gt; int: self.edges( root ) return self.ans def edges(self, node: Optional[TreeNode]) -\u0026gt; int: if not node: return -1 left, right = self.edges( node.left ), self.edges( node.right ) # if the child is illegitimate. Discard it if not node.left or node.left.val != node.val: left = -1 # treat as null if not node.right or node.right.val != node.val: right = -1 self.ans = max( self.ans, ( 1+left ) + ( 1 + right ) ) return 1 + max( left, right ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function longestUnivaluePath(root: TreeNode | null): number { let ans = 0; const edges = ( node: TreeNode|null ): number =\u0026gt; { if ( !node ) return -1; let left = edges( node.left ), right = edges( node.right ); // if child value doesn\u0026#39;t match -\u0026gt; treat as null left = (node.left \u0026amp;\u0026amp; node.val == node.left.val) ? left : -1; right = (node.right \u0026amp;\u0026amp; node.val == node.right.val) ? right : -1; ans = Math.max( ans, (1 + left) + (1 + right) ); return 1 + Math.max( left, right ); } edges( root ); return ans; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function longestUnivaluePath(root) { let ans = 0; const edges = ( node ) =\u0026gt; { if ( !node ) return -1; let left = edges( node.left ), right = edges( node.right ); // if child value doesn\u0026#39;t match -\u0026gt; treat as null left = (node.left \u0026amp;\u0026amp; node.val == node.left.val) ? left : -1; right = (node.right \u0026amp;\u0026amp; node.val == node.right.val) ? right : -1; ans = Math.max( ans, (1 + left) + (1 + right) ); return 1 + Math.max( left, right ); } edges( root ); return ans; }; ","permalink":"http://localhost:45763/personal_website/posts/solution_to_leetcode_687_longest_univalue_path/","summary":"\u003cp\u003eThis problem is very similar to\n\u003ca href=\"https://leetcode.com/problems/diameter-of-binary-tree/solutions/6824338/solution-for-dummies-by-abdulrahim2002-yzrs/\"\u003elc543\u003c/a\u003e,\nwhich is about finding the longest edge path in a tree. You can just\ncopy over that code, and add 2 lines in it.\u003c/p\u003e\n\u003cp\u003eHere we are doing the same thing as in lc543, however, when we encounter a non-matching child. We treat it as null.\u003c/p\u003e\n\u003cp\u003eFor example, here the longest path at root node is highlighted below in red with 6 edges.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/148ffbfd-0ead-48cd-b45d-8c2575bafd11_1751999234.494938.png\"\u003e\u003c/p\u003e","title":"Solution to Leetcode 687: Longest Univalue Path"},{"content":"I keep track of the top k elements in sorted list. The kth largest element is the smallest of the top k elements.\ne.g. top k(=6) elements: [3,5,7,10,42,56] in sorted order. The kth largest element = 6th largest element = smallest element in above list.\nWhen I insert an element, I simply check if it can make it\u0026rsquo;s place among k largest elements already present in the list. Which it can, if it can defeat the smallest element in our list.\nFor example, we cannot add 2 in the array above since it fails to defeat 3.\nHowever, A number like 15 can be inserted. In which case, we remove the smallest element i.e. 3, to keep the list length=k\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class KthLargest: def __init__(self, k: int, nums: List[int]): self.scores = SortedList() self.limit = k for num in nums: self.add(num) def add(self, val: int) -\u0026gt; int: # if the current element can make space in top k elements if len(self.scores) \u0026lt; self.limit or self.scores[0] \u0026lt; val: self.scores.add(val) # remove smallest if len(self.scores) \u0026gt; self.limit: self.scores.pop(0) # return smallest return self.scores[0] ","permalink":"http://localhost:45763/personal_website/posts/leetcode_703_kth_largest_element_in_a_stream/","summary":"\u003cp\u003eI keep track of the top k elements in sorted list.\nThe kth largest element is the \u003cstrong\u003esmallest of the top k elements\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003ee.g. top k(=6) elements: \u003ccode\u003e[3,5,7,10,42,56]\u003c/code\u003e in sorted order.\nThe kth largest element = 6th largest element = smallest element in above list.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/070564ea-afa3-4108-92e6-7fa76c2fb981_1752504996.0140414.png\"\u003e\u003c/p\u003e\n\u003cp\u003eWhen I insert an element, I simply check if it can make it\u0026rsquo;s place among k largest elements already present in the list. Which it can, if it can defeat the smallest element in our list.\u003c/p\u003e","title":"Leetcode 703: kth largest element in a stream solution in python"},{"content":"When numbers from $$\\in$$ [0,n-1] are sorted in an array of size n. Their sorted position is equal to their index.\nSubset of numbers in array[i:j] can form a partition, if all elements in [i,j) are available in array[i:j].\nFor example [2,0,1] can form a partition, since they are at index 0, 1, 2 respectively. Sorted will involving swapping them at their correct position.\nThe basic idea behind this solution is that we try to identify such partitions, where all elements required to be sorted in [i, j] are available in current partition.\nHere\u0026rsquo;s the visualization of the algorithm, i points to the start of the group and j iterates through the group and checks if the current group needs to be expanded. e points to the end of the current group.\nSince, array[j]=1, we found a number greater than current boundaries. We need to expand the boundary. Hence, new group end is e = array[j].\nIncrement j. We find that array[1] = 0 which is \u0026lt; current end. Increment j again, j=2, Hence, no we exhaust the current group and we move forward to finding the next partition. Increase, current group ending, and reinitialize i=e/\nIn the second group, we have array[j]=2 and we are at index 2. Hence, we do not need to expand this group, since 2 is at right position.\nSimilarly we find the next 2 partitions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int maxChunksToSorted(int* arr, int arrSize) { int cur_gp_end = 0, cnt_gps = 0, i = 0; while ( i \u0026lt; arrSize ) { int j = i; // try to terminate the current group while ( j \u0026lt;= cur_gp_end ) { cur_gp_end = fmax( cur_gp_end, arr[j] ); j++; } i = ++cur_gp_end; cnt_gps++; } return cnt_gps; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_769_max_chunks_to_make_sorted/","summary":"\u003cp\u003eWhen numbers from $$\\in$$ \u003ccode\u003e[0,n-1]\u003c/code\u003e are sorted in an array of size n. Their sorted position is equal to their index.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/07a3b1d2-9478-486f-9f62-3a67e6dde1b3_1752513551.205261.png\"\u003e\u003c/p\u003e\n\u003cp\u003eSubset of numbers in \u003ccode\u003earray[i:j]\u003c/code\u003e can form a partition, if all elements in \u003ccode\u003e[i,j)\u003c/code\u003e are available in \u003ccode\u003earray[i:j]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFor example \u003ccode\u003e[2,0,1]\u003c/code\u003e can form a partition, since they are at index \u003ccode\u003e0, 1, 2\u003c/code\u003e respectively. Sorted will involving swapping them at their correct position.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/77d9235f-d72a-416a-bd77-d8802d7567b0_1752513786.651974.png\"\u003e\u003c/p\u003e\n\u003cp\u003eThe basic idea behind this solution is that we try to identify such partitions, where all elements required to be sorted in \u003ccode\u003e[i, j]\u003c/code\u003e are available in current partition.\u003c/p\u003e","title":"Leetcode 769: Max chunks to make sorted solution"},{"content":"For each word, we basically store all versions of it after removal of 1 character. For example,\n1 2 3 4 5 6 hello -\u0026gt; ello -\u0026gt; removed h@0 hllo -\u0026gt; removed e@1 helo -\u0026gt; removed l@2 helo -\u0026gt; removed l@3 hell -\u0026gt; removed o@4 We can store: wordAfterRemoval,indexOfRemoval in hashmap. So whenever we search for a word like: hexlo then we can try removing it\u0026rsquo;s 2nd index and search: helo,2 in the map, which we will find.\nIn the value we can store the removed character. For example, store key=helo,2 with value=l to indicate that l was removed.\nSo when you match a word like hexlo. Try to search helo,2 in the hashmap. It gives value=l which is !='x' i.e. the removed character in hexlo.\nHowever, there is one problem with this approach. When you add 2 words like: hello and hallo in the map. Then hllo,1 will give e in the first insertion and a in the second. The second overides the first so hello is forgetten by the structure. To avoid this issue, we store both of them (e, a) in a list.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class MagicDictionary { private map = new Map\u0026lt;string,string[]\u0026gt;(); buildDict(dictionary: string[]): void { for ( const word of dictionary ) { for ( let i=0; i \u0026lt; word.length; i++ ) { const wordAfterRemoval = word.slice(0, i) + word.slice(i+1); // key stores wordAfterRemoval,indexOfRemoval as value const key = `${wordAfterRemoval},${i}`; if ( !this.map.has(key) ) this.map.set(key,[]); // values have the removed character this.map.get(key).push( word[i] ) } } } search(word: string): boolean { for ( let i=0; i \u0026lt; word.length; i++ ) { const wordAfterRemoval = word.slice(0, i) + word.slice(i+1); const key = `${wordAfterRemoval},${i}`; if ( !this.map.has(key) ) continue; const removedChars = this.map.get(key); // If there was a word with removed character != word[i] for ( let j=0; j \u0026lt; removedChars.length; j++ ) { if ( removedChars[j] !== word[i] ) return true; } } return false; } } You can also embed the index information by replacing the removed word with _ like in this pyton version:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class MagicDictionary: def __init__(self): self.map = {} def buildDict(self, dictionary: List[str]) -\u0026gt; None: for word in dictionary: for i in range(len(word)): key = word[0:i] + \u0026#39;_\u0026#39; + word[i+1:] if not key in self.map: self.map[key] = [] self.map[key].append(word[i]) def search(self, searchWord: str) -\u0026gt; bool: for i in range(len(searchWord)): key = searchWord[0:i] + \u0026#39;_\u0026#39; + searchWord[i+1:] if key not in self.map: continue for c in self.map[key]: if c != searchWord[i]: return True return False # Your MagicDictionary object will be instantiated and called as such: # obj = MagicDictionary() # obj.buildDict(dictionary) # param_2 = obj.search(searchWord) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_676_magic_dictionary/","summary":"\u003cp\u003eFor each word, we basically store all versions of it after removal of 1 character. For example,\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehello -\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eello -\u0026gt; removed h@0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehllo -\u0026gt; removed e@1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehelo -\u0026gt; removed l@2\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehelo -\u0026gt; removed l@3\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehell -\u0026gt; removed o@4\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eWe can store: \u003ccode\u003ewordAfterRemoval,indexOfRemoval\u003c/code\u003e in hashmap. So whenever we search for a word like: \u003ccode\u003ehexlo\u003c/code\u003e then we can try removing it\u0026rsquo;s 2nd index and search: \u003ccode\u003ehelo,2\u003c/code\u003e in the map, which we will find.\u003c/p\u003e","title":"Leetcode 676: magic dictionary"},{"content":"consider the word \u0026ldquo;catsdogcats\u0026rdquo;. We have the dictionary: [\u0026quot;cat\u0026quot;,\u0026quot;cats\u0026quot;,\u0026quot;catsdogcats\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;dogcatsdog\u0026quot;,\u0026quot;hippopotamuses\u0026quot;,\u0026quot;rat\u0026quot;,\u0026quot;ratcatdogcat\u0026quot;]\nWe iterate over the word: catsdogcats and at each iteration, we ask if the prefix is contained in dictionary.\nIf the prefix is in the dictionary, we recursively call the function on the remaining word (excluding matched prefix)\nis c in dictionary ? is ca in dictionary ? is cat in dictionary ? -\u0026gt; YES call( sdogcats ) \u0026ndash;[1] Prefix cat matched so recursively call with sdogcats\nis s in dictionary ? is sd in dictionary ? \u0026hellip;. is sdogcats in dictionary ? NO We exhausted the word so we return false. Nothing was matched\nBack at the first call, this time we try to match cats Return to [1]\nis cats in dictionary -\u0026gt; YES recursively call on dogcats\nis d in dictionary ?\nis do in dictionary ?\nis dog in dictionary ? -\u0026gt; YES, recursively call on cats\nis c in dictionary ?\nis ca in dictionary ?\nis cat in dictionary ? YES , recursively call(s) \u0026ndash;[2]\nis s in dictionary ? NO -\u0026gt; word exhausted, return false;\nBack at recursive call [2]\nis cats in dictionary ? YES recursively call(``) i.e. empty string When we reach empty string, it means whole of string can be constructed using words in dictionary. Hence return true.\nImport considerations:\nThe dictionary has all the words, which means that catsdogcats will match with itself completely. To avoid words matching with themselves, we tell the function to ignore the catsdogcats word to avoid matching it with itself. Also, we can memoize the results since, dictionary remains the same, only target word and ignore word changes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function findAllConcatenatedWordsInADict(words: string[]): string[] { const dict = new Set\u0026lt;string\u0026gt;( words ); return words.filter( curWord =\u0026gt; canChunk( curWord, curWord, dict ) ); }; function canChunk( target: string, ignore: string, dict: Set\u0026lt;string\u0026gt;, memo = new Map\u0026lt;string, boolean\u0026gt;() ): boolean { if ( !target.length ) return true; const key = target + ignore; if ( memo.has( key ) ) return memo.get( key ); for ( let i=1; i \u0026lt;= target.length; i++ ) { const prefix = target.slice( 0, i ); if ( prefix !== ignore \u0026amp;\u0026amp; dict.has( prefix ) \u0026amp;\u0026amp; canChunk( target.slice( i ), ignore, dict, memo ) ) { memo.set( key, true ); return true; } } memo.set( key, false ); return false; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_472_concatenated_words/","summary":"\u003cp\u003econsider the word \u0026ldquo;catsdogcats\u0026rdquo;. We have the dictionary: \u003ccode\u003e[\u0026quot;cat\u0026quot;,\u0026quot;cats\u0026quot;,\u0026quot;catsdogcats\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;dogcatsdog\u0026quot;,\u0026quot;hippopotamuses\u0026quot;,\u0026quot;rat\u0026quot;,\u0026quot;ratcatdogcat\u0026quot;]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWe iterate over the word: \u003ccode\u003ecatsdogcats\u003c/code\u003e and at each iteration, we ask if the prefix is contained in dictionary.\u003c/p\u003e\n\u003cp\u003eIf the prefix is in the dictionary, we recursively call the function on the remaining word (excluding matched prefix)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eis \u003ccode\u003ec\u003c/code\u003e in dictionary ?\u003c/li\u003e\n\u003cli\u003eis \u003ccode\u003eca\u003c/code\u003e in dictionary ?\u003c/li\u003e\n\u003cli\u003eis \u003ccode\u003ecat\u003c/code\u003e in dictionary ? -\u0026gt; YES       call( \u003ccode\u003esdogcats\u003c/code\u003e ) \u0026ndash;[1]\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePrefix \u003ccode\u003ecat\u003c/code\u003e matched so recursively call with \u003ccode\u003esdogcats\u003c/code\u003e\u003c/p\u003e","title":"Leetcode 472: Concatenated words"},{"content":"The task is to find a subarray with sum of elements = k\nTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\nThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\n$$ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k] $$\nNow we are looking for sub of subarray = T(target). Therefore:\n$$ sum\\ of\\ subarray = prefix\\ [j]\\ -\\ prefix\\ [i-1] = T\\ \\ prefix\\ [i-1] = prefix\\ [j]\\ - T $$\nTherefore, we iterate the prefix array. And at each prefix[j], we search for a previously inserted prefix[i-1] such that prefix[i-1] = prefix[j] - T. We also need the count of such subarrays. At a particular j the number of subarrays where sum=T is the number of i that occured previously such that prefix[i-1] = prefix[j] - T. Index j will form a subarray with each of such previous i\u0026rsquo;s.\nWe must store the mapping: ( prefix[x], count ) in a map.\nSo far so good. But what happens when $$i=0$$. In this case, sum of subarray between indices [0, j] is defined as:\n$$ prefix\\ [j] = \\sum_{k=0}^j nums\\ [k] = T $$\nAt each index j, the code will try to look for prefix[j] - T in the map. When prefix[j]=T itself, then it would look for T-T=0 into the map. Therefore we must keep prefix= 0, count= 1 into the map to account for subarrays starting at index 0.\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 function subarraySum(nums: number[], k: number): number { const map = new Map\u0026lt;number, number\u0026gt;([ [0, 1] ]); let sumk = 0; for ( let j=0; j \u0026lt; nums.length; j++ ) { nums[j] = ( j==0 ) ? nums[j] : nums[j-1] + nums[j]; sumk += map.get( nums[j] - k ) ?? 0; map.set( nums[j], ( map.get(nums[j]) ?? 0 ) + 1 ); } return sumk; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_560_subarray_sub_equal_k_solution/","summary":"\u003cp\u003eThe task is to find a subarray with \u003ccode\u003esum of elements = k\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\u003c/p\u003e\n\u003cp\u003eThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\u003c/p\u003e\n\u003cp\u003e$$\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k]\n$$\u003c/p\u003e","title":"Leetcode 560: Subarray sum equals k"},{"content":"Consider the array: [0,1,1,0,0,1,1,0,1,1] The idea is to turn the 0\u0026rsquo;s into -1\u0026rsquo;s\narray: [-1,1,1,-1,-1,1,1,-1,1,1]\nNow, the task is to find a subarray with sum of elements = 0\nTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\nThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\n$$ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k] $$\nAnd the length of the subarray between indices $$[i,j]$$ is defined as: $$length(i,j) = j-i+1 = j-(i-1) $$\nNow we are looking for sub of subarray = 0. Therefore:\n$$ sum\\ of\\ subarray = prefix\\ [j]\\ -\\ prefix\\ [i-1] = 0\\ prefix\\ [j]\\ =\\ prefix\\ [i-1] $$\nTherefore, we iterate the prefix array. And at each prefix[j], we search for a previously inserted prefix[i-1] such that prefix[j]=prefix[i-1]. We record the length of the current subarray as: length = j-(i-1).\nWe must store the mapping: ( prefix[k], k ) in a map to achieve this.\nSo far so good. But what happens when $$i=0$$. In this case, sum of subarray between indices [0, j] is defined as:\n$$ prefiix\\ [j] = \\sum_{k=0}^j nums\\ [k] $$\nAnd the length of the subarray [0,j] is: $$j+1 = j-(-1)$$\nTherefore we keep a superficial (prefix = 0, index = -1) in the map.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function findMaxLength(nums: number[]): number { const map = new Map\u0026lt;number, number\u0026gt;( [ [0, -1], ] ); let maxLen = 0; for ( let j=0; j \u0026lt; nums.length; j++ ) { let cur = ( nums[j] == 1 ) ? 1 : -1; nums[j] = ( j==0 ) ? cur : cur + nums[j-1]; // prefix sum occured previously at i. Length = j-i if ( map.has( nums[j] ) ) { let i = map.get( nums[j] ); maxLen = Math.max( maxLen, j - i ); } // put the current prefix sum into map if ( !map.has( nums[j] ) ) map.set( nums[j], j ); } return maxLen; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_525_contiguous_array/","summary":"\u003cp\u003eConsider the array: \u003ccode\u003e[0,1,1,0,0,1,1,0,1,1] \u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe idea is to turn the 0\u0026rsquo;s into -1\u0026rsquo;s\u003c/p\u003e\n\u003cp\u003earray: \u003ccode\u003e[-1,1,1,-1,-1,1,1,-1,1,1]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eNow, the task is to find a subarray with \u003ccode\u003esum of elements = 0\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\u003c/p\u003e\n\u003cp\u003eThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\u003c/p\u003e\n\u003cp\u003e$$\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k]\n$$\u003c/p\u003e","title":"Leetcode_525_contiguous_array"},{"content":"The idea is to keep 2 pointers. trail pointer and cur pointer. The list is build in recursive function build(trail, cur) which returns last node of the list we build.\nbuild works as follows:\nwhen there is no child node: simply connect trail and cur and advance both when there is a child node, then recursively call itself with build( trail = cur, cur = cur.child ). The call would connect cur node with the list in the next level. It would return the last node in next level. Then we assign trail = last node in next level and cur = cur.next in current level. This ensures that the next iteration would connect last node in next level to next node in current level. when cur becomes null trail is the last node in current level. return trail Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function flatten(head: _Node | null): _Node | null { const save: _Node = new _Node( -1 ); build( save, head ); if ( save.next ) save.next.prev = null; return save.next; }; function build( trail: _Node | null, cur: _Node | null ): _Node | null { while ( cur ) { if ( !cur.child ) { trail.next = cur; cur.prev = trail; trail = trail.next; cur = cur.next; } else { trail.next = cur; cur.prev = trail; const saveNext = cur.next; const lastNodeFromChildList = build( cur, cur.child ); cur.child = null; cur = saveNext; trail = lastNodeFromChildList; } } return trail; } Complexity Time complexity: $$O(n)$$\nSpace complexity: $$O(n)$$ {recursion stack}\n","permalink":"http://localhost:45763/personal_website/posts/leetcode_430_flattening_multilevel_linked_list/","summary":"\u003cp\u003eThe idea is to keep 2 pointers. \u003ccode\u003etrail\u003c/code\u003e pointer and \u003ccode\u003ecur\u003c/code\u003e pointer. The\nlist is build in recursive function \u003ccode\u003ebuild(trail, cur)\u003c/code\u003e which returns\nlast node of the list we build.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebuild\u003c/code\u003e works as follows:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ewhen there is no \u003ccode\u003echild\u003c/code\u003e node: simply connect \u003ccode\u003etrail\u003c/code\u003e and \u003ccode\u003ecur\u003c/code\u003e and advance both\u003c/li\u003e\n\u003cli\u003ewhen there is a \u003ccode\u003echild\u003c/code\u003e node, then recursively call itself with \u003ccode\u003ebuild( trail = cur, cur = cur.child )\u003c/code\u003e. The call would connect \u003ccode\u003ecur\u003c/code\u003e node with the \u003ccode\u003elist in the next level\u003c/code\u003e. It would return the last node in next level. Then we assign \u003ccode\u003etrail = last node in next level\u003c/code\u003e and \u003ccode\u003ecur = cur.next in current level\u003c/code\u003e. This ensures that the next iteration would connect \u003ccode\u003elast node in next level\u003c/code\u003e to \u003ccode\u003enext node in current level\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003ewhen \u003ccode\u003ecur\u003c/code\u003e becomes \u003ccode\u003enull\u003c/code\u003e \u003ccode\u003etrail\u003c/code\u003e is the last node in current level. \u003ccode\u003ereturn trail\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"code\"\u003eCode\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003eflatten\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ehead\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kr\"\u003econst\u003c/span\u003e   \u003cspan class=\"nx\"\u003esave\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ehead\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003esaveNext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003elastNodeFromChildList\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003esaveNext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003elastNodeFromChildList\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"complexity\"\u003eComplexity\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTime complexity:  $$O(n)$$\u003c/p\u003e","title":"Leetcode 430: Flattening a multilevel linked list"},{"content":"Below is my solution for the leetcode 154: Find minimum in rotated sorted array problem\nIntuition Fact is, that you cannot solve this question in O(log n) time. The reason is because of duplicates.\nConsider a situation like:\n$$ [2,2,2,2,1,2,2] $$\nwhere mid is at 3 and the minium number here is clearly $$1$$. But our binary search algorithm will not be able to figure out in which direction it should go, since starting, ending and middle values are all same. In this case the best we can do is increment mid which makes the worst running time: O(n)\nHowever, it is possible to solve this problem in O(n/2) as explain below.\nApproach We will make use of the fact that a sorted array follows the (min) heap property i.e. in a sorted array, at all parent nodes are smaller than their children.\nAnd if this sorted array is rotated, then the place at which the first violation occurs is the subtree where the answer will be found.\nComplexity Time complexity: $$O(n/2)$$ Space complexity: $$O(1)$$ Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 var findMin = function(a) { /** Approach: You cannot solve this problem in O(log n) since it contains duplicate values. But you can actually solve this problem in O(n/2) by using the fact that a sorted array follows heap property. And if a sorted array is rotated then the heap property no longer holds. to find the minium element traverse the array, and find the first subtree where the heap property does not hold. the minium of the 2 values where the heap property does not satisfy is also minium in the array. Time: O(n/2) Space: O(1) */ let A = a.length; let i = 0; while ( i \u0026lt;= Math.floor(A/2)-1 ) { let root = i; let lc = 2*i + 1; let rc = 2*i + 2; let smallest = root; if ( lc \u0026lt; A \u0026amp;\u0026amp; a[lc] \u0026lt; a[smallest] ) smallest = lc; if ( rc \u0026lt; A \u0026amp;\u0026amp; a[rc] \u0026lt; a[smallest] ) smallest = rc; if ( smallest != root ) /* violation found. the value at smallest is minium */ return a[smallest]; i++; } /* no violation found. Either the array is sorted ar there it is all duplicates, in either case, return the first element. */ return a[0]; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_154_find_minimum_in_rotated_sorted_array/","summary":"\u003cp\u003eBelow is my solution for the \u003ca href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/\"\u003eleetcode 154: Find minimum in rotated\nsorted array problem\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"intuition\"\u003eIntuition\u003c/h1\u003e\n\u003c!-- Describe your first thoughts on how to solve this problem. --\u003e\n\u003cp\u003eFact is, that you \u003cstrong\u003ecannot\u003c/strong\u003e solve this question in \u003cstrong\u003eO(log n)\u003c/strong\u003e time. The reason is because of duplicates.\u003c/p\u003e\n\u003cp\u003eConsider a situation like:\u003c/p\u003e\n\u003cp\u003e$$\n[2,2,2,2,1,2,2]\n$$\u003c/p\u003e\n\u003cp\u003ewhere mid is at 3 and the minium number here is clearly $$1$$. But our binary search algorithm will not be able to figure out in which direction it should go, since starting, ending and middle values are all same. In this case the best we can do is increment mid which makes the worst running time: \u003cstrong\u003eO(n)\u003c/strong\u003e\u003c/p\u003e","title":"Leetcode 154: Find minimum in rotated sorted array"},{"content":"Here\u0026rsquo;s my solution to the Leetcode 315: Count of Smaller Numbers After Self problem using standard merge sort. I just change one line to count while merge procedure.\nSolution Let\u0026rsquo;s build the solution step by step.\nInput: nums = $$[5,2,6,1]$$\nFirst, turn the numbers into [number, index] tuple. So it looks like:\narray = $$ [ [ 5, 0 ], [ 2, 1 ], [ 6, 2 ], [ 1, 3 ] ] $$\nSecond, just write standard merge sort algorithm and sort the array in ascending order by first values.\nThe output is: $$ [ [ 1, 3 ], [ 2, 1 ], [ 5, 0 ], [ 6, 2 ] ] $$\nHere\u0026rsquo;s the trace of the algorithm:\nSimple merge sort implemented 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { tmp.push( a[j] ); j++; } else { tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); merge_sort( array, 0, array.length-1 ); }; So far so good.\nNow let\u0026rsquo;s get back to the question. The question is asking: For each index $$i$$, count all numbers at index $$j$$ such that $$i \u0026lt; j$$ and $$a[i] \u0026gt; a[j]$$. Or, simply put: for each number, find all numbers that appear after it and are smaller than it.\nNow, look at the visualization again, pay attention to the merge procedure (in magenta colour) and observe the following:\nat each merge procedure, we merge 2 consecutive partitions. all numbers in the left partition appear before numbers in right partition in the original array. The partitions are sorted in increasing order. Now, suppose we are merging 2 partitions where, the pointer of left partition is at $$x$$ and pointer of right partition is at $$y$$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [....a,b,c, x ,d,e,f....] [...h,i,j, y, k,l,m....] ^ ^ i j Suppose x \u0026gt; y It follows from observation 2 that: y is one of the numbers that appear to the right of x and is smaller than x ---(1) Also, since partitions are sorted (observation 3): d, e, f .... (i.e. all number that appear to the right of x) are greater than x. ----(2) From (1) and (2) we can conclude that: x, d, e, f, ... (i.e. all numbers to the right of x including x) appear before y. And y is smaller than all these numbers. Hence, required condition satisfied! Now, we just need a counter for each variable, and whenever the condition same as above occurs, we increment the counter for each x,d,e,\u0026hellip;\n1 2 3 4 5 6 7 [....a,b,c, x ,d,e,f....] [...h,i,j, y, k,l,m....] ^ ^ i j while merging: if x \u0026gt; y increment the counters of x, d, e, f, ... Single line changed in standard merge sort algorithm We can use the index at the second position to access the counter of that particular number.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 let counts; const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { /* ____(x \u0026gt; y) so increment counters of x,d,e,...____*/ for ( let p=i; p\u0026lt;=mid; p++ ) counts[ a[p][1] ]++; /*_______________INSERT THIS LINE_____________________*/ tmp.push( a[j] ); j++; } else { tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); counts = new Array(nums.length).fill(0); merge_sort( array, 0, array.length-1 ); return counts; }; That is the whole idea behind this question. Now the above implementation won\u0026rsquo;t work because at each iteration, we are updating whole left partition after i. Making it O(n^2) Optimize To avoid updating the whole partition, we keep a running counter cnt.\nFinal implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 let counts; const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; let cnt = 0; // keep running counter while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { cnt++; // increment counter tmp.push( a[j] ); j++; } else { counts[ a[i][1] ] += cnt; // no more numbers that are // smaller than i tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { counts[ a[i][1] ] += cnt; // if left partition is not over // update left over number counts tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); counts = nums; counts.fill(0); merge_sort( array, 0, array.length-1 ); return counts; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def countSmaller(nums): counts = [0] * len(nums) array = [(num, i) for i, num in enumerate(nums)] def merge_sort(start, end): if start == end: return mid = (start + end) // 2 merge_sort(start, mid) merge_sort(mid + 1, end) merge(start, mid, end) def merge(start, mid, end): temp = [] i, j = start, mid + 1 cnt = 0 while i \u0026lt;= mid and j \u0026lt;= end: if array[i][0] \u0026gt; array[j][0]: cnt += 1 temp.append(array[j]) j += 1 else: counts[array[i][1]] += cnt temp.append(array[i]) i += 1 while i \u0026lt;= mid: counts[array[i][1]] += cnt temp.append(array[i]) i += 1 while j \u0026lt;= end: temp.append(array[j]) j += 1 for i in range(len(temp)): array[start + i] = temp[i] merge_sort(0, len(nums) - 1) return counts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; countSmaller(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; counts(nums.size(), 0); vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; array; for (int i = 0; i \u0026lt; nums.size(); i++) { array.emplace_back(nums[i], i); } function\u0026lt;void(int, int)\u0026gt; merge_sort = [\u0026amp;](int start, int end) { if (start == end) return; int mid = start + (end - start) / 2; merge_sort(start, mid); merge_sort(mid + 1, end); merge(start, mid, end); }; function\u0026lt;void(int, int, int)\u0026gt; merge = [\u0026amp;](int start, int mid, int end) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; temp; int i = start, j = mid + 1; int cnt = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end) { if (array[i].first \u0026gt; array[j].first) { cnt++; temp.push_back(array[j]); j++; } else { counts[array[i].second] += cnt; temp.push_back(array[i]); i++; } } while (i \u0026lt;= mid) { counts[array[i].second] += cnt; temp.push_back(array[i]); i++; } while (j \u0026lt;= end) { temp.push_back(array[j]); j++; } for (int k = 0; k \u0026lt; temp.size(); k++) { array[start + k] = temp[k]; } }; merge_sort(0, nums.size() - 1); return counts; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import java.util.*; class Solution { private int[] counts; private int[][] array; public List\u0026lt;Integer\u0026gt; countSmaller(int[] nums) { counts = new int[nums.length]; array = new int[nums.length][2]; for (int i = 0; i \u0026lt; nums.length; i++) { array[i][0] = nums[i]; array[i][1] = i; } mergeSort(0, nums.length - 1); List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (int count : counts) { result.add(count); } return result; } private void mergeSort(int start, int end) { if (start == end) return; int mid = start + (end - start) / 2; mergeSort(start, mid); mergeSort(mid + 1, end); merge(start, mid, end); } private void merge(int start, int mid, int end) { List\u0026lt;int[]\u0026gt; temp = new ArrayList\u0026lt;\u0026gt;(); int i = start, j = mid + 1; int cnt = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end) { if (array[i][0] \u0026gt; array[j][0]) { cnt++; temp.add(array[j]); j++; } else { counts[array[i][1]] += cnt; temp.add(array[i]); i++; } } while (i \u0026lt;= mid) { counts[array[i][1]] += cnt; temp.add(array[i]); i++; } while (j \u0026lt;= end) { temp.add(array[j]); j++; } for (int k = 0; k \u0026lt; temp.size(); k++) { array[start + k] = temp.get(k); } } } Time: $$O(n\\ log\\ n)$$ Space: $$O(n)$$ ","permalink":"http://localhost:45763/personal_website/posts/leetcode_315_count_of_smaller_numbers_after_self/","summary":"\u003cp\u003eHere\u0026rsquo;s my solution to the \u003ca href=\"https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/\"\u003eLeetcode 315: Count of Smaller Numbers After\nSelf problem\u003c/a\u003e using standard merge sort. I just change one line to\ncount while merge procedure.\u003c/p\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\n\u003cp\u003eLet\u0026rsquo;s build the solution step by step.\u003c/p\u003e\n\u003cp\u003eInput: nums = $$[5,2,6,1]$$\u003c/p\u003e\n\u003cp\u003eFirst, turn the numbers into \u003cstrong\u003e[number, index]\u003c/strong\u003e tuple. So it looks like:\u003c/p\u003e\n\u003cp\u003earray = $$ [ [ 5, 0 ], [ 2, 1 ], [ 6, 2 ], [ 1, 3 ] ] $$\u003c/p\u003e","title":"Leetcode 315: Count of Smaller Numbers After Self"},{"content":"Here\u0026rsquo;s my explanation for the leetcode 306: Additive Number problem\nAdditive Number Problem Problem Recap An additive number is a string of digits where the sequence of numbers formed by splitting the string satisfies the condition that each number (after the first two) is the sum of the two preceding numbers.\nExamples: \u0026quot;112358\u0026quot; is additive because the sequence is 1, 1, 2, 3, 5, 8, and:\n1 + 1 = 2 1 + 2 = 3 2 + 3 = 5 3 + 5 = 8 \u0026quot;199100199\u0026quot; is additive because the sequence is 1, 99, 100, 199, and:\n1 + 99 = 100 99 + 100 = 199 Solution Approach The solution uses a backtracking approach to try all possible splits of the string into sequences of numbers and checks if any of these sequences form an additive sequence.\nDetailed Explanation Helper Function isValid This recursive function checks if the remaining part of the string s forms a valid additive sequence given the first two numbers a and b.\nBase Case: If the remaining string s is empty, it means we\u0026rsquo;ve successfully formed an additive sequence, so return true.\nRecursive Step:\nCompute the sum of a and b and convert it to a string sum. Check if the remaining string s starts with sum: If not, the sequence is invalid  return false. If yes, recursively check the next part of the string with the new pair (b, sum) and the remaining string after removing sum. Main Function isAdditiveNumber Initialization: Get the length of the input string num. Nested Loops: The outer loop (i) determines the end index of the first number a (from index 0 to i). The inner loop (j) determines the end index of the second number b (from index i to j). Leading Zero Check: Skip any splits where a or b have leading zeros unless they are exactly \u0026quot;0\u0026quot;. Example: \u0026quot;02\u0026quot; is invalid, but \u0026quot;0\u0026quot; is valid. Validation: For each valid pair (a, b), call isValid to check if the remaining part of the string forms a valid additive sequence starting with a and b. If isValid returns true, immediately return true from the main function. Final Check: If no valid sequence is found after all possible splits, return false. Example Walkthrough Let\u0026rsquo;s walk through the example num = \u0026quot;112358\u0026quot;:\nFirst Iteration (i = 1, j = 2): a = \u0026quot;1\u0026quot;, b = \u0026quot;1\u0026quot;. No leading zeros  proceed. isValid(1, 1, \u0026quot;2358\u0026quot;): Sum of 1 + 1 = 2. Check if \u0026quot;2358\u0026quot; starts with \u0026quot;2\u0026quot;  Yes. Recursively call isValid(1, 2, \u0026quot;358\u0026quot;): Sum of 1 + 2 = 3. Check if \u0026quot;358\u0026quot; starts with \u0026quot;3\u0026quot;  Yes. Recursively call isValid(2, 3, \u0026quot;58\u0026quot;): Sum of 2 + 3 = 5. Check if \u0026quot;58\u0026quot; starts with \u0026quot;5\u0026quot;  Yes. Recursively call isValid(3, 5, \u0026quot;8\u0026quot;): Sum of 3 + 5 = 8. Check if \u0026quot;8\u0026quot; starts with \u0026quot;8\u0026quot;  Yes. Recursively call isValid(5, 8, \u0026quot;\u0026quot;): Empty string  return true. Since isValid returned true, the main function returns true. Edge Cases Leading Zeros: Correctly skips invalid splits (e.g., \u0026quot;02\u0026quot; unless it\u0026rsquo;s \u0026quot;0\u0026quot;). Single Digit: If input length \u0026lt; 3, returns false. Large Numbers: Uses parseInt, but BigInt is better for very large numbers to avoid precision issues. Time Complexity Nested loops: O(n), where n is the string length. isValid function: O(n) per pair (a, b). Overall: O(n), feasible for reasonably sized strings. Space Complexity O(n) due to recursion stack in the worst case. Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var isAdditiveNumber = function(num) { const isValid = (a, b, s) =\u0026gt; { if (s.length === 0) return true; const sum = (a + b).toString(); return s.startsWith(sum) \u0026amp;\u0026amp; isValid(b, parseInt(sum), s.slice(sum.length)); }; const n = num.length; for (let i = 1; i \u0026lt; n; i++) { for (let j = i + 1; j \u0026lt; n; j++) { const a = num.slice(0, i); const b = num.slice(i, j); if ((a.startsWith(\u0026#39;0\u0026#39;) \u0026amp;\u0026amp; a.length \u0026gt; 1) || (b.startsWith(\u0026#39;0\u0026#39;) \u0026amp;\u0026amp; b.length \u0026gt; 1)) continue; if (isValid(parseInt(a), parseInt(b), num.slice(j))) return true; } } return false; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 var isAdditiveNumber = function(num) { let N = num.length; let check = ( a ) =\u0026gt; { /** check if numbers in an array form fibonacci seqence **/ let A = a.length; if ( A \u0026lt; 3 ) return false; for ( let i=2; i \u0026lt; A; i++ ) if ( Number(a[i]) != Number(a[i-1]) + Number(a[i-2]) || ( a[i].length \u0026gt; 1 \u0026amp;\u0026amp; a[i].startsWith(\u0026#39;0\u0026#39;) ) || ( a[i-1].length \u0026gt; 1 \u0026amp;\u0026amp; a[i-1].startsWith(\u0026#39;0\u0026#39;) ) || ( a[i-2].length \u0026gt; 1 \u0026amp;\u0026amp; a[i-2].startsWith(\u0026#39;0\u0026#39;) ) ) return false; return true; }; let bt_search = ( i, cur = [] ) =\u0026gt; { if ( i \u0026gt; N ) return false; if ( i === N \u0026amp;\u0026amp; check(cur) ) return true; // num[i] starts a new number, explore path cur.push( num[i] ); let new_start = bt_search( i+1, cur ); if ( new_start ) return true; // backtrack, num[i] continues the previous number cur.pop(); if ( i \u0026gt; 0 ) { cur[ cur.length-1 ] += num[i]; let add_prev = bt_search( i+1, cur ); if ( add_prev ) return true; } return false; }; return bt_search( 0 ); }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_306_additive_number/","summary":"\u003cp\u003eHere\u0026rsquo;s my explanation for the \u003ca href=\"https://leetcode.com/problems/additive-number/description/\"\u003eleetcode 306: Additive Number problem\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"additive-number-problem\"\u003eAdditive Number Problem\u003c/h2\u003e\n\u003ch3 id=\"problem-recap\"\u003eProblem Recap\u003c/h3\u003e\n\u003cp\u003eAn \u003cstrong\u003eadditive number\u003c/strong\u003e is a string of digits where the sequence of numbers formed by splitting the string satisfies the condition that each number (after the first two) is the sum of the two preceding numbers.\u003c/p\u003e\n\u003ch4 id=\"examples\"\u003eExamples:\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026quot;112358\u0026quot;\u003c/code\u003e is additive because the sequence is \u003ccode\u003e1, 1, 2, 3, 5, 8\u003c/code\u003e, and:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e1 + 1 = 2\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e1 + 2 = 3\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e2 + 3 = 5\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e3 + 5 = 8\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026quot;199100199\u0026quot;\u003c/code\u003e is additive because the sequence is \u003ccode\u003e1, 99, 100, 199\u003c/code\u003e, and:\u003c/p\u003e","title":"Leetcode 306: Additive number"},{"content":"Here are all possible solutions I could come up with for the longest increasing subsequence problem. leetcode 300\nApproach 1: Generate all possible increasing subsequences We will keep track of a subsequence in an array named cur_subsequence or cur_sub. For each element (a[i]) we have the following 2 options:\nAdd the element to the end of current subsequence.\nNote: The current element can only be included if either the current subsequence is empty or the last element of the current subsequence is smaller than the current element. This is important to maintain the increasing subsequence property.\nIgnore the current element and explore without a[i]\nTime complexity: $$ O(2^N) $$ Space complexity: $$ O(N) $$ // recursion stack + auxilary array 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 var lengthOfLIS = function(a) { let A = a.length; // maximum length of a subsequence seen so far let max_len = 1; let bt_search = ( i, cur_sub = [] ) =\u0026gt; { if ( i \u0026gt;= A ) { max_len = Math.max( max_len, cur_sub.length ); return; } // either select the ith element, or ignore it. // a[i] can be taken when either subsequencee is empty or // last inserted element is smaller if ( !cur_sub.length || cur_sub[ cur_sub.length-1 ] \u0026lt; a[i] ) { cur_sub.push( a[i] ); bt_search( i+1, cur_sub ); cur_sub.pop(); // backtrack } // explore without a[i] included bt_search( i+1, cur_sub ); }; bt_search(0); return max_len; } Approach 2 (Version 1) : Generating all possible subsequences, but change the structure of the recursion to allow memoization Currently, we are keeping track of the current subsequence in an array cur_sub which makes it difficult for us to implement memoization. Notice that we only need previously selected element (to compare if current element is larger) and current length (to find the subsequence length). Hence, we will only use 3 variables: index, previous element index, current length.\nTime complexity: $$ O( N^2 ) $$ Space complexity: $$O( N^3 )$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 var lengthOfLIS = function(a) { /** Write a recurrence relation. Either you take the element @i or your ignore it. In either case, your pick the maximum length. generating all possible increasing subsequences, but not storing the subsequence and using only 3 variables. for each call(index, prev_selected, cur_length) we try to find the maximum length we can form by either selecting or rejecting a[i] This configuration is easy to memoize. **/ let A = a.length; let memo = new Map(); let bt_search = ( i, prev, cur_len = 0 ) =\u0026gt; { // inputs of the function are memoized by turning // them into a String `key` let key = JSON.stringify( [i, prev, cur_len] ); if (memo.has(key)) return memo.get(key); if ( i \u0026gt;= A ) return cur_len; let take = -1, not_take = -1; // a[i] can be taken if prev=null / cur_len=0 // or prev \u0026lt; a[i] if ( cur_len == 0 || prev \u0026lt; a[i] ) take = bt_search( i+1, a[i], cur_len+1 ); // backtrack. do not take a[i] not_take = bt_search( i+1, prev, cur_len ); let res = Math.max( take, not_take ); memo.set(key, res); return memo.get(key); }; return bt_search(0); } Approach 2 (Version 2): Yet another recursive solution, but with better memoization This solution memoizes using only: index of current element (i), index of previously selected element (prev_i).\nThe memoization is done in a matrix of size $$N$$X$$(N+1)$$.\nTime complexity: $$ O( N^2 ) $$ Space complexity: $$O( N^2 )$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 var lengthOfLIS = function(a) { /** Approach 2 (version 2): Instead of storing 3 variables, just store 2 variables. This will enable memoization table to be an NxN matrix. **/ let A = a.length; let memo = new Array( A ).fill(null).map( () =\u0026gt; new Array( A+1 ).fill( null ) ); let bt_search = ( i, prev_i = -1 ) =\u0026gt; { // y is remapped since prev_i is in range [-1,n-1] // but our array ranges is in range [0, n] let x = i, y = prev_i + 1; if ( i \u0026gt;= A ) return 0; if ( memo[x][y] !== null ) return memo[x][y]; let take = -1, not_take = -1; // a[i] can be taken if prev_i = -1 / cur_len=0 or // a[prev_i] \u0026lt; a[i] if ( prev_i == -1 || a[prev_i] \u0026lt; a[i] ) take = 1 + bt_search( i+1, i ); // backtrack. do not take a[i]. The length remains same not_take = bt_search( i+1, prev_i ); let res = Math.max( take, not_take ); memo[x][y] = res; return memo[x][y]; }; return bt_search(0); } Approach 3: Dynamic programming Declare a lis(longest increasing subsequence) array, where lis[i] denotes the length of longest increasing subsequence starting at i and ending at the end of the array. Fill this table from second last element towards first element.\nTo find lis[i] for an element a[i] use the following algorithm:\nFor each i \u0026lt;- n-2 - 0 // find if index i can form an increasing subsequence // with any element on the right of it max_len = 1 For each j \u0026lt;- i+1 - n if ( a[i] \u0026lt; a[j] ) // a[j] is a potential connection point max_len = MAX( max_len, 1 + lis[j] ) lis[i] = max_len The basic intuition behind it is, that we explore all elements to the right of a[i] which can connect with a[i] to form an increasing subsequence. The length of such a subsequence is given by:\n1 (length of a[i]) + length of longest subsequence from a[j] up until the end of the array\nwhich is same as: 1 + lcs[j]\nTime: $$O(n^2)$$ Space: $$O(n)$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 let MAX = Math.max; var lengthOfLIS = function(a) { /** Appraoch 3: Build the dp table manually using loops **/ let A = a.length; let lis = new Array( A ).fill(1); // global maximum, subsequence length from a[i] until end let gmax = 1; for ( let i = A-2; i \u0026gt;= 0; i-- ) { let max_len = 1; for ( let j = i+1; j \u0026lt; A; j++ ) { if ( a[i] \u0026lt; a[j] ) max_len = MAX( max_len, 1+lis[j] ); } lis[i] = max_len; gmax = MAX( max_len, gmax ); } return gmax; } Approach 4: Build an auxilary array, such that the minium elements are always at the end of it Here, we are basically trying to kick out large elements and inserting small elements whereever possible, so that new incoming elements feel welcome attaching themselves to the existing subsequence.\nBuild a auxilary array using the following algorithm:\nsubsequence = [] For each i \u0026lt;- 0 to A-1 if subsequence.last_element \u0026lt; a[i] subsequence.push( a[i] ) else { replace the largest element smaller than or equal to a[i] in subsequence using binary search. } the length of the subsequence is the length of the largest increasing subsequence. Time: $$O(n\\ log n)$$ // n for iteration, and for each iteration binary search O(log n) Space: $$O(n)$$ // auxilary array Note that the array that we actually build here does not represent a valid increasing subsequence. Nor is it the longest increasing subsequence, we just insert the elements using a particularly methodology which ensures its validity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 let MAX = Math.max; let FLOOR = Math.floor; var b_search = ( a, target ) =\u0026gt; { // return the index pf the number \u0026gt;= target let i = 0, j = a.length-1; while ( i \u0026lt;= j ) { let mid = i + FLOOR( (j-i)/2 ); if ( a[mid] == target ) return mid; else if ( a[mid] \u0026lt; target ) i = mid+1; else j = mid-1; } return i; }; var lengthOfLIS = function(a) { /** Approach 4: The idea is to keep the minium elements, such that validity of lis(longest increasing subsequence) for new incoming elements can be calculated quickly **/ let A = a.length; let sub = [ a[0] ]; for ( let i=1; i \u0026lt; A; i++ ) { let lst = sub.length-1; if ( sub[ lst ] \u0026lt; a[i] ) sub.push( a[i] ); else { // find a \u0026#34;write index\u0026#34; where we replace a[i] let wi = b_search( sub, a[i] ); sub[wi] = a[i]; } } return sub.length; } Approach 5: In place algorithm for approach 4 Time: $$O(n\\ logn)$$ Space: $$O(1)$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 let MAX = Math.max; let FLOOR = Math.floor; /* this version is for searching within the same array starting and ending position are requirede */ var b_search = ( a, start, end, target ) =\u0026gt; { // return the index pf the number \u0026gt;= target let i = start, j = end; while ( i \u0026lt;= j ) { let mid = i + FLOOR( (j-i)/2 ); if ( a[mid] == target ) return mid; else if ( a[mid] \u0026lt; target ) i = mid+1; else j = mid-1; } return i; }; var lengthOfLIS = function(a) { /*** Approach 5: Same as the above approach, but in place Hence saving auxilary space. The idea is to keep a variable to mark the end of the subsequence in a itself. **/ let A = a.length; let S = 1; // variable to mark the end of the subsequence for ( let i=1; i \u0026lt; A; i++ ) { if ( a[S-1] \u0026lt; a[i] ) { a[S] = a[i]; S++; } else { // find a \u0026#34;write index\u0026#34; where we replace a[i] let wi = b_search( a, 0, S-1, a[i] ); a[wi] = a[i]; } } return S; } ","permalink":"http://localhost:45763/personal_website/posts/all_possible_solutions_to_longest_increasing_subsequence_problem_leetcode_300/","summary":"\u003cp\u003eHere are all possible solutions I could come up with for the longest\nincreasing subsequence problem. \u003ca href=\"https://leetcode.com/problems/factorial-trailing-zeroes/description/\"\u003eleetcode\n300\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"approach-1-generate-all-possible-increasing-subsequences\"\u003eApproach 1: Generate all possible increasing subsequences\u003c/h1\u003e\n\u003cp\u003eWe will keep track of a subsequence in an array named \u003ccode\u003ecur_subsequence\u003c/code\u003e\nor \u003ccode\u003ecur_sub\u003c/code\u003e. For each element (\u003ccode\u003ea[i]\u003c/code\u003e)  we have the following 2\noptions:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eAdd the element to the end of current subsequence.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eNote: The current element can only be included if\neither the current subsequence is empty or the last\nelement of the current subsequence is smaller than\nthe current element. This is important to maintain\nthe increasing subsequence property.\u003c/em\u003e\u003c/p\u003e","title":"All possible solutions to longest increasing subsequence problem: leetcode 300"},{"content":"Problem link: leetcode 70: climbing stairs\nIntuition You need to climb n stairs, taking 1 or 2 stairs at a time.\nIf n = 2, you can climb like:\n$$1+1 = 2\\times (1) + 0 \\times(2)$$ $$2 = 0 \\times (1) + 1\\times(2) $$ if n = 3, you can climb like:\n$$1+1+1 = 3\\times(1) + 0\\times(2)$$ $$1+2 = 1\\times(1) + 1\\times(2)$$ $$2+1 = 1\\times(1) + 1\\times(2) $$ Basically you first need to decide how many steps of size 1 will you take and how many of size 2 do you need:\nHence, your first task is to solve the equation:\n$$ x \\times 1 + y \\times 2 = n $$\nTo decide the number of 1s and 2s. After you decide upon x and y then you will have calculate $$ \\frac{(x + y)!}{x! , y!} $$\nWhich is nothing but ways of chosing how exactly you will proceed. This is because we are trying to adjust x identical objects and y identical objects in x+y positions. Think of the number of ways you can arrange x men and y women in x + y positions.\nAs an example $$n=3, x=1 $$ and $$y=1$$\nThen you will have $$\\frac{(1 + 1)!}{1! , 1!} =2$$. see above, they are: $$ 1+2 \\ 2+1 $$\nApproach $$ y \\in [0, n/2] $$\nFor each , calculate the corresponding values of $$x$$ using the equation: $$ x \\times 1 + y \\times 2 = n \\ x = n - (2 \\times y ) $$\nthen calculate $$ \\frac{(x + y)!}{x! , y!} $$\nand add this to your counter variable.\nreturn counter.\nComplexity Time complexity: Time: O($$n^2$$)\nSpace: O(1)\nBut it can be reduced, if you can store calculated factorials. Hence, making the time complexity of calculating $$ \\frac{(x + y)!}{x! , y!} $$ -\u0026gt; O(1) and Space complexity O(n)\nTime complexity: O(n) Space complexity: O(n)\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 var permute = (x,y) =\u0026gt; { /* compute (x+y)! / x! y! without computing factorials */ /* which is basically computing x+y x+y-1 x+y-2 .. y+1 / x! */ var denom = 1; for (var i=1; i \u0026lt;= x; i++) denom *= i; var numi = 1; for (var i = y+1; i \u0026lt;= x+y; i++) numi *= i; return numi/denom; }; var climbStairs = function(n) { /* The number of ways in which we can get n by adding only 1 and 2 Let, 1x + 2y = n ---(1) then we need to find the number of integer solutions to this equation. that is S = {x,y | x,y in integers} we need to return |S| i.e. the number of elements in this solution set. from (1) it implies x = n - 2y ---(2) y in range [0,n/2] i.e. consequently x in range [0,n] hence, iterate over y from 0 to n/2 such that y is integer. we find the corrosponding solution using equation 2 */ let n_solutions = 0 ; for (var y=0; y \u0026lt;= Math.floor(n/2); y++ ) { var x = n - (2 * y); n_solutions += permute(x,y); } return (n_solutions); }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_70/","summary":"\u003cp\u003eProblem link: \u003ca href=\"https://leetcode.com/problems/climbing-stairs/description/\"\u003eleetcode 70: climbing stairs\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"intuition\"\u003eIntuition\u003c/h1\u003e\n\u003c!-- Describe your first thoughts on how to solve this problem. --\u003e\n\u003cp\u003eYou need to climb \u003ccode\u003en\u003c/code\u003e stairs, taking 1 or 2 stairs at a time.\u003c/p\u003e\n\u003cp\u003eIf n = 2, you can climb like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$$1+1 = 2\\times (1) + 0 \\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$2 = 0 \\times (1) + 1\\times(2) $$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eif n = 3, you can climb like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$$1+1+1 =  3\\times(1) + 0\\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$1+2   =  1\\times(1) + 1\\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$2+1   =  1\\times(1) + 1\\times(2) $$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBasically you first need to decide how many steps of size 1 will you take and how many of size 2 do you need:\u003c/p\u003e","title":"Leetcode 70: Climbing Stairs"},{"content":"Below is my C solution for the Leetcode problem candy.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 static inline void previous_kids_started_crying(int* kid, int continous_decrease_start, int continous_decrease_end, int* candy) { /* * To satisfy the condition that each child with higher rating than * it\u0026#39;s neighbors must get more candies. We give all children in range * [continous_decrease_start, continous_decrease_end] an extra candy * if the he has candies lower or equal to the kid after it. * * Note that we do not bother the kid before it, since it is known * that the kid before it has more rating than this kid */ if (continous_decrease_start == -1) { exit(1); } for (int i = continous_decrease_end; i \u0026gt;= continous_decrease_start; i--) { if (kid[i] \u0026lt;= kid[i+1]) { int before = kid[i]; kid[i]++; int after = kid[i]; *candy += after - before;; } else { /* chain is broken. We found a satisfied non protesting kid the kids before it must also be non-protesting */ return; } } } int candy(int* kid, int n) { /* * Few things to take care of: * * 1. At a time take a look at 2 children. i.e. iterate the children * in window of 2. * * 2. Each time a candy is given, check if previous child has more * rating, since he will start crying. He/she will protest that the * kid in front of him has less rating than him/her and still got * more/equal candies than him/her. It might even trigger a chain * where the kid previous to the previous kid might also see this * changed state, and if he had a rating more then the kid after him. * then he will also start asking more candies. And the kid behind * that and so on. * * The algorithm runs in linear time, however, if the children are * arranged in decreasing order of rating, then at each iteration all * previous children will start crying. Hence, everybofy needs to be * given more candies. In that case it becomes quadratic * * Space required is constant. * * Best case: * Time: O(n) * Space: O(1) * * Worst Case: * Time: O(n^2) * Space: O(1) */ int candies = 0; int continous_decrease_from = -1; /* First child gets a candy, but save his rating first */ int previous_child_rating = kid[0]; kid[0] = 1; candies++; for (int i = 1; i \u0026lt; n; i++) { if (kid[i] \u0026gt; previous_child_rating) { /* Since this child has more rating than the previous child, this child gets 1 more candy than previous child */ previous_child_rating = kid[i]; kid[i] = kid[i-1]+1; candies += kid[i]; continous_decrease_from = -1; } else if (kid[i] == previous_child_rating){ /* Since this child has equal rating than the previous child, give him 1 candy */ previous_child_rating = kid[i]; kid[i] = 1; candies++; continous_decrease_from = -1; } else { /* Previous child has more rating. Give this child one candy, and after giving : if the previous child had less candy, then we must initiate a chain reaction to do justice to all previous kids to previous children the problem here is that if this child has less rating then his predecessor then he will also start crying. And, the predecesor of this child also has more score then he will also start crying. Hence, we must give candies to them as well to maintain rule. Hence, check if the rule is disturbed, */ if (continous_decrease_from == -1) { /* A period of continous decrease started */ /* Hence, give this child 1 candy and if the previous child will also get 1 candy if he gets */ continous_decrease_from = i-1; previous_child_rating = kid[i]; kid[i] = 1; if (kid[i-1] \u0026gt; kid[i]) { candies ++; } else { kid[i-1] = kid[i] + 1; candies += 2; } } else { /* Give this child a candy, but mind the children behind this child */ previous_child_rating = kid[i]; kid[i] = 1; candies++; previous_kids_started_crying(kid, continous_decrease_from, i-1, \u0026amp;candies); } } } return candies; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_135/","summary":"\u003cp\u003eBelow is my C solution for the Leetcode problem \u003ca href=\"https://leetcode.com/problems/climbing-stairs/description/\"\u003ecandy\u003c/a\u003e.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e  1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 35\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 36\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 37\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 38\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 39\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 40\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 41\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 42\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 43\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 44\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 45\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 46\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 47\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 48\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 49\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 50\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 51\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 52\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 53\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 54\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 55\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 56\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 57\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 58\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 59\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 60\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 61\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 62\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 63\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 64\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 65\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 66\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 67\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 68\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 69\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 70\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 71\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 72\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 73\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 74\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 75\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 76\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 77\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 78\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 79\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 80\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 81\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 82\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 83\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 84\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 85\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 86\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 87\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 88\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 89\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 90\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 91\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 92\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 93\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 94\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 95\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 96\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 97\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 98\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 99\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e100\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e101\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e102\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e103\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e104\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e105\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e106\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e107\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e108\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e109\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e110\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e111\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e112\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e113\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e114\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e115\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e116\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e117\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e118\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e119\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e120\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e121\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e122\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e123\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e124\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e125\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e126\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e127\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e128\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e129\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e130\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e131\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e132\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e133\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e134\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kr\"\u003einline\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eprevious_kids_started_crying\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_end\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ecandy\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * To satisfy the condition that each child with higher rating than\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * it\u0026#39;s neighbors must get more candies. We give all children in range\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * [continous_decrease_start, continous_decrease_end] an extra candy\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * if the he has candies lower or equal to the kid after it.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Note that we do not bother the kid before it, since it is known\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * that the kid before it has more rating than this kid\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e        */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nf\"\u003eexit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_end\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ebefore\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eafter\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ecandy\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003eafter\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ebefore\u003c/span\u003e\u003cspan class=\"p\"\u003e;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* chain is broken. We found a satisfied non protesting kid\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                          the kids before it must also be non-protesting */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ecandy\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Few things to take care of:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * 1. At a time take a look at 2 children. i.e. iterate the children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * in window of 2.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * 2. Each time a candy is given, check if previous child has more\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * rating, since he will start crying. He/she will protest that the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * kid in front of him has less rating than him/her and still got\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * more/equal candies than him/her. It might even trigger a chain\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * where the kid previous to the previous kid might also see this\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * changed state, and if he had a rating more then the kid after him.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * then he will also start asking more candies. And the kid behind\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * that and so on.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * The algorithm runs in linear time, however, if the children are\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * arranged in decreasing order of rating, then at each iteration all\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * previous children will start crying. Hence, everybofy needs to be\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * given more candies. In that case it becomes quadratic\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space required is constant.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Best case:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Time: O(n)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space: O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Worst Case:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Time: O(n^2)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space: O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e         */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/* First child gets a candy, but save his rating first */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Since this child has more rating than the previous\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         child, this child gets 1 more candy than previous\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         child */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Since this child has equal rating than the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         previous child, give him 1 candy */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Previous child has more rating. Give this child one\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candy, and after giving : if the previous child had less\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candy, then we must initiate a chain reaction to do\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        justice to all previous kids to previous children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        the problem here is that if this child has less rating\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        then his predecessor then he will also start crying.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        And, the predecesor of this child also has more score\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        then he will also start crying. Hence, we must give\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candies to them as well to maintain rule. Hence, check\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        if the rule is disturbed,\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* A period of continous decrease started */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* Hence, give this child 1 candy and if the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                                   previous child will also get 1 candy if he gets  */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* Give this child a candy, but mind the children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                                  behind this child */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"nf\"\u003eprevious_kids_started_crying\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Leetcode 135: Candy"},{"content":"Introduction Linux is the kernel that powers the modern computing world. Its everywherefrom all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isnt about why Linux dominates the tech world; its about how I started contributing to the Linux Kerneland how you can too.\nHow Kernel Development Works Kernel development thrives on the Linux Kernel Mailing List (LKML), the nerve center of Linuxs open-source ecosystem. The beauty of open source? Anyone can contribute. Your task is to send patches (essentially the output of git diff refurbushed into an email).\nIf your patch solves a real problem or adds value, experienced developers will jump in with questions about your intent and rationale. Heres a pro tip: dont explain the how of your code; let the code speak for itself. Instead, focus on explaining why your change is needed.\nThe LKML community is incredibly supportive \u0026ndash; theyll critique your code, point out mistakes, and suggest improvements. Sure, it might feel overwhelming initially, but resources like the LFD103 course can guide you through the basics: generating patches, submitting them to LKML, compiling, and booting the kernel.\nFor me, just setting up my mail client and understanding LKML discussions took about a month. But once you clear these initial hurdles, things get easier. If youre struggling, feel free to check out my notesthey might save you some time.\nMy Background For years, kernel developers seemed like magicians to medoing impossibly cool things with computers. My fascination started after I stumbled upon a video of someone working on the kernel. It was mesmerizing!\nIn my second semester, I discovered the book The C Programming Language, and it sparked my love for C. The control C offers is unmatched, but it comes with its fair share of challengesbugs galore!\nSurprisingly, I wasnt a Linux user until recently. When I finally switched from Windows to Linux, everything just clicked. Concepts that once felt abstract suddenly made sense. On Windows, troubleshooting often felt like solving a mystery even Microsoft couldnt decode. On Linux, it felt like someone handed me the keys to the entire system.\nWhile working on kernel contributions, I read Linux Device Drivers, a book authored by seasoned kernel developers. It gave me a deeper understanding of the kernels inner workings. If youre serious about kernel development or writing drivers, this book is a must-read.\nWhat to Contribute The hardest part of contributing to the Linux Kernel is figuring out what to work on. The kernel is vasttheres everything from GPU drivers to network stack development.\nSince the kernels primary job is managing hardware, driver development is a hotspot of activity. New devices constantly hit the market, and they need drivers. If you have an electronics background and access to hardware, driver development is an excellent starting point.\nIf hardware isnt your thing (like in my case), here are some alternatives:\nkselftest: A testing framework for kernel functionality. Core subsystems: The backbone of the kernela great way to learn the essentials. syzbot reports: A kernel fuzzer that uncovers bugs by feeding the kernel random data. These reports are a goldmine for learning about common mistakes. Another beginner-friendly option is upgrading deprecated APIs. These updates are highly appreciated because they improve the kernels maintainability and security. Its not always a simple find-and-replaceyoull need to understand the codebut its a rewarding way to start.\nAnd dont underestimate fixing spelling and grammar errors in the documentation or comments. While it might sound trivial, its a fantastic way to learn the workflow: creating patches, submitting them, and receiving feedback. Tools like codespell can help you automate finding these errors.\nMy first-ever patch was a simple typo fix, but I made the classic rookie mistake of introducing two changes while documenting only one. Lesson learned!\nOnce you start contributing, youll notice issues everywhere. Even just following discussions on LKML can teach you a ton about how seasoned developers think and work.\nConclusion Kernel development might seem intimidating at first, but trust me, its worth the effort. Youll not only become a stronger developer but also gain a deep understanding of how computers work. Youll build expertise in both kernel and userspace development, and your Git skills will level up immenselya must-have for any programmer.\nThe learning opportunities in kernel development are unparalleled, often rivaling (or even exceeding) those at top tech companies. So if youre considering it, dont hesitatedive in! You might be surprised by how much youll grow.\nGood Luck!\nReferences ","permalink":"http://localhost:45763/personal_website/posts/highlights_from_linux_kernel_mentorship_program_2024/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux is the kernel that powers the modern computing world. Its everywherefrom all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isnt about \u003cem\u003ewhy\u003c/em\u003e Linux dominates the tech world; its about how I started contributing to the Linux Kerneland how you can too.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"how-kernel-development-works\"\u003eHow Kernel Development Works\u003c/h2\u003e\n\u003cp\u003eKernel development thrives on the Linux Kernel Mailing List (LKML), the\nnerve center of Linuxs open-source ecosystem. The beauty of open\nsource? Anyone can contribute. Your task is to send patches (essentially\nthe output of \u003ccode\u003egit diff\u003c/code\u003e refurbushed into an email).\u003c/p\u003e","title":"Highlights from Linux Kernel Mentorship Program 2024 by Abdul Rahim"},{"content":"Introduction Computer memory is usually implemented as a file system. While tampering with data is easy to detect, unauthorized access to memory is a more complex task falling within the domain of Intrusion Detection Systems (IDS). Most intrusion detection systems focus on analyzing network traffic or using machine learning techniques to identify suspicious patterns, we explore if we can employ merkel trees for this task.\nIf unauthorized memory access cannot be detected, users would never know that the system was compromised. Detecting tampered files is straightforward: you can hash the contents of a file, and if the hash changes you might conclude that the file changed. However, detecting memory access is more complicated. Although Linux keeps track of the last access timestamp, available via the stat command1, it only tracks file accesses that use the read() syscall2.\nMerkel Trees Merkle trees are a data structure in which hashes are stored rather than data. Leaf nodes store hashes of particular data blocks, while other nodes store hashes of their children. Merkle trees are widely used in blockchains for their ability to detect data tampering. They provide a robust mechanism to detect tampering in multiple distinct data items. If any data item in a leaf node changes, the whole tree becomes invalidated because it changes the hashes of all nodes up the tree.\nFig. 1: A Merkle tree is a data structure in which each node contains a hash. All non-leaf nodes contain hashes of their children, and all leaf nodes contain hashes of the underlying data.\nMerkel tree as directory tree Now, what we want to do is to augment the directory tree as a merkel tree. To be exact the inode structure (See inode doc for more details).\nDoing this would make us have hashes for children in directory tree. And the benefit of that is whenever the child inodes change, the current inode would change. And there\u0026rsquo;s 2 fields that each node would contain, the last seen hash (expected hash) of it\u0026rsquo;s child and the current hash of the same child. And when the current hash changes to a different value from expected hash, then we can imply that the child inode changed.\nBut one question is that if memory can be accessed bare metal, then the protections done in software doesn\u0026rsquo;t really make any sense. One possible solution to this problem is employing encryption.\nThe encryption should be performed in hardware, and the memory access system calls should define protocols for decrypting the underlying memory. The same system call would update necessary variables of the file in question, such as access time. The memory access system call needs to be implemented so that when one accesses memory, the data is decrypted and other functions are performed.\nBelow is a detailed description.\nArchitecture File system in most operating systems follow a hierarchical structure. We augment this with a Merkle tree, where a node is attached to each file in the file system. These nodes form a Merkle tree, where each node contains the hash of its children (in the case of non-leaf nodes) or the hash of the file data (in the case of files). Additionally, a pollution flag is attached to each node to detect illegal access.\nEach node will also has an expected hash, which is the hash of the node when the subtree below that node was last valid.\nWorking The pollution flag is set if expected_hash != hash, which occurs only on illegal access. I will explain this in a moment.\nWhen a user or process requests memory, it will go through the memory access system call, requiring authentication. Once the authentication is successful, the underlying data is decrypted and returned, the access time is updated, and all the hashes up to the root are updated along with the expected hash (note that the expected hash changes on authorized access). The tree remains valid.\nIf the authentication fails, the memory is not returned, but the access time changes. Consequently, when the tree is re-evaluated, the hash of this node changes since it incorporates the access time, but the expected hash remains the same, setting the pollution flag for this node.\nSince the parent of this node uses its hash, the parent\u0026rsquo;s hash also changes. However, its expected hash remains the same, leading to its invalidation. This process continues up the tree, invalidating the whole tree.\nThe benefit of this approach is that all other nodes remain valid. If one tries to determine which file was accessed and the timestamp, it is easy to identify the exact file by following the invalid nodes from top to bottom.\nRefrences stat man page\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nread syscall\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:45763/personal_website/posts/merkel_trees_and_computer_memory/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003c!-- mine\nComputer memory is usually implemented as a file system. While tampering\nof data is easy to detect, unauthorised access to memory is a more\ncomplex task. A problem that lies in the domain of Intrusion Detection\nSystems. While, most intrusion detection focus on analyzing network\ntraffic, or machine learning techniques to identify suspicious patterns.\nWe propose a method that works within the system, providing robust\naccess detection.\n--\u003e\n\u003cp\u003eComputer memory is usually implemented as a file system. While tampering\nwith data is easy to detect, unauthorized access to memory is a more\ncomplex task falling within the domain of Intrusion Detection Systems\n(IDS). Most intrusion detection systems focus on analyzing network traffic or\nusing machine learning techniques to identify suspicious patterns, we\nexplore if we can employ merkel trees for this task.\u003c/p\u003e","title":"Merkel Trees and computer memory"},{"content":"Introduction When you install vim, a usual requirement as with all text editors is the ability to copy to/from system clipboard so you can lets say, copy something into your vim session from firefox or vice versa, however copy pasting in terminal editors is not as straight forward as with GUI editors. In vim if you want to copy something into an auxilary space (anticipating it would be used later, so you can paste from this auxilary space) is achieved by registers.\nThe register that represents system clipboard is + register. Anything that you copy into this register is available in system clipboard.\nHow to use registers to copy/paste To copy a text into a register, select it in visual mode and press \u0026quot;\u0026lt;register_name\u0026gt;y to yank the contents into the given register. And to paste the contents of a particular register at current position, use \u0026quot;\u0026lt;register_name\u0026gt;p.\nTo use system clipboard, you just have to substitute \u0026ldquo;+\u0026rdquo; for register name in the above commands.\nclipboard support But the + register wont work unless you have clipboard support with your vim installation. By default there is no clipboard support in vim.\nTo check if your vim installation has clipboard support use:\n1 2 3 $ vim --version | grep clipboard +clipboard +keymap +printer +vertsplit +ex_extra +mouse_netterm +syntax +xterm_clipboard or inside of vim, you can run the command:\n1 :echo has(\u0026#39;clipboard\u0026#39;) If the output is 0, your installation doesnt have clipboard support.\nCompiling vim Now there are 2 solutions to this problem:\nEither install gvim: Or compile vim from sources with clipboard support Let\u0026rsquo;s see how each of them can be done.\nInstall gvim To install gvim run:\nOn Debian:\n1 sudo apt install vim-gtk On Fedora\n1 sudo dnf install gvim To compile vim with clipboard support Below are the simple steps:\nStep 1: Grab the sources Clone the repository:\n1 2 git clone https://github.com/vim/vim.git vim cd vim Step 2: Install dependencies Install the required libraries and tools to build vim, for example gcc, x11 etc. Note that you only need them to compile vim and you are free to delete them once you are done.\nOn Debian:\n1 sudo apt install build-essential libx11-dev libncurses5-dev On Fedora:\n1 2 3 4 sudo dnf groupinstall \u0026#34;Development Tools\u0026#34; sudo yum install gcc sudo yum groupinstall \u0026#34;X Software Development\u0026#34; sudo dnf install libX11-devel ncurses-devel Also, you need to remove the existing installation(if any).\nOn Debian\n1 sudo apt remove vim On Fedora\n1 sudo dnf remove vim gvim Step 3: Configure and Compile Configure vim with features of your choice\n1 2 3 4 5 6 7 ./configure \\\\ --enable-cscope \\\\ --enable-gui=auto \\\\ --enable-gtk2-check \\\\ --enable-gnome-check \\\\ --with-features=huge \\\\ --with-x Then compile and install with:\n1 2 make sudo make install Conclusion In this article we learned how can we compile vim with clipboard support, you can also tweak configuration according to your requirements. There are many configuration options available.\n","permalink":"http://localhost:45763/personal_website/posts/how_to_compile_vim_with_clipboard_support/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eWhen you install vim, a usual requirement as with all text editors is\nthe ability to copy to/from system clipboard so you can lets say, copy\nsomething into your vim session from firefox or vice versa, however copy\npasting in terminal editors is not as straight forward as with GUI\neditors. In vim if you want to copy something into an auxilary space\n(anticipating it would be used later, so you can paste from this\nauxilary space) is achieved by \u003cstrong\u003eregisters\u003c/strong\u003e.\u003c/p\u003e","title":"How to compile vim with clipboard support"},{"content":" Introduction I had an unused phone lying around for some time, and I began contemplating how I could repurpose it. This led me to reflect on the impressive performance of modern smartphones and consider whether they could be utilized as servers.\nSmartphones are equipped with ARM-based processors and run on Android, which is itself built on the Linux kernel. ARM processors are renowned for their energy efficiency1 and have recently found applications in the server space2.\nAs someone who enjoys exploring the full potential of devices, I embarked on a journey to discover how I could leverage the full potential of smartphones.\nSetup Although, you would like to run your programs on phones, but programming on phones typing on screen is a horrifying idea. Fortunately, you dont have to type on your phone, what you can do is you can access its terminal, using protocols like ssh/telnet etc.\nSo, firstly you would need a terminal to control a machine remotely. Unfortunately, there are not, alot of choices available in phone space when it comes to terminal emulators. Termux is one of the few available options.\nAfter you manage to open a terminal remotely, then from there its pretty frictionless. You can install the software of your choice and write, compile and run your programs. You might also find it helpful to root your phone for root privilages, which will help you run all commands. But please beware that rooting can null your warrenty, check with local expert. If termux does\u0026rsquo;nt work for you then there are also other options like kali net hunter.\nSo, in total, we need to install termux, then we would setup ssh.\nTermux Termux is an open source terminal emulator for android. In essence, it provides you with a linux environment, within android, The only difference between actual linux environment and termex is that it is not FHS(File System Hierarcy) compliant, i.e. it does not strictly follow linux file system conventions. The consequences of that are that #! /usr/bin/sh may not work, so you have to watch out the paths. Other than that, it supports almost all commands on linux.\nMoreover, It is an app that does\u0026rsquo;nt interfere with your system so you can run your android as normal, moreover it runs without root privilages. It comes with a large repository of software found at packages.termux.dev.\nBelow are the steps to setup ssh in termux Step 1: Download texmux on playstore, f-droid or from github releases\nStep 2: Update using pkg:\n1 2 pkg update # update the repositories pkg upgrade # upgrade all to latest versions Run this commands\nStep 3: Install ssh 1 pkg install ssh install ssh\nStep 4: Set a password Setup a password that you will use to login\n1 passwd set password and note username\nStep 5: Note your username You will require username and ip address when logging in using ssh, hence note them. Run the command whoami the know your username. This will generally start with \u0026ldquo;a0_\u0026rdquo;\n1 whoami Step 6: Note your IP address You can check your IP address in:\n1 2 3 settings \u0026gt; Wi-Fi \u0026gt; click on the (i) button, on the wifi you are connected to and Look for IPv4 address Step 7: Run ssh doemon in termux On your phone, run the ssh daemon using\n1 sshd Step 8: Login form your computer On your computer, use the following command to login into your phone and access its terminal\n1 ssh \u0026lt;user_name\u0026gt;@\u0026lt;IP_address\u0026gt; -p 8022 The username and IP address we already determined in step 5 and 6 resp. Note that it will promt you for password\nAftermath You can use scp command to transfer files between your computer and phone. In case you want to do development, there are a number of programming packages available in termux, you can find rust, nodejs, python, C/C++ and tools for many other programming languages.\nConclusion So, now you have successfully installed ssh in your android phone. You might find it useful to install vim, git, gcc etc. There is a large repository of packages in termux, which covers pretty much everything your would need.\nFurther Reads Simili, Emanuele, et al. \u0026ldquo;Power Efficiency in HEP (x86 vs. arm).\u0026rdquo; Power (W) 350.400 (2023): 450\u0026#160;\u0026#x21a9;\u0026#xfe0e;\narm_server\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:45763/personal_website/posts/how_to_turn_your_old_smartphone_into_a_home_server/","summary":"\u003c!--\n---\ndate: '2025-07-15T22:33:11+05:30'\ndate: ''\ntitle: 'How_to_turn_your_old_smartphone_into_a_home_server'\n---\n--\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eI had an unused phone lying around for some time, and I began\ncontemplating how I could repurpose it. This led me to reflect on the\nimpressive performance of modern smartphones and consider whether they\ncould be utilized as servers.\u003c/p\u003e\n\u003cp\u003eSmartphones are equipped with ARM-based processors and run on Android,\nwhich is itself built on the Linux kernel. ARM processors are renowned\nfor their energy efficiency\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e and have recently found\napplications in the server space\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e","title":"How to turn your old smartphone into a home server"},{"content":"We need to divide the array nums into k subsets such that the sum of each subset is same.\n$$ k \\times sum\\ of\\ each\\ subset = total\\ sum\\ sum\\ of\\ each\\ subset = total\\ sum\\ \\div k\\ target = total\\ sum\\ \\div k $$\nNow our task is to find all the k subsets in nums whose sum is target.\nMy idea is to structure this as multi-level recursion. We first try to find the $$k^{th}$$ subset, then $$(k-1)^{th}$$, then $$(k-2)^{th} \u0026hellip;$$ until there is only one subset left. The last subset will naturally sum to target. You can only go to $$(k-1)^{th}$$ level when you are able to successfully find $$k^{th}$$ level subset,\nFor example,\n1 2 3 4 5 6 7 .. .. find the 5th subset find the 4th subset find the 3rd subset find the 2nd subset return true Seeing the recursive structure.\n1 2 3 4 5 6 7 8 9 nums = [4,3,2,3,5,2,1] k=4 target = 20 / 4 = 5 suppose you find the 4th subset as: {3,2} from [4,3,2,3,5,2,1] Now your task reduces to finding 3 subsets in [4, ,3,4,2,1] that sum to target=5 recursive call: nums=[4, ,3,4,2,1] k=3 When finding the kth subset. You can simply use pick/not pick backtracking approach. It is important to understant the distinction between same level recursion (at any given k) which operates by deciding weather to pick/drop nums@i.\nAnd the k levels recursion which succeeds/fails by checking if we can form the $$k^{th}$$ subset.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution: def __init__(self): self.nums, self.target, self.used = None, None, None def canPartitionKSubsets(self, nums: List[int], k: int) -\u0026gt; bool: self.nums = nums total = sum(self.nums) self.target = total // k self.used = [False] * len(nums) if total % k != 0: return False self.nums.sort(reverse=True) return self.bt_search(0, k, 0) def bt_search(self, i: int, k: int, cur_sum: int) -\u0026gt; bool: if k == 1: # last subset is sure to sum upto target return True if i \u0026gt;= len(self.nums) or cur_sum \u0026gt; self.target: return False if cur_sum == self.target: # current subset found, return self.bt_search(0, k-1, 0) # explore the next level of k # try picking nums@i in current subset if not self.used[i] and cur_sum + self.nums[i] \u0026lt;= self.target: self.used[i] = True # explore in same level if self.bt_search(i+1, k, cur_sum + self.nums[i]): return True self.used[i] = False # on failure, skip duplicates of nums@i while i+1 \u0026lt; len(self.nums) and self.nums[i] == self.nums[i+1]: i += 1 # do not pick nums@i -\u0026gt; explore in same level return self.bt_search(i+1, k, cur_sum) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_698_partition_to_k_equal_sum_subsets/","summary":"\u003cp\u003eWe need to divide the array \u003ccode\u003enums\u003c/code\u003e into \u003ccode\u003ek\u003c/code\u003e subsets such that the sum of each subset is same.\u003c/p\u003e\n\u003cp\u003e$$\nk \\times sum\\ of\\ each\\ subset = total\\ sum\\\nsum\\ of\\ each\\ subset = total\\ sum\\ \\div k\\\ntarget = total\\ sum\\ \\div k\n$$\u003c/p\u003e\n\u003cp\u003eNow our task is to \u003cstrong\u003efind all the \u003ccode\u003ek\u003c/code\u003e subsets in nums whose sum is \u003ccode\u003etarget\u003c/code\u003e\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eMy idea is to structure this as multi-level recursion. We first try to find the $$k^{th}$$ subset, then $$(k-1)^{th}$$, then $$(k-2)^{th} \u0026hellip;$$ until there is only one subset left. The last subset will naturally sum to \u003ccode\u003etarget\u003c/code\u003e. You can only go to $$(k-1)^{th}$$ level when you are able to successfully find $$k^{th}$$ level subset,\u003c/p\u003e","title":"Leetcode 698: Partition into k equal sum subsets: The art of recursion: mastering double recursion in a single function"},{"content":"For each possible word, we ask the question: What possible queries can lead to this word?.\nFor example consider the word: abd. Below are the possible (prefix, suffix) queries that can return abd\n1 2 3 4 5 6 7 8 9 10 (prefix, suffix) a abd a bd a d ab abd ab bd ab d abd abd abd bd abd d Now, given word.length \u0026lt;= 7. Each word can at maximum generate 7*7=49 such pairs. Can we store all of them in a hashmap? Yes, because the total storage = 49 * number of words = O(n) Which is acceptable for this problem.\nWhat if there is already a value for (prefix,suffix) in current word. Shall we override it. We need the latest index right?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class WordFilter: def __init__(self, words: List[str]): self.map = {} for widx, w in enumerate(words): for i in range( len(w) ): prefix = w[:i+1] for j in range( len(w) ): suffix = w[j:] # for all possible prefix suffix queries that might route # to current word. We set it in dictionary overriding previously # inserted values to get the maximum index key = prefix + \u0026#39;|\u0026#39; + suffix self.map[key] = widx def f(self, pref: str, suff: str) -\u0026gt; int: key = pref + \u0026#39;|\u0026#39; + suff return self.map.get(key, -1) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_745_prefix_and_suffix_search_solution/","summary":"\u003cp\u003eFor each possible word, we ask the question: \u003cstrong\u003eWhat possible queries can lead to this word?\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor example consider the word: \u003ccode\u003eabd\u003c/code\u003e. Below are the possible (prefix, suffix) queries that can return \u003ccode\u003eabd\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(prefix, suffix)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    d\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  d\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  d\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eNow, given word.length \u0026lt;= 7. Each word can at maximum generate \u003ccode\u003e7*7=49\u003c/code\u003e such pairs. Can we store all of them in a hashmap? Yes, because the total storage = \u003ccode\u003e49 * number of words = O(n)\u003c/code\u003e Which is acceptable for this problem.\u003c/p\u003e","title":"Leetcode 745: prefix and suffix search solution"},{"content":"This problem is very similar to lc543, which is about finding the longest edge path in a tree. You can just copy over that code, and add 2 lines in it.\nHere we are doing the same thing as in lc543, however, when we encounter a non-matching child. We treat it as null.\nFor example, here the longest path at root node is highlighted below in red with 6 edges.\nOur algorithm views the tree like this. The longest path of 3 edges is highlighted in red.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int edges( struct TreeNode* node ); int longest_path; int longestUnivaluePath(struct TreeNode* root) { longest_path = 0; edges(root); return longest_path; } int edges( struct TreeNode* node ) { if ( !node ) return -1; int left = edges(node-\u0026gt;left), right = edges(node-\u0026gt;right); // treat child as null if it doesn\u0026#39;t match parent left = (node-\u0026gt;left \u0026amp;\u0026amp; node-\u0026gt;val == node-\u0026gt;left-\u0026gt;val) ? left : -1; right = (node-\u0026gt;right \u0026amp;\u0026amp; node-\u0026gt;val == node-\u0026gt;right-\u0026gt;val) ? right : -1; longest_path = fmax(longest_path, 1+left + 1+right); return 1 + fmax( left, right); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution: def __init__(self): self.ans = 0 def longestUnivaluePath(self, root: Optional[TreeNode]) -\u0026gt; int: self.edges( root ) return self.ans def edges(self, node: Optional[TreeNode]) -\u0026gt; int: if not node: return -1 left, right = self.edges( node.left ), self.edges( node.right ) # if the child is illegitimate. Discard it if not node.left or node.left.val != node.val: left = -1 # treat as null if not node.right or node.right.val != node.val: right = -1 self.ans = max( self.ans, ( 1+left ) + ( 1 + right ) ) return 1 + max( left, right ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function longestUnivaluePath(root: TreeNode | null): number { let ans = 0; const edges = ( node: TreeNode|null ): number =\u0026gt; { if ( !node ) return -1; let left = edges( node.left ), right = edges( node.right ); // if child value doesn\u0026#39;t match -\u0026gt; treat as null left = (node.left \u0026amp;\u0026amp; node.val == node.left.val) ? left : -1; right = (node.right \u0026amp;\u0026amp; node.val == node.right.val) ? right : -1; ans = Math.max( ans, (1 + left) + (1 + right) ); return 1 + Math.max( left, right ); } edges( root ); return ans; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function longestUnivaluePath(root) { let ans = 0; const edges = ( node ) =\u0026gt; { if ( !node ) return -1; let left = edges( node.left ), right = edges( node.right ); // if child value doesn\u0026#39;t match -\u0026gt; treat as null left = (node.left \u0026amp;\u0026amp; node.val == node.left.val) ? left : -1; right = (node.right \u0026amp;\u0026amp; node.val == node.right.val) ? right : -1; ans = Math.max( ans, (1 + left) + (1 + right) ); return 1 + Math.max( left, right ); } edges( root ); return ans; }; ","permalink":"http://localhost:45763/personal_website/posts/solution_to_leetcode_687_longest_univalue_path/","summary":"\u003cp\u003eThis problem is very similar to\n\u003ca href=\"https://leetcode.com/problems/diameter-of-binary-tree/solutions/6824338/solution-for-dummies-by-abdulrahim2002-yzrs/\"\u003elc543\u003c/a\u003e,\nwhich is about finding the longest edge path in a tree. You can just\ncopy over that code, and add 2 lines in it.\u003c/p\u003e\n\u003cp\u003eHere we are doing the same thing as in lc543, however, when we encounter a non-matching child. We treat it as null.\u003c/p\u003e\n\u003cp\u003eFor example, here the longest path at root node is highlighted below in red with 6 edges.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/148ffbfd-0ead-48cd-b45d-8c2575bafd11_1751999234.494938.png\"\u003e\u003c/p\u003e","title":"Solution to Leetcode 687: Longest Univalue Path"},{"content":"I keep track of the top k elements in sorted list. The kth largest element is the smallest of the top k elements.\ne.g. top k(=6) elements: [3,5,7,10,42,56] in sorted order. The kth largest element = 6th largest element = smallest element in above list.\nWhen I insert an element, I simply check if it can make it\u0026rsquo;s place among k largest elements already present in the list. Which it can, if it can defeat the smallest element in our list.\nFor example, we cannot add 2 in the array above since it fails to defeat 3.\nHowever, A number like 15 can be inserted. In which case, we remove the smallest element i.e. 3, to keep the list length=k\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class KthLargest: def __init__(self, k: int, nums: List[int]): self.scores = SortedList() self.limit = k for num in nums: self.add(num) def add(self, val: int) -\u0026gt; int: # if the current element can make space in top k elements if len(self.scores) \u0026lt; self.limit or self.scores[0] \u0026lt; val: self.scores.add(val) # remove smallest if len(self.scores) \u0026gt; self.limit: self.scores.pop(0) # return smallest return self.scores[0] ","permalink":"http://localhost:45763/personal_website/posts/leetcode_703_kth_largest_element_in_a_stream/","summary":"\u003cp\u003eI keep track of the top k elements in sorted list.\nThe kth largest element is the \u003cstrong\u003esmallest of the top k elements\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003ee.g. top k(=6) elements: \u003ccode\u003e[3,5,7,10,42,56]\u003c/code\u003e in sorted order.\nThe kth largest element = 6th largest element = smallest element in above list.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/070564ea-afa3-4108-92e6-7fa76c2fb981_1752504996.0140414.png\"\u003e\u003c/p\u003e\n\u003cp\u003eWhen I insert an element, I simply check if it can make it\u0026rsquo;s place among k largest elements already present in the list. Which it can, if it can defeat the smallest element in our list.\u003c/p\u003e","title":"Leetcode 703: kth largest element in a stream solution in python"},{"content":"When numbers from $$\\in$$ [0,n-1] are sorted in an array of size n. Their sorted position is equal to their index.\nSubset of numbers in array[i:j] can form a partition, if all elements in [i,j) are available in array[i:j].\nFor example [2,0,1] can form a partition, since they are at index 0, 1, 2 respectively. Sorted will involving swapping them at their correct position.\nThe basic idea behind this solution is that we try to identify such partitions, where all elements required to be sorted in [i, j] are available in current partition.\nHere\u0026rsquo;s the visualization of the algorithm, i points to the start of the group and j iterates through the group and checks if the current group needs to be expanded. e points to the end of the current group.\nSince, array[j]=1, we found a number greater than current boundaries. We need to expand the boundary. Hence, new group end is e = array[j].\nIncrement j. We find that array[1] = 0 which is \u0026lt; current end. Increment j again, j=2, Hence, no we exhaust the current group and we move forward to finding the next partition. Increase, current group ending, and reinitialize i=e/\nIn the second group, we have array[j]=2 and we are at index 2. Hence, we do not need to expand this group, since 2 is at right position.\nSimilarly we find the next 2 partitions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int maxChunksToSorted(int* arr, int arrSize) { int cur_gp_end = 0, cnt_gps = 0, i = 0; while ( i \u0026lt; arrSize ) { int j = i; // try to terminate the current group while ( j \u0026lt;= cur_gp_end ) { cur_gp_end = fmax( cur_gp_end, arr[j] ); j++; } i = ++cur_gp_end; cnt_gps++; } return cnt_gps; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_769_max_chunks_to_make_sorted/","summary":"\u003cp\u003eWhen numbers from $$\\in$$ \u003ccode\u003e[0,n-1]\u003c/code\u003e are sorted in an array of size n. Their sorted position is equal to their index.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/07a3b1d2-9478-486f-9f62-3a67e6dde1b3_1752513551.205261.png\"\u003e\u003c/p\u003e\n\u003cp\u003eSubset of numbers in \u003ccode\u003earray[i:j]\u003c/code\u003e can form a partition, if all elements in \u003ccode\u003e[i,j)\u003c/code\u003e are available in \u003ccode\u003earray[i:j]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFor example \u003ccode\u003e[2,0,1]\u003c/code\u003e can form a partition, since they are at index \u003ccode\u003e0, 1, 2\u003c/code\u003e respectively. Sorted will involving swapping them at their correct position.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/77d9235f-d72a-416a-bd77-d8802d7567b0_1752513786.651974.png\"\u003e\u003c/p\u003e\n\u003cp\u003eThe basic idea behind this solution is that we try to identify such partitions, where all elements required to be sorted in \u003ccode\u003e[i, j]\u003c/code\u003e are available in current partition.\u003c/p\u003e","title":"Leetcode 769: Max chunks to make sorted solution"},{"content":"For each word, we basically store all versions of it after removal of 1 character. For example,\n1 2 3 4 5 6 hello -\u0026gt; ello -\u0026gt; removed h@0 hllo -\u0026gt; removed e@1 helo -\u0026gt; removed l@2 helo -\u0026gt; removed l@3 hell -\u0026gt; removed o@4 We can store: wordAfterRemoval,indexOfRemoval in hashmap. So whenever we search for a word like: hexlo then we can try removing it\u0026rsquo;s 2nd index and search: helo,2 in the map, which we will find.\nIn the value we can store the removed character. For example, store key=helo,2 with value=l to indicate that l was removed.\nSo when you match a word like hexlo. Try to search helo,2 in the hashmap. It gives value=l which is !='x' i.e. the removed character in hexlo.\nHowever, there is one problem with this approach. When you add 2 words like: hello and hallo in the map. Then hllo,1 will give e in the first insertion and a in the second. The second overides the first so hello is forgetten by the structure. To avoid this issue, we store both of them (e, a) in a list.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class MagicDictionary { private map = new Map\u0026lt;string,string[]\u0026gt;(); buildDict(dictionary: string[]): void { for ( const word of dictionary ) { for ( let i=0; i \u0026lt; word.length; i++ ) { const wordAfterRemoval = word.slice(0, i) + word.slice(i+1); // key stores wordAfterRemoval,indexOfRemoval as value const key = `${wordAfterRemoval},${i}`; if ( !this.map.has(key) ) this.map.set(key,[]); // values have the removed character this.map.get(key).push( word[i] ) } } } search(word: string): boolean { for ( let i=0; i \u0026lt; word.length; i++ ) { const wordAfterRemoval = word.slice(0, i) + word.slice(i+1); const key = `${wordAfterRemoval},${i}`; if ( !this.map.has(key) ) continue; const removedChars = this.map.get(key); // If there was a word with removed character != word[i] for ( let j=0; j \u0026lt; removedChars.length; j++ ) { if ( removedChars[j] !== word[i] ) return true; } } return false; } } You can also embed the index information by replacing the removed word with _ like in this pyton version:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class MagicDictionary: def __init__(self): self.map = {} def buildDict(self, dictionary: List[str]) -\u0026gt; None: for word in dictionary: for i in range(len(word)): key = word[0:i] + \u0026#39;_\u0026#39; + word[i+1:] if not key in self.map: self.map[key] = [] self.map[key].append(word[i]) def search(self, searchWord: str) -\u0026gt; bool: for i in range(len(searchWord)): key = searchWord[0:i] + \u0026#39;_\u0026#39; + searchWord[i+1:] if key not in self.map: continue for c in self.map[key]: if c != searchWord[i]: return True return False # Your MagicDictionary object will be instantiated and called as such: # obj = MagicDictionary() # obj.buildDict(dictionary) # param_2 = obj.search(searchWord) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_676_magic_dictionary/","summary":"\u003cp\u003eFor each word, we basically store all versions of it after removal of 1 character. For example,\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehello -\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eello -\u0026gt; removed h@0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehllo -\u0026gt; removed e@1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehelo -\u0026gt; removed l@2\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehelo -\u0026gt; removed l@3\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehell -\u0026gt; removed o@4\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eWe can store: \u003ccode\u003ewordAfterRemoval,indexOfRemoval\u003c/code\u003e in hashmap. So whenever we search for a word like: \u003ccode\u003ehexlo\u003c/code\u003e then we can try removing it\u0026rsquo;s 2nd index and search: \u003ccode\u003ehelo,2\u003c/code\u003e in the map, which we will find.\u003c/p\u003e","title":"Leetcode 676: magic dictionary"},{"content":"consider the word \u0026ldquo;catsdogcats\u0026rdquo;. We have the dictionary: [\u0026quot;cat\u0026quot;,\u0026quot;cats\u0026quot;,\u0026quot;catsdogcats\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;dogcatsdog\u0026quot;,\u0026quot;hippopotamuses\u0026quot;,\u0026quot;rat\u0026quot;,\u0026quot;ratcatdogcat\u0026quot;]\nWe iterate over the word: catsdogcats and at each iteration, we ask if the prefix is contained in dictionary.\nIf the prefix is in the dictionary, we recursively call the function on the remaining word (excluding matched prefix)\nis c in dictionary ? is ca in dictionary ? is cat in dictionary ? -\u0026gt; YES call( sdogcats ) \u0026ndash;[1] Prefix cat matched so recursively call with sdogcats\nis s in dictionary ? is sd in dictionary ? \u0026hellip;. is sdogcats in dictionary ? NO We exhausted the word so we return false. Nothing was matched\nBack at the first call, this time we try to match cats Return to [1]\nis cats in dictionary -\u0026gt; YES recursively call on dogcats\nis d in dictionary ?\nis do in dictionary ?\nis dog in dictionary ? -\u0026gt; YES, recursively call on cats\nis c in dictionary ?\nis ca in dictionary ?\nis cat in dictionary ? YES , recursively call(s) \u0026ndash;[2]\nis s in dictionary ? NO -\u0026gt; word exhausted, return false;\nBack at recursive call [2]\nis cats in dictionary ? YES recursively call(``) i.e. empty string When we reach empty string, it means whole of string can be constructed using words in dictionary. Hence return true.\nImport considerations:\nThe dictionary has all the words, which means that catsdogcats will match with itself completely. To avoid words matching with themselves, we tell the function to ignore the catsdogcats word to avoid matching it with itself. Also, we can memoize the results since, dictionary remains the same, only target word and ignore word changes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function findAllConcatenatedWordsInADict(words: string[]): string[] { const dict = new Set\u0026lt;string\u0026gt;( words ); return words.filter( curWord =\u0026gt; canChunk( curWord, curWord, dict ) ); }; function canChunk( target: string, ignore: string, dict: Set\u0026lt;string\u0026gt;, memo = new Map\u0026lt;string, boolean\u0026gt;() ): boolean { if ( !target.length ) return true; const key = target + ignore; if ( memo.has( key ) ) return memo.get( key ); for ( let i=1; i \u0026lt;= target.length; i++ ) { const prefix = target.slice( 0, i ); if ( prefix !== ignore \u0026amp;\u0026amp; dict.has( prefix ) \u0026amp;\u0026amp; canChunk( target.slice( i ), ignore, dict, memo ) ) { memo.set( key, true ); return true; } } memo.set( key, false ); return false; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_472_concatenated_words/","summary":"\u003cp\u003econsider the word \u0026ldquo;catsdogcats\u0026rdquo;. We have the dictionary: \u003ccode\u003e[\u0026quot;cat\u0026quot;,\u0026quot;cats\u0026quot;,\u0026quot;catsdogcats\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;dogcatsdog\u0026quot;,\u0026quot;hippopotamuses\u0026quot;,\u0026quot;rat\u0026quot;,\u0026quot;ratcatdogcat\u0026quot;]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWe iterate over the word: \u003ccode\u003ecatsdogcats\u003c/code\u003e and at each iteration, we ask if the prefix is contained in dictionary.\u003c/p\u003e\n\u003cp\u003eIf the prefix is in the dictionary, we recursively call the function on the remaining word (excluding matched prefix)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eis \u003ccode\u003ec\u003c/code\u003e in dictionary ?\u003c/li\u003e\n\u003cli\u003eis \u003ccode\u003eca\u003c/code\u003e in dictionary ?\u003c/li\u003e\n\u003cli\u003eis \u003ccode\u003ecat\u003c/code\u003e in dictionary ? -\u0026gt; YES       call( \u003ccode\u003esdogcats\u003c/code\u003e ) \u0026ndash;[1]\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePrefix \u003ccode\u003ecat\u003c/code\u003e matched so recursively call with \u003ccode\u003esdogcats\u003c/code\u003e\u003c/p\u003e","title":"Leetcode 472: Concatenated words"},{"content":"The task is to find a subarray with sum of elements = k\nTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\nThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\n$$ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k] $$\nNow we are looking for sub of subarray = T(target). Therefore:\n$$ sum\\ of\\ subarray = prefix\\ [j]\\ -\\ prefix\\ [i-1] = T\\ \\ prefix\\ [i-1] = prefix\\ [j]\\ - T $$\nTherefore, we iterate the prefix array. And at each prefix[j], we search for a previously inserted prefix[i-1] such that prefix[i-1] = prefix[j] - T. We also need the count of such subarrays. At a particular j the number of subarrays where sum=T is the number of i that occured previously such that prefix[i-1] = prefix[j] - T. Index j will form a subarray with each of such previous i\u0026rsquo;s.\nWe must store the mapping: ( prefix[x], count ) in a map.\nSo far so good. But what happens when $$i=0$$. In this case, sum of subarray between indices [0, j] is defined as:\n$$ prefix\\ [j] = \\sum_{k=0}^j nums\\ [k] = T $$\nAt each index j, the code will try to look for prefix[j] - T in the map. When prefix[j]=T itself, then it would look for T-T=0 into the map. Therefore we must keep prefix= 0, count= 1 into the map to account for subarrays starting at index 0.\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 function subarraySum(nums: number[], k: number): number { const map = new Map\u0026lt;number, number\u0026gt;([ [0, 1] ]); let sumk = 0; for ( let j=0; j \u0026lt; nums.length; j++ ) { nums[j] = ( j==0 ) ? nums[j] : nums[j-1] + nums[j]; sumk += map.get( nums[j] - k ) ?? 0; map.set( nums[j], ( map.get(nums[j]) ?? 0 ) + 1 ); } return sumk; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_560_subarray_sub_equal_k_solution/","summary":"\u003cp\u003eThe task is to find a subarray with \u003ccode\u003esum of elements = k\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\u003c/p\u003e\n\u003cp\u003eThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\u003c/p\u003e\n\u003cp\u003e$$\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k]\n$$\u003c/p\u003e","title":"Leetcode 560: Subarray sum equals k"},{"content":"Consider the array: [0,1,1,0,0,1,1,0,1,1] The idea is to turn the 0\u0026rsquo;s into -1\u0026rsquo;s\narray: [-1,1,1,-1,-1,1,1,-1,1,1]\nNow, the task is to find a subarray with sum of elements = 0\nTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\nThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\n$$ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k] $$\nAnd the length of the subarray between indices $$[i,j]$$ is defined as: $$length(i,j) = j-i+1 = j-(i-1) $$\nNow we are looking for sub of subarray = 0. Therefore:\n$$ sum\\ of\\ subarray = prefix\\ [j]\\ -\\ prefix\\ [i-1] = 0\\ prefix\\ [j]\\ =\\ prefix\\ [i-1] $$\nTherefore, we iterate the prefix array. And at each prefix[j], we search for a previously inserted prefix[i-1] such that prefix[j]=prefix[i-1]. We record the length of the current subarray as: length = j-(i-1).\nWe must store the mapping: ( prefix[k], k ) in a map to achieve this.\nSo far so good. But what happens when $$i=0$$. In this case, sum of subarray between indices [0, j] is defined as:\n$$ prefiix\\ [j] = \\sum_{k=0}^j nums\\ [k] $$\nAnd the length of the subarray [0,j] is: $$j+1 = j-(-1)$$\nTherefore we keep a superficial (prefix = 0, index = -1) in the map.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function findMaxLength(nums: number[]): number { const map = new Map\u0026lt;number, number\u0026gt;( [ [0, -1], ] ); let maxLen = 0; for ( let j=0; j \u0026lt; nums.length; j++ ) { let cur = ( nums[j] == 1 ) ? 1 : -1; nums[j] = ( j==0 ) ? cur : cur + nums[j-1]; // prefix sum occured previously at i. Length = j-i if ( map.has( nums[j] ) ) { let i = map.get( nums[j] ); maxLen = Math.max( maxLen, j - i ); } // put the current prefix sum into map if ( !map.has( nums[j] ) ) map.set( nums[j], j ); } return maxLen; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_525_contiguous_array/","summary":"\u003cp\u003eConsider the array: \u003ccode\u003e[0,1,1,0,0,1,1,0,1,1] \u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe idea is to turn the 0\u0026rsquo;s into -1\u0026rsquo;s\u003c/p\u003e\n\u003cp\u003earray: \u003ccode\u003e[-1,1,1,-1,-1,1,1,-1,1,1]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eNow, the task is to find a subarray with \u003ccode\u003esum of elements = 0\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\u003c/p\u003e\n\u003cp\u003eThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\u003c/p\u003e\n\u003cp\u003e$$\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k]\n$$\u003c/p\u003e","title":"Leetcode_525_contiguous_array"},{"content":"The idea is to keep 2 pointers. trail pointer and cur pointer. The list is build in recursive function build(trail, cur) which returns last node of the list we build.\nbuild works as follows:\nwhen there is no child node: simply connect trail and cur and advance both when there is a child node, then recursively call itself with build( trail = cur, cur = cur.child ). The call would connect cur node with the list in the next level. It would return the last node in next level. Then we assign trail = last node in next level and cur = cur.next in current level. This ensures that the next iteration would connect last node in next level to next node in current level. when cur becomes null trail is the last node in current level. return trail Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function flatten(head: _Node | null): _Node | null { const save: _Node = new _Node( -1 ); build( save, head ); if ( save.next ) save.next.prev = null; return save.next; }; function build( trail: _Node | null, cur: _Node | null ): _Node | null { while ( cur ) { if ( !cur.child ) { trail.next = cur; cur.prev = trail; trail = trail.next; cur = cur.next; } else { trail.next = cur; cur.prev = trail; const saveNext = cur.next; const lastNodeFromChildList = build( cur, cur.child ); cur.child = null; cur = saveNext; trail = lastNodeFromChildList; } } return trail; } Complexity Time complexity: $$O(n)$$\nSpace complexity: $$O(n)$$ {recursion stack}\n","permalink":"http://localhost:45763/personal_website/posts/leetcode_430_flattening_multilevel_linked_list/","summary":"\u003cp\u003eThe idea is to keep 2 pointers. \u003ccode\u003etrail\u003c/code\u003e pointer and \u003ccode\u003ecur\u003c/code\u003e pointer. The\nlist is build in recursive function \u003ccode\u003ebuild(trail, cur)\u003c/code\u003e which returns\nlast node of the list we build.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebuild\u003c/code\u003e works as follows:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ewhen there is no \u003ccode\u003echild\u003c/code\u003e node: simply connect \u003ccode\u003etrail\u003c/code\u003e and \u003ccode\u003ecur\u003c/code\u003e and advance both\u003c/li\u003e\n\u003cli\u003ewhen there is a \u003ccode\u003echild\u003c/code\u003e node, then recursively call itself with \u003ccode\u003ebuild( trail = cur, cur = cur.child )\u003c/code\u003e. The call would connect \u003ccode\u003ecur\u003c/code\u003e node with the \u003ccode\u003elist in the next level\u003c/code\u003e. It would return the last node in next level. Then we assign \u003ccode\u003etrail = last node in next level\u003c/code\u003e and \u003ccode\u003ecur = cur.next in current level\u003c/code\u003e. This ensures that the next iteration would connect \u003ccode\u003elast node in next level\u003c/code\u003e to \u003ccode\u003enext node in current level\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003ewhen \u003ccode\u003ecur\u003c/code\u003e becomes \u003ccode\u003enull\u003c/code\u003e \u003ccode\u003etrail\u003c/code\u003e is the last node in current level. \u003ccode\u003ereturn trail\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"code\"\u003eCode\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003eflatten\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ehead\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kr\"\u003econst\u003c/span\u003e   \u003cspan class=\"nx\"\u003esave\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ehead\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003esaveNext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003elastNodeFromChildList\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003esaveNext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003elastNodeFromChildList\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"complexity\"\u003eComplexity\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTime complexity:  $$O(n)$$\u003c/p\u003e","title":"Leetcode 430: Flattening a multilevel linked list"},{"content":"Below is my solution for the leetcode 154: Find minimum in rotated sorted array problem\nIntuition Fact is, that you cannot solve this question in O(log n) time. The reason is because of duplicates.\nConsider a situation like:\n$$ [2,2,2,2,1,2,2] $$\nwhere mid is at 3 and the minium number here is clearly $$1$$. But our binary search algorithm will not be able to figure out in which direction it should go, since starting, ending and middle values are all same. In this case the best we can do is increment mid which makes the worst running time: O(n)\nHowever, it is possible to solve this problem in O(n/2) as explain below.\nApproach We will make use of the fact that a sorted array follows the (min) heap property i.e. in a sorted array, at all parent nodes are smaller than their children.\nAnd if this sorted array is rotated, then the place at which the first violation occurs is the subtree where the answer will be found.\nComplexity Time complexity: $$O(n/2)$$ Space complexity: $$O(1)$$ Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 var findMin = function(a) { /** Approach: You cannot solve this problem in O(log n) since it contains duplicate values. But you can actually solve this problem in O(n/2) by using the fact that a sorted array follows heap property. And if a sorted array is rotated then the heap property no longer holds. to find the minium element traverse the array, and find the first subtree where the heap property does not hold. the minium of the 2 values where the heap property does not satisfy is also minium in the array. Time: O(n/2) Space: O(1) */ let A = a.length; let i = 0; while ( i \u0026lt;= Math.floor(A/2)-1 ) { let root = i; let lc = 2*i + 1; let rc = 2*i + 2; let smallest = root; if ( lc \u0026lt; A \u0026amp;\u0026amp; a[lc] \u0026lt; a[smallest] ) smallest = lc; if ( rc \u0026lt; A \u0026amp;\u0026amp; a[rc] \u0026lt; a[smallest] ) smallest = rc; if ( smallest != root ) /* violation found. the value at smallest is minium */ return a[smallest]; i++; } /* no violation found. Either the array is sorted ar there it is all duplicates, in either case, return the first element. */ return a[0]; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_154_find_minimum_in_rotated_sorted_array/","summary":"\u003cp\u003eBelow is my solution for the \u003ca href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/\"\u003eleetcode 154: Find minimum in rotated\nsorted array problem\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"intuition\"\u003eIntuition\u003c/h1\u003e\n\u003c!-- Describe your first thoughts on how to solve this problem. --\u003e\n\u003cp\u003eFact is, that you \u003cstrong\u003ecannot\u003c/strong\u003e solve this question in \u003cstrong\u003eO(log n)\u003c/strong\u003e time. The reason is because of duplicates.\u003c/p\u003e\n\u003cp\u003eConsider a situation like:\u003c/p\u003e\n\u003cp\u003e$$\n[2,2,2,2,1,2,2]\n$$\u003c/p\u003e\n\u003cp\u003ewhere mid is at 3 and the minium number here is clearly $$1$$. But our binary search algorithm will not be able to figure out in which direction it should go, since starting, ending and middle values are all same. In this case the best we can do is increment mid which makes the worst running time: \u003cstrong\u003eO(n)\u003c/strong\u003e\u003c/p\u003e","title":"Leetcode 154: Find minimum in rotated sorted array"},{"content":"Here\u0026rsquo;s my solution to the Leetcode 315: Count of Smaller Numbers After Self problem using standard merge sort. I just change one line to count while merge procedure.\nSolution Let\u0026rsquo;s build the solution step by step.\nInput: nums = $$[5,2,6,1]$$\nFirst, turn the numbers into [number, index] tuple. So it looks like:\narray = $$ [ [ 5, 0 ], [ 2, 1 ], [ 6, 2 ], [ 1, 3 ] ] $$\nSecond, just write standard merge sort algorithm and sort the array in ascending order by first values.\nThe output is: $$ [ [ 1, 3 ], [ 2, 1 ], [ 5, 0 ], [ 6, 2 ] ] $$\nHere\u0026rsquo;s the trace of the algorithm:\nSimple merge sort implemented 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { tmp.push( a[j] ); j++; } else { tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); merge_sort( array, 0, array.length-1 ); }; So far so good.\nNow let\u0026rsquo;s get back to the question. The question is asking: For each index $$i$$, count all numbers at index $$j$$ such that $$i \u0026lt; j$$ and $$a[i] \u0026gt; a[j]$$. Or, simply put: for each number, find all numbers that appear after it and are smaller than it.\nNow, look at the visualization again, pay attention to the merge procedure (in magenta colour) and observe the following:\nat each merge procedure, we merge 2 consecutive partitions. all numbers in the left partition appear before numbers in right partition in the original array. The partitions are sorted in increasing order. Now, suppose we are merging 2 partitions where, the pointer of left partition is at $$x$$ and pointer of right partition is at $$y$$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [....a,b,c, x ,d,e,f....] [...h,i,j, y, k,l,m....] ^ ^ i j Suppose x \u0026gt; y It follows from observation 2 that: y is one of the numbers that appear to the right of x and is smaller than x ---(1) Also, since partitions are sorted (observation 3): d, e, f .... (i.e. all number that appear to the right of x) are greater than x. ----(2) From (1) and (2) we can conclude that: x, d, e, f, ... (i.e. all numbers to the right of x including x) appear before y. And y is smaller than all these numbers. Hence, required condition satisfied! Now, we just need a counter for each variable, and whenever the condition same as above occurs, we increment the counter for each x,d,e,\u0026hellip;\n1 2 3 4 5 6 7 [....a,b,c, x ,d,e,f....] [...h,i,j, y, k,l,m....] ^ ^ i j while merging: if x \u0026gt; y increment the counters of x, d, e, f, ... Single line changed in standard merge sort algorithm We can use the index at the second position to access the counter of that particular number.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 let counts; const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { /* ____(x \u0026gt; y) so increment counters of x,d,e,...____*/ for ( let p=i; p\u0026lt;=mid; p++ ) counts[ a[p][1] ]++; /*_______________INSERT THIS LINE_____________________*/ tmp.push( a[j] ); j++; } else { tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); counts = new Array(nums.length).fill(0); merge_sort( array, 0, array.length-1 ); return counts; }; That is the whole idea behind this question. Now the above implementation won\u0026rsquo;t work because at each iteration, we are updating whole left partition after i. Making it O(n^2) Optimize To avoid updating the whole partition, we keep a running counter cnt.\nFinal implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 let counts; const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; let cnt = 0; // keep running counter while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { cnt++; // increment counter tmp.push( a[j] ); j++; } else { counts[ a[i][1] ] += cnt; // no more numbers that are // smaller than i tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { counts[ a[i][1] ] += cnt; // if left partition is not over // update left over number counts tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); counts = nums; counts.fill(0); merge_sort( array, 0, array.length-1 ); return counts; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def countSmaller(nums): counts = [0] * len(nums) array = [(num, i) for i, num in enumerate(nums)] def merge_sort(start, end): if start == end: return mid = (start + end) // 2 merge_sort(start, mid) merge_sort(mid + 1, end) merge(start, mid, end) def merge(start, mid, end): temp = [] i, j = start, mid + 1 cnt = 0 while i \u0026lt;= mid and j \u0026lt;= end: if array[i][0] \u0026gt; array[j][0]: cnt += 1 temp.append(array[j]) j += 1 else: counts[array[i][1]] += cnt temp.append(array[i]) i += 1 while i \u0026lt;= mid: counts[array[i][1]] += cnt temp.append(array[i]) i += 1 while j \u0026lt;= end: temp.append(array[j]) j += 1 for i in range(len(temp)): array[start + i] = temp[i] merge_sort(0, len(nums) - 1) return counts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; countSmaller(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; counts(nums.size(), 0); vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; array; for (int i = 0; i \u0026lt; nums.size(); i++) { array.emplace_back(nums[i], i); } function\u0026lt;void(int, int)\u0026gt; merge_sort = [\u0026amp;](int start, int end) { if (start == end) return; int mid = start + (end - start) / 2; merge_sort(start, mid); merge_sort(mid + 1, end); merge(start, mid, end); }; function\u0026lt;void(int, int, int)\u0026gt; merge = [\u0026amp;](int start, int mid, int end) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; temp; int i = start, j = mid + 1; int cnt = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end) { if (array[i].first \u0026gt; array[j].first) { cnt++; temp.push_back(array[j]); j++; } else { counts[array[i].second] += cnt; temp.push_back(array[i]); i++; } } while (i \u0026lt;= mid) { counts[array[i].second] += cnt; temp.push_back(array[i]); i++; } while (j \u0026lt;= end) { temp.push_back(array[j]); j++; } for (int k = 0; k \u0026lt; temp.size(); k++) { array[start + k] = temp[k]; } }; merge_sort(0, nums.size() - 1); return counts; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import java.util.*; class Solution { private int[] counts; private int[][] array; public List\u0026lt;Integer\u0026gt; countSmaller(int[] nums) { counts = new int[nums.length]; array = new int[nums.length][2]; for (int i = 0; i \u0026lt; nums.length; i++) { array[i][0] = nums[i]; array[i][1] = i; } mergeSort(0, nums.length - 1); List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (int count : counts) { result.add(count); } return result; } private void mergeSort(int start, int end) { if (start == end) return; int mid = start + (end - start) / 2; mergeSort(start, mid); mergeSort(mid + 1, end); merge(start, mid, end); } private void merge(int start, int mid, int end) { List\u0026lt;int[]\u0026gt; temp = new ArrayList\u0026lt;\u0026gt;(); int i = start, j = mid + 1; int cnt = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end) { if (array[i][0] \u0026gt; array[j][0]) { cnt++; temp.add(array[j]); j++; } else { counts[array[i][1]] += cnt; temp.add(array[i]); i++; } } while (i \u0026lt;= mid) { counts[array[i][1]] += cnt; temp.add(array[i]); i++; } while (j \u0026lt;= end) { temp.add(array[j]); j++; } for (int k = 0; k \u0026lt; temp.size(); k++) { array[start + k] = temp.get(k); } } } Time: $$O(n\\ log\\ n)$$ Space: $$O(n)$$ ","permalink":"http://localhost:45763/personal_website/posts/leetcode_315_count_of_smaller_numbers_after_self/","summary":"\u003cp\u003eHere\u0026rsquo;s my solution to the \u003ca href=\"https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/\"\u003eLeetcode 315: Count of Smaller Numbers After\nSelf problem\u003c/a\u003e using standard merge sort. I just change one line to\ncount while merge procedure.\u003c/p\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\n\u003cp\u003eLet\u0026rsquo;s build the solution step by step.\u003c/p\u003e\n\u003cp\u003eInput: nums = $$[5,2,6,1]$$\u003c/p\u003e\n\u003cp\u003eFirst, turn the numbers into \u003cstrong\u003e[number, index]\u003c/strong\u003e tuple. So it looks like:\u003c/p\u003e\n\u003cp\u003earray = $$ [ [ 5, 0 ], [ 2, 1 ], [ 6, 2 ], [ 1, 3 ] ] $$\u003c/p\u003e","title":"Leetcode 315: Count of Smaller Numbers After Self"},{"content":"Here\u0026rsquo;s my explanation for the leetcode 306: Additive Number problem\nAdditive Number Problem Problem Recap An additive number is a string of digits where the sequence of numbers formed by splitting the string satisfies the condition that each number (after the first two) is the sum of the two preceding numbers.\nExamples: \u0026quot;112358\u0026quot; is additive because the sequence is 1, 1, 2, 3, 5, 8, and:\n1 + 1 = 2 1 + 2 = 3 2 + 3 = 5 3 + 5 = 8 \u0026quot;199100199\u0026quot; is additive because the sequence is 1, 99, 100, 199, and:\n1 + 99 = 100 99 + 100 = 199 Solution Approach The solution uses a backtracking approach to try all possible splits of the string into sequences of numbers and checks if any of these sequences form an additive sequence.\nDetailed Explanation Helper Function isValid This recursive function checks if the remaining part of the string s forms a valid additive sequence given the first two numbers a and b.\nBase Case: If the remaining string s is empty, it means we\u0026rsquo;ve successfully formed an additive sequence, so return true.\nRecursive Step:\nCompute the sum of a and b and convert it to a string sum. Check if the remaining string s starts with sum: If not, the sequence is invalid  return false. If yes, recursively check the next part of the string with the new pair (b, sum) and the remaining string after removing sum. Main Function isAdditiveNumber Initialization: Get the length of the input string num. Nested Loops: The outer loop (i) determines the end index of the first number a (from index 0 to i). The inner loop (j) determines the end index of the second number b (from index i to j). Leading Zero Check: Skip any splits where a or b have leading zeros unless they are exactly \u0026quot;0\u0026quot;. Example: \u0026quot;02\u0026quot; is invalid, but \u0026quot;0\u0026quot; is valid. Validation: For each valid pair (a, b), call isValid to check if the remaining part of the string forms a valid additive sequence starting with a and b. If isValid returns true, immediately return true from the main function. Final Check: If no valid sequence is found after all possible splits, return false. Example Walkthrough Let\u0026rsquo;s walk through the example num = \u0026quot;112358\u0026quot;:\nFirst Iteration (i = 1, j = 2): a = \u0026quot;1\u0026quot;, b = \u0026quot;1\u0026quot;. No leading zeros  proceed. isValid(1, 1, \u0026quot;2358\u0026quot;): Sum of 1 + 1 = 2. Check if \u0026quot;2358\u0026quot; starts with \u0026quot;2\u0026quot;  Yes. Recursively call isValid(1, 2, \u0026quot;358\u0026quot;): Sum of 1 + 2 = 3. Check if \u0026quot;358\u0026quot; starts with \u0026quot;3\u0026quot;  Yes. Recursively call isValid(2, 3, \u0026quot;58\u0026quot;): Sum of 2 + 3 = 5. Check if \u0026quot;58\u0026quot; starts with \u0026quot;5\u0026quot;  Yes. Recursively call isValid(3, 5, \u0026quot;8\u0026quot;): Sum of 3 + 5 = 8. Check if \u0026quot;8\u0026quot; starts with \u0026quot;8\u0026quot;  Yes. Recursively call isValid(5, 8, \u0026quot;\u0026quot;): Empty string  return true. Since isValid returned true, the main function returns true. Edge Cases Leading Zeros: Correctly skips invalid splits (e.g., \u0026quot;02\u0026quot; unless it\u0026rsquo;s \u0026quot;0\u0026quot;). Single Digit: If input length \u0026lt; 3, returns false. Large Numbers: Uses parseInt, but BigInt is better for very large numbers to avoid precision issues. Time Complexity Nested loops: O(n), where n is the string length. isValid function: O(n) per pair (a, b). Overall: O(n), feasible for reasonably sized strings. Space Complexity O(n) due to recursion stack in the worst case. Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var isAdditiveNumber = function(num) { const isValid = (a, b, s) =\u0026gt; { if (s.length === 0) return true; const sum = (a + b).toString(); return s.startsWith(sum) \u0026amp;\u0026amp; isValid(b, parseInt(sum), s.slice(sum.length)); }; const n = num.length; for (let i = 1; i \u0026lt; n; i++) { for (let j = i + 1; j \u0026lt; n; j++) { const a = num.slice(0, i); const b = num.slice(i, j); if ((a.startsWith(\u0026#39;0\u0026#39;) \u0026amp;\u0026amp; a.length \u0026gt; 1) || (b.startsWith(\u0026#39;0\u0026#39;) \u0026amp;\u0026amp; b.length \u0026gt; 1)) continue; if (isValid(parseInt(a), parseInt(b), num.slice(j))) return true; } } return false; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 var isAdditiveNumber = function(num) { let N = num.length; let check = ( a ) =\u0026gt; { /** check if numbers in an array form fibonacci seqence **/ let A = a.length; if ( A \u0026lt; 3 ) return false; for ( let i=2; i \u0026lt; A; i++ ) if ( Number(a[i]) != Number(a[i-1]) + Number(a[i-2]) || ( a[i].length \u0026gt; 1 \u0026amp;\u0026amp; a[i].startsWith(\u0026#39;0\u0026#39;) ) || ( a[i-1].length \u0026gt; 1 \u0026amp;\u0026amp; a[i-1].startsWith(\u0026#39;0\u0026#39;) ) || ( a[i-2].length \u0026gt; 1 \u0026amp;\u0026amp; a[i-2].startsWith(\u0026#39;0\u0026#39;) ) ) return false; return true; }; let bt_search = ( i, cur = [] ) =\u0026gt; { if ( i \u0026gt; N ) return false; if ( i === N \u0026amp;\u0026amp; check(cur) ) return true; // num[i] starts a new number, explore path cur.push( num[i] ); let new_start = bt_search( i+1, cur ); if ( new_start ) return true; // backtrack, num[i] continues the previous number cur.pop(); if ( i \u0026gt; 0 ) { cur[ cur.length-1 ] += num[i]; let add_prev = bt_search( i+1, cur ); if ( add_prev ) return true; } return false; }; return bt_search( 0 ); }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_306_additive_number/","summary":"\u003cp\u003eHere\u0026rsquo;s my explanation for the \u003ca href=\"https://leetcode.com/problems/additive-number/description/\"\u003eleetcode 306: Additive Number problem\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"additive-number-problem\"\u003eAdditive Number Problem\u003c/h2\u003e\n\u003ch3 id=\"problem-recap\"\u003eProblem Recap\u003c/h3\u003e\n\u003cp\u003eAn \u003cstrong\u003eadditive number\u003c/strong\u003e is a string of digits where the sequence of numbers formed by splitting the string satisfies the condition that each number (after the first two) is the sum of the two preceding numbers.\u003c/p\u003e\n\u003ch4 id=\"examples\"\u003eExamples:\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026quot;112358\u0026quot;\u003c/code\u003e is additive because the sequence is \u003ccode\u003e1, 1, 2, 3, 5, 8\u003c/code\u003e, and:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e1 + 1 = 2\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e1 + 2 = 3\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e2 + 3 = 5\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e3 + 5 = 8\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026quot;199100199\u0026quot;\u003c/code\u003e is additive because the sequence is \u003ccode\u003e1, 99, 100, 199\u003c/code\u003e, and:\u003c/p\u003e","title":"Leetcode 306: Additive number"},{"content":"Here are all possible solutions I could come up with for the longest increasing subsequence problem. leetcode 300\nApproach 1: Generate all possible increasing subsequences We will keep track of a subsequence in an array named cur_subsequence or cur_sub. For each element (a[i]) we have the following 2 options:\nAdd the element to the end of current subsequence.\nNote: The current element can only be included if either the current subsequence is empty or the last element of the current subsequence is smaller than the current element. This is important to maintain the increasing subsequence property.\nIgnore the current element and explore without a[i]\nTime complexity: $$ O(2^N) $$ Space complexity: $$ O(N) $$ // recursion stack + auxilary array 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 var lengthOfLIS = function(a) { let A = a.length; // maximum length of a subsequence seen so far let max_len = 1; let bt_search = ( i, cur_sub = [] ) =\u0026gt; { if ( i \u0026gt;= A ) { max_len = Math.max( max_len, cur_sub.length ); return; } // either select the ith element, or ignore it. // a[i] can be taken when either subsequencee is empty or // last inserted element is smaller if ( !cur_sub.length || cur_sub[ cur_sub.length-1 ] \u0026lt; a[i] ) { cur_sub.push( a[i] ); bt_search( i+1, cur_sub ); cur_sub.pop(); // backtrack } // explore without a[i] included bt_search( i+1, cur_sub ); }; bt_search(0); return max_len; } Approach 2 (Version 1) : Generating all possible subsequences, but change the structure of the recursion to allow memoization Currently, we are keeping track of the current subsequence in an array cur_sub which makes it difficult for us to implement memoization. Notice that we only need previously selected element (to compare if current element is larger) and current length (to find the subsequence length). Hence, we will only use 3 variables: index, previous element index, current length.\nTime complexity: $$ O( N^2 ) $$ Space complexity: $$O( N^3 )$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 var lengthOfLIS = function(a) { /** Write a recurrence relation. Either you take the element @i or your ignore it. In either case, your pick the maximum length. generating all possible increasing subsequences, but not storing the subsequence and using only 3 variables. for each call(index, prev_selected, cur_length) we try to find the maximum length we can form by either selecting or rejecting a[i] This configuration is easy to memoize. **/ let A = a.length; let memo = new Map(); let bt_search = ( i, prev, cur_len = 0 ) =\u0026gt; { // inputs of the function are memoized by turning // them into a String `key` let key = JSON.stringify( [i, prev, cur_len] ); if (memo.has(key)) return memo.get(key); if ( i \u0026gt;= A ) return cur_len; let take = -1, not_take = -1; // a[i] can be taken if prev=null / cur_len=0 // or prev \u0026lt; a[i] if ( cur_len == 0 || prev \u0026lt; a[i] ) take = bt_search( i+1, a[i], cur_len+1 ); // backtrack. do not take a[i] not_take = bt_search( i+1, prev, cur_len ); let res = Math.max( take, not_take ); memo.set(key, res); return memo.get(key); }; return bt_search(0); } Approach 2 (Version 2): Yet another recursive solution, but with better memoization This solution memoizes using only: index of current element (i), index of previously selected element (prev_i).\nThe memoization is done in a matrix of size $$N$$X$$(N+1)$$.\nTime complexity: $$ O( N^2 ) $$ Space complexity: $$O( N^2 )$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 var lengthOfLIS = function(a) { /** Approach 2 (version 2): Instead of storing 3 variables, just store 2 variables. This will enable memoization table to be an NxN matrix. **/ let A = a.length; let memo = new Array( A ).fill(null).map( () =\u0026gt; new Array( A+1 ).fill( null ) ); let bt_search = ( i, prev_i = -1 ) =\u0026gt; { // y is remapped since prev_i is in range [-1,n-1] // but our array ranges is in range [0, n] let x = i, y = prev_i + 1; if ( i \u0026gt;= A ) return 0; if ( memo[x][y] !== null ) return memo[x][y]; let take = -1, not_take = -1; // a[i] can be taken if prev_i = -1 / cur_len=0 or // a[prev_i] \u0026lt; a[i] if ( prev_i == -1 || a[prev_i] \u0026lt; a[i] ) take = 1 + bt_search( i+1, i ); // backtrack. do not take a[i]. The length remains same not_take = bt_search( i+1, prev_i ); let res = Math.max( take, not_take ); memo[x][y] = res; return memo[x][y]; }; return bt_search(0); } Approach 3: Dynamic programming Declare a lis(longest increasing subsequence) array, where lis[i] denotes the length of longest increasing subsequence starting at i and ending at the end of the array. Fill this table from second last element towards first element.\nTo find lis[i] for an element a[i] use the following algorithm:\nFor each i \u0026lt;- n-2 - 0 // find if index i can form an increasing subsequence // with any element on the right of it max_len = 1 For each j \u0026lt;- i+1 - n if ( a[i] \u0026lt; a[j] ) // a[j] is a potential connection point max_len = MAX( max_len, 1 + lis[j] ) lis[i] = max_len The basic intuition behind it is, that we explore all elements to the right of a[i] which can connect with a[i] to form an increasing subsequence. The length of such a subsequence is given by:\n1 (length of a[i]) + length of longest subsequence from a[j] up until the end of the array\nwhich is same as: 1 + lcs[j]\nTime: $$O(n^2)$$ Space: $$O(n)$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 let MAX = Math.max; var lengthOfLIS = function(a) { /** Appraoch 3: Build the dp table manually using loops **/ let A = a.length; let lis = new Array( A ).fill(1); // global maximum, subsequence length from a[i] until end let gmax = 1; for ( let i = A-2; i \u0026gt;= 0; i-- ) { let max_len = 1; for ( let j = i+1; j \u0026lt; A; j++ ) { if ( a[i] \u0026lt; a[j] ) max_len = MAX( max_len, 1+lis[j] ); } lis[i] = max_len; gmax = MAX( max_len, gmax ); } return gmax; } Approach 4: Build an auxilary array, such that the minium elements are always at the end of it Here, we are basically trying to kick out large elements and inserting small elements whereever possible, so that new incoming elements feel welcome attaching themselves to the existing subsequence.\nBuild a auxilary array using the following algorithm:\nsubsequence = [] For each i \u0026lt;- 0 to A-1 if subsequence.last_element \u0026lt; a[i] subsequence.push( a[i] ) else { replace the largest element smaller than or equal to a[i] in subsequence using binary search. } the length of the subsequence is the length of the largest increasing subsequence. Time: $$O(n\\ log n)$$ // n for iteration, and for each iteration binary search O(log n) Space: $$O(n)$$ // auxilary array Note that the array that we actually build here does not represent a valid increasing subsequence. Nor is it the longest increasing subsequence, we just insert the elements using a particularly methodology which ensures its validity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 let MAX = Math.max; let FLOOR = Math.floor; var b_search = ( a, target ) =\u0026gt; { // return the index pf the number \u0026gt;= target let i = 0, j = a.length-1; while ( i \u0026lt;= j ) { let mid = i + FLOOR( (j-i)/2 ); if ( a[mid] == target ) return mid; else if ( a[mid] \u0026lt; target ) i = mid+1; else j = mid-1; } return i; }; var lengthOfLIS = function(a) { /** Approach 4: The idea is to keep the minium elements, such that validity of lis(longest increasing subsequence) for new incoming elements can be calculated quickly **/ let A = a.length; let sub = [ a[0] ]; for ( let i=1; i \u0026lt; A; i++ ) { let lst = sub.length-1; if ( sub[ lst ] \u0026lt; a[i] ) sub.push( a[i] ); else { // find a \u0026#34;write index\u0026#34; where we replace a[i] let wi = b_search( sub, a[i] ); sub[wi] = a[i]; } } return sub.length; } Approach 5: In place algorithm for approach 4 Time: $$O(n\\ logn)$$ Space: $$O(1)$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 let MAX = Math.max; let FLOOR = Math.floor; /* this version is for searching within the same array starting and ending position are requirede */ var b_search = ( a, start, end, target ) =\u0026gt; { // return the index pf the number \u0026gt;= target let i = start, j = end; while ( i \u0026lt;= j ) { let mid = i + FLOOR( (j-i)/2 ); if ( a[mid] == target ) return mid; else if ( a[mid] \u0026lt; target ) i = mid+1; else j = mid-1; } return i; }; var lengthOfLIS = function(a) { /*** Approach 5: Same as the above approach, but in place Hence saving auxilary space. The idea is to keep a variable to mark the end of the subsequence in a itself. **/ let A = a.length; let S = 1; // variable to mark the end of the subsequence for ( let i=1; i \u0026lt; A; i++ ) { if ( a[S-1] \u0026lt; a[i] ) { a[S] = a[i]; S++; } else { // find a \u0026#34;write index\u0026#34; where we replace a[i] let wi = b_search( a, 0, S-1, a[i] ); a[wi] = a[i]; } } return S; } ","permalink":"http://localhost:45763/personal_website/posts/all_possible_solutions_to_longest_increasing_subsequence_problem_leetcode_300/","summary":"\u003cp\u003eHere are all possible solutions I could come up with for the longest\nincreasing subsequence problem. \u003ca href=\"https://leetcode.com/problems/factorial-trailing-zeroes/description/\"\u003eleetcode\n300\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"approach-1-generate-all-possible-increasing-subsequences\"\u003eApproach 1: Generate all possible increasing subsequences\u003c/h1\u003e\n\u003cp\u003eWe will keep track of a subsequence in an array named \u003ccode\u003ecur_subsequence\u003c/code\u003e\nor \u003ccode\u003ecur_sub\u003c/code\u003e. For each element (\u003ccode\u003ea[i]\u003c/code\u003e)  we have the following 2\noptions:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eAdd the element to the end of current subsequence.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eNote: The current element can only be included if\neither the current subsequence is empty or the last\nelement of the current subsequence is smaller than\nthe current element. This is important to maintain\nthe increasing subsequence property.\u003c/em\u003e\u003c/p\u003e","title":"All possible solutions to longest increasing subsequence problem: leetcode 300"},{"content":"Problem link: leetcode 70: climbing stairs\nIntuition You need to climb n stairs, taking 1 or 2 stairs at a time.\nIf n = 2, you can climb like:\n$$1+1 = 2\\times (1) + 0 \\times(2)$$ $$2 = 0 \\times (1) + 1\\times(2) $$ if n = 3, you can climb like:\n$$1+1+1 = 3\\times(1) + 0\\times(2)$$ $$1+2 = 1\\times(1) + 1\\times(2)$$ $$2+1 = 1\\times(1) + 1\\times(2) $$ Basically you first need to decide how many steps of size 1 will you take and how many of size 2 do you need:\nHence, your first task is to solve the equation:\n$$ x \\times 1 + y \\times 2 = n $$\nTo decide the number of 1s and 2s. After you decide upon x and y then you will have calculate $$ \\frac{(x + y)!}{x! , y!} $$\nWhich is nothing but ways of chosing how exactly you will proceed. This is because we are trying to adjust x identical objects and y identical objects in x+y positions. Think of the number of ways you can arrange x men and y women in x + y positions.\nAs an example $$n=3, x=1 $$ and $$y=1$$\nThen you will have $$\\frac{(1 + 1)!}{1! , 1!} =2$$. see above, they are: $$ 1+2 \\ 2+1 $$\nApproach $$ y \\in [0, n/2] $$\nFor each , calculate the corresponding values of $$x$$ using the equation: $$ x \\times 1 + y \\times 2 = n \\ x = n - (2 \\times y ) $$\nthen calculate $$ \\frac{(x + y)!}{x! , y!} $$\nand add this to your counter variable.\nreturn counter.\nComplexity Time complexity: Time: O($$n^2$$)\nSpace: O(1)\nBut it can be reduced, if you can store calculated factorials. Hence, making the time complexity of calculating $$ \\frac{(x + y)!}{x! , y!} $$ -\u0026gt; O(1) and Space complexity O(n)\nTime complexity: O(n) Space complexity: O(n)\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 var permute = (x,y) =\u0026gt; { /* compute (x+y)! / x! y! without computing factorials */ /* which is basically computing x+y x+y-1 x+y-2 .. y+1 / x! */ var denom = 1; for (var i=1; i \u0026lt;= x; i++) denom *= i; var numi = 1; for (var i = y+1; i \u0026lt;= x+y; i++) numi *= i; return numi/denom; }; var climbStairs = function(n) { /* The number of ways in which we can get n by adding only 1 and 2 Let, 1x + 2y = n ---(1) then we need to find the number of integer solutions to this equation. that is S = {x,y | x,y in integers} we need to return |S| i.e. the number of elements in this solution set. from (1) it implies x = n - 2y ---(2) y in range [0,n/2] i.e. consequently x in range [0,n] hence, iterate over y from 0 to n/2 such that y is integer. we find the corrosponding solution using equation 2 */ let n_solutions = 0 ; for (var y=0; y \u0026lt;= Math.floor(n/2); y++ ) { var x = n - (2 * y); n_solutions += permute(x,y); } return (n_solutions); }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_70/","summary":"\u003cp\u003eProblem link: \u003ca href=\"https://leetcode.com/problems/climbing-stairs/description/\"\u003eleetcode 70: climbing stairs\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"intuition\"\u003eIntuition\u003c/h1\u003e\n\u003c!-- Describe your first thoughts on how to solve this problem. --\u003e\n\u003cp\u003eYou need to climb \u003ccode\u003en\u003c/code\u003e stairs, taking 1 or 2 stairs at a time.\u003c/p\u003e\n\u003cp\u003eIf n = 2, you can climb like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$$1+1 = 2\\times (1) + 0 \\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$2 = 0 \\times (1) + 1\\times(2) $$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eif n = 3, you can climb like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$$1+1+1 =  3\\times(1) + 0\\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$1+2   =  1\\times(1) + 1\\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$2+1   =  1\\times(1) + 1\\times(2) $$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBasically you first need to decide how many steps of size 1 will you take and how many of size 2 do you need:\u003c/p\u003e","title":"Leetcode 70: Climbing Stairs"},{"content":"Below is my C solution for the Leetcode problem candy.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 static inline void previous_kids_started_crying(int* kid, int continous_decrease_start, int continous_decrease_end, int* candy) { /* * To satisfy the condition that each child with higher rating than * it\u0026#39;s neighbors must get more candies. We give all children in range * [continous_decrease_start, continous_decrease_end] an extra candy * if the he has candies lower or equal to the kid after it. * * Note that we do not bother the kid before it, since it is known * that the kid before it has more rating than this kid */ if (continous_decrease_start == -1) { exit(1); } for (int i = continous_decrease_end; i \u0026gt;= continous_decrease_start; i--) { if (kid[i] \u0026lt;= kid[i+1]) { int before = kid[i]; kid[i]++; int after = kid[i]; *candy += after - before;; } else { /* chain is broken. We found a satisfied non protesting kid the kids before it must also be non-protesting */ return; } } } int candy(int* kid, int n) { /* * Few things to take care of: * * 1. At a time take a look at 2 children. i.e. iterate the children * in window of 2. * * 2. Each time a candy is given, check if previous child has more * rating, since he will start crying. He/she will protest that the * kid in front of him has less rating than him/her and still got * more/equal candies than him/her. It might even trigger a chain * where the kid previous to the previous kid might also see this * changed state, and if he had a rating more then the kid after him. * then he will also start asking more candies. And the kid behind * that and so on. * * The algorithm runs in linear time, however, if the children are * arranged in decreasing order of rating, then at each iteration all * previous children will start crying. Hence, everybofy needs to be * given more candies. In that case it becomes quadratic * * Space required is constant. * * Best case: * Time: O(n) * Space: O(1) * * Worst Case: * Time: O(n^2) * Space: O(1) */ int candies = 0; int continous_decrease_from = -1; /* First child gets a candy, but save his rating first */ int previous_child_rating = kid[0]; kid[0] = 1; candies++; for (int i = 1; i \u0026lt; n; i++) { if (kid[i] \u0026gt; previous_child_rating) { /* Since this child has more rating than the previous child, this child gets 1 more candy than previous child */ previous_child_rating = kid[i]; kid[i] = kid[i-1]+1; candies += kid[i]; continous_decrease_from = -1; } else if (kid[i] == previous_child_rating){ /* Since this child has equal rating than the previous child, give him 1 candy */ previous_child_rating = kid[i]; kid[i] = 1; candies++; continous_decrease_from = -1; } else { /* Previous child has more rating. Give this child one candy, and after giving : if the previous child had less candy, then we must initiate a chain reaction to do justice to all previous kids to previous children the problem here is that if this child has less rating then his predecessor then he will also start crying. And, the predecesor of this child also has more score then he will also start crying. Hence, we must give candies to them as well to maintain rule. Hence, check if the rule is disturbed, */ if (continous_decrease_from == -1) { /* A period of continous decrease started */ /* Hence, give this child 1 candy and if the previous child will also get 1 candy if he gets */ continous_decrease_from = i-1; previous_child_rating = kid[i]; kid[i] = 1; if (kid[i-1] \u0026gt; kid[i]) { candies ++; } else { kid[i-1] = kid[i] + 1; candies += 2; } } else { /* Give this child a candy, but mind the children behind this child */ previous_child_rating = kid[i]; kid[i] = 1; candies++; previous_kids_started_crying(kid, continous_decrease_from, i-1, \u0026amp;candies); } } } return candies; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_135/","summary":"\u003cp\u003eBelow is my C solution for the Leetcode problem \u003ca href=\"https://leetcode.com/problems/climbing-stairs/description/\"\u003ecandy\u003c/a\u003e.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e  1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 35\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 36\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 37\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 38\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 39\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 40\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 41\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 42\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 43\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 44\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 45\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 46\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 47\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 48\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 49\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 50\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 51\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 52\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 53\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 54\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 55\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 56\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 57\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 58\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 59\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 60\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 61\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 62\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 63\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 64\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 65\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 66\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 67\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 68\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 69\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 70\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 71\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 72\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 73\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 74\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 75\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 76\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 77\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 78\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 79\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 80\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 81\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 82\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 83\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 84\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 85\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 86\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 87\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 88\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 89\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 90\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 91\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 92\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 93\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 94\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 95\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 96\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 97\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 98\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 99\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e100\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e101\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e102\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e103\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e104\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e105\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e106\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e107\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e108\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e109\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e110\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e111\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e112\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e113\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e114\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e115\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e116\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e117\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e118\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e119\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e120\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e121\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e122\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e123\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e124\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e125\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e126\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e127\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e128\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e129\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e130\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e131\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e132\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e133\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e134\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kr\"\u003einline\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eprevious_kids_started_crying\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_end\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ecandy\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * To satisfy the condition that each child with higher rating than\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * it\u0026#39;s neighbors must get more candies. We give all children in range\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * [continous_decrease_start, continous_decrease_end] an extra candy\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * if the he has candies lower or equal to the kid after it.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Note that we do not bother the kid before it, since it is known\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * that the kid before it has more rating than this kid\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e        */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nf\"\u003eexit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_end\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ebefore\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eafter\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ecandy\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003eafter\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ebefore\u003c/span\u003e\u003cspan class=\"p\"\u003e;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* chain is broken. We found a satisfied non protesting kid\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                          the kids before it must also be non-protesting */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ecandy\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Few things to take care of:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * 1. At a time take a look at 2 children. i.e. iterate the children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * in window of 2.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * 2. Each time a candy is given, check if previous child has more\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * rating, since he will start crying. He/she will protest that the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * kid in front of him has less rating than him/her and still got\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * more/equal candies than him/her. It might even trigger a chain\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * where the kid previous to the previous kid might also see this\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * changed state, and if he had a rating more then the kid after him.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * then he will also start asking more candies. And the kid behind\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * that and so on.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * The algorithm runs in linear time, however, if the children are\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * arranged in decreasing order of rating, then at each iteration all\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * previous children will start crying. Hence, everybofy needs to be\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * given more candies. In that case it becomes quadratic\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space required is constant.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Best case:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Time: O(n)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space: O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Worst Case:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Time: O(n^2)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space: O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e         */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/* First child gets a candy, but save his rating first */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Since this child has more rating than the previous\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         child, this child gets 1 more candy than previous\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         child */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Since this child has equal rating than the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         previous child, give him 1 candy */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Previous child has more rating. Give this child one\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candy, and after giving : if the previous child had less\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candy, then we must initiate a chain reaction to do\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        justice to all previous kids to previous children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        the problem here is that if this child has less rating\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        then his predecessor then he will also start crying.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        And, the predecesor of this child also has more score\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        then he will also start crying. Hence, we must give\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candies to them as well to maintain rule. Hence, check\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        if the rule is disturbed,\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* A period of continous decrease started */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* Hence, give this child 1 candy and if the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                                   previous child will also get 1 candy if he gets  */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* Give this child a candy, but mind the children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                                  behind this child */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"nf\"\u003eprevious_kids_started_crying\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Leetcode 135: Candy"},{"content":"Introduction Linux is the kernel that powers the modern computing world. Its everywherefrom all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isnt about why Linux dominates the tech world; its about how I started contributing to the Linux Kerneland how you can too.\nHow Kernel Development Works Kernel development thrives on the Linux Kernel Mailing List (LKML), the nerve center of Linuxs open-source ecosystem. The beauty of open source? Anyone can contribute. Your task is to send patches (essentially the output of git diff refurbushed into an email).\nIf your patch solves a real problem or adds value, experienced developers will jump in with questions about your intent and rationale. Heres a pro tip: dont explain the how of your code; let the code speak for itself. Instead, focus on explaining why your change is needed.\nThe LKML community is incredibly supportive \u0026ndash; theyll critique your code, point out mistakes, and suggest improvements. Sure, it might feel overwhelming initially, but resources like the LFD103 course can guide you through the basics: generating patches, submitting them to LKML, compiling, and booting the kernel.\nFor me, just setting up my mail client and understanding LKML discussions took about a month. But once you clear these initial hurdles, things get easier. If youre struggling, feel free to check out my notesthey might save you some time.\nMy Background For years, kernel developers seemed like magicians to medoing impossibly cool things with computers. My fascination started after I stumbled upon a video of someone working on the kernel. It was mesmerizing!\nIn my second semester, I discovered the book The C Programming Language, and it sparked my love for C. The control C offers is unmatched, but it comes with its fair share of challengesbugs galore!\nSurprisingly, I wasnt a Linux user until recently. When I finally switched from Windows to Linux, everything just clicked. Concepts that once felt abstract suddenly made sense. On Windows, troubleshooting often felt like solving a mystery even Microsoft couldnt decode. On Linux, it felt like someone handed me the keys to the entire system.\nWhile working on kernel contributions, I read Linux Device Drivers, a book authored by seasoned kernel developers. It gave me a deeper understanding of the kernels inner workings. If youre serious about kernel development or writing drivers, this book is a must-read.\nWhat to Contribute The hardest part of contributing to the Linux Kernel is figuring out what to work on. The kernel is vasttheres everything from GPU drivers to network stack development.\nSince the kernels primary job is managing hardware, driver development is a hotspot of activity. New devices constantly hit the market, and they need drivers. If you have an electronics background and access to hardware, driver development is an excellent starting point.\nIf hardware isnt your thing (like in my case), here are some alternatives:\nkselftest: A testing framework for kernel functionality. Core subsystems: The backbone of the kernela great way to learn the essentials. syzbot reports: A kernel fuzzer that uncovers bugs by feeding the kernel random data. These reports are a goldmine for learning about common mistakes. Another beginner-friendly option is upgrading deprecated APIs. These updates are highly appreciated because they improve the kernels maintainability and security. Its not always a simple find-and-replaceyoull need to understand the codebut its a rewarding way to start.\nAnd dont underestimate fixing spelling and grammar errors in the documentation or comments. While it might sound trivial, its a fantastic way to learn the workflow: creating patches, submitting them, and receiving feedback. Tools like codespell can help you automate finding these errors.\nMy first-ever patch was a simple typo fix, but I made the classic rookie mistake of introducing two changes while documenting only one. Lesson learned!\nOnce you start contributing, youll notice issues everywhere. Even just following discussions on LKML can teach you a ton about how seasoned developers think and work.\nConclusion Kernel development might seem intimidating at first, but trust me, its worth the effort. Youll not only become a stronger developer but also gain a deep understanding of how computers work. Youll build expertise in both kernel and userspace development, and your Git skills will level up immenselya must-have for any programmer.\nThe learning opportunities in kernel development are unparalleled, often rivaling (or even exceeding) those at top tech companies. So if youre considering it, dont hesitatedive in! You might be surprised by how much youll grow.\nGood Luck!\nReferences ","permalink":"http://localhost:45763/personal_website/posts/highlights_from_linux_kernel_mentorship_program_2024/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux is the kernel that powers the modern computing world. Its everywherefrom all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isnt about \u003cem\u003ewhy\u003c/em\u003e Linux dominates the tech world; its about how I started contributing to the Linux Kerneland how you can too.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"how-kernel-development-works\"\u003eHow Kernel Development Works\u003c/h2\u003e\n\u003cp\u003eKernel development thrives on the Linux Kernel Mailing List (LKML), the\nnerve center of Linuxs open-source ecosystem. The beauty of open\nsource? Anyone can contribute. Your task is to send patches (essentially\nthe output of \u003ccode\u003egit diff\u003c/code\u003e refurbushed into an email).\u003c/p\u003e","title":"Highlights from Linux Kernel Mentorship Program 2024 by Abdul Rahim"},{"content":"Introduction Computer memory is usually implemented as a file system. While tampering with data is easy to detect, unauthorized access to memory is a more complex task falling within the domain of Intrusion Detection Systems (IDS). Most intrusion detection systems focus on analyzing network traffic or using machine learning techniques to identify suspicious patterns, we explore if we can employ merkel trees for this task.\nIf unauthorized memory access cannot be detected, users would never know that the system was compromised. Detecting tampered files is straightforward: you can hash the contents of a file, and if the hash changes you might conclude that the file changed. However, detecting memory access is more complicated. Although Linux keeps track of the last access timestamp, available via the stat command1, it only tracks file accesses that use the read() syscall2.\nMerkel Trees Merkle trees are a data structure in which hashes are stored rather than data. Leaf nodes store hashes of particular data blocks, while other nodes store hashes of their children. Merkle trees are widely used in blockchains for their ability to detect data tampering. They provide a robust mechanism to detect tampering in multiple distinct data items. If any data item in a leaf node changes, the whole tree becomes invalidated because it changes the hashes of all nodes up the tree.\nFig. 1: A Merkle tree is a data structure in which each node contains a hash. All non-leaf nodes contain hashes of their children, and all leaf nodes contain hashes of the underlying data.\nMerkel tree as directory tree Now, what we want to do is to augment the directory tree as a merkel tree. To be exact the inode structure (See inode doc for more details).\nDoing this would make us have hashes for children in directory tree. And the benefit of that is whenever the child inodes change, the current inode would change. And there\u0026rsquo;s 2 fields that each node would contain, the last seen hash (expected hash) of it\u0026rsquo;s child and the current hash of the same child. And when the current hash changes to a different value from expected hash, then we can imply that the child inode changed.\nBut one question is that if memory can be accessed bare metal, then the protections done in software doesn\u0026rsquo;t really make any sense. One possible solution to this problem is employing encryption.\nThe encryption should be performed in hardware, and the memory access system calls should define protocols for decrypting the underlying memory. The same system call would update necessary variables of the file in question, such as access time. The memory access system call needs to be implemented so that when one accesses memory, the data is decrypted and other functions are performed.\nBelow is a detailed description.\nArchitecture File system in most operating systems follow a hierarchical structure. We augment this with a Merkle tree, where a node is attached to each file in the file system. These nodes form a Merkle tree, where each node contains the hash of its children (in the case of non-leaf nodes) or the hash of the file data (in the case of files). Additionally, a pollution flag is attached to each node to detect illegal access.\nEach node will also has an expected hash, which is the hash of the node when the subtree below that node was last valid.\nWorking The pollution flag is set if expected_hash != hash, which occurs only on illegal access. I will explain this in a moment.\nWhen a user or process requests memory, it will go through the memory access system call, requiring authentication. Once the authentication is successful, the underlying data is decrypted and returned, the access time is updated, and all the hashes up to the root are updated along with the expected hash (note that the expected hash changes on authorized access). The tree remains valid.\nIf the authentication fails, the memory is not returned, but the access time changes. Consequently, when the tree is re-evaluated, the hash of this node changes since it incorporates the access time, but the expected hash remains the same, setting the pollution flag for this node.\nSince the parent of this node uses its hash, the parent\u0026rsquo;s hash also changes. However, its expected hash remains the same, leading to its invalidation. This process continues up the tree, invalidating the whole tree.\nThe benefit of this approach is that all other nodes remain valid. If one tries to determine which file was accessed and the timestamp, it is easy to identify the exact file by following the invalid nodes from top to bottom.\nRefrences stat man page\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nread syscall\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:45763/personal_website/posts/merkel_trees_and_computer_memory/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003c!-- mine\nComputer memory is usually implemented as a file system. While tampering\nof data is easy to detect, unauthorised access to memory is a more\ncomplex task. A problem that lies in the domain of Intrusion Detection\nSystems. While, most intrusion detection focus on analyzing network\ntraffic, or machine learning techniques to identify suspicious patterns.\nWe propose a method that works within the system, providing robust\naccess detection.\n--\u003e\n\u003cp\u003eComputer memory is usually implemented as a file system. While tampering\nwith data is easy to detect, unauthorized access to memory is a more\ncomplex task falling within the domain of Intrusion Detection Systems\n(IDS). Most intrusion detection systems focus on analyzing network traffic or\nusing machine learning techniques to identify suspicious patterns, we\nexplore if we can employ merkel trees for this task.\u003c/p\u003e","title":"Merkel Trees and computer memory"},{"content":"Introduction When you install vim, a usual requirement as with all text editors is the ability to copy to/from system clipboard so you can lets say, copy something into your vim session from firefox or vice versa, however copy pasting in terminal editors is not as straight forward as with GUI editors. In vim if you want to copy something into an auxilary space (anticipating it would be used later, so you can paste from this auxilary space) is achieved by registers.\nThe register that represents system clipboard is + register. Anything that you copy into this register is available in system clipboard.\nHow to use registers to copy/paste To copy a text into a register, select it in visual mode and press \u0026quot;\u0026lt;register_name\u0026gt;y to yank the contents into the given register. And to paste the contents of a particular register at current position, use \u0026quot;\u0026lt;register_name\u0026gt;p.\nTo use system clipboard, you just have to substitute \u0026ldquo;+\u0026rdquo; for register name in the above commands.\nclipboard support But the + register wont work unless you have clipboard support with your vim installation. By default there is no clipboard support in vim.\nTo check if your vim installation has clipboard support use:\n1 2 3 $ vim --version | grep clipboard +clipboard +keymap +printer +vertsplit +ex_extra +mouse_netterm +syntax +xterm_clipboard or inside of vim, you can run the command:\n1 :echo has(\u0026#39;clipboard\u0026#39;) If the output is 0, your installation doesnt have clipboard support.\nCompiling vim Now there are 2 solutions to this problem:\nEither install gvim: Or compile vim from sources with clipboard support Let\u0026rsquo;s see how each of them can be done.\nInstall gvim To install gvim run:\nOn Debian:\n1 sudo apt install vim-gtk On Fedora\n1 sudo dnf install gvim To compile vim with clipboard support Below are the simple steps:\nStep 1: Grab the sources Clone the repository:\n1 2 git clone https://github.com/vim/vim.git vim cd vim Step 2: Install dependencies Install the required libraries and tools to build vim, for example gcc, x11 etc. Note that you only need them to compile vim and you are free to delete them once you are done.\nOn Debian:\n1 sudo apt install build-essential libx11-dev libncurses5-dev On Fedora:\n1 2 3 4 sudo dnf groupinstall \u0026#34;Development Tools\u0026#34; sudo yum install gcc sudo yum groupinstall \u0026#34;X Software Development\u0026#34; sudo dnf install libX11-devel ncurses-devel Also, you need to remove the existing installation(if any).\nOn Debian\n1 sudo apt remove vim On Fedora\n1 sudo dnf remove vim gvim Step 3: Configure and Compile Configure vim with features of your choice\n1 2 3 4 5 6 7 ./configure \\\\ --enable-cscope \\\\ --enable-gui=auto \\\\ --enable-gtk2-check \\\\ --enable-gnome-check \\\\ --with-features=huge \\\\ --with-x Then compile and install with:\n1 2 make sudo make install Conclusion In this article we learned how can we compile vim with clipboard support, you can also tweak configuration according to your requirements. There are many configuration options available.\n","permalink":"http://localhost:45763/personal_website/posts/how_to_compile_vim_with_clipboard_support/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eWhen you install vim, a usual requirement as with all text editors is\nthe ability to copy to/from system clipboard so you can lets say, copy\nsomething into your vim session from firefox or vice versa, however copy\npasting in terminal editors is not as straight forward as with GUI\neditors. In vim if you want to copy something into an auxilary space\n(anticipating it would be used later, so you can paste from this\nauxilary space) is achieved by \u003cstrong\u003eregisters\u003c/strong\u003e.\u003c/p\u003e","title":"How to compile vim with clipboard support"},{"content":" Introduction I had an unused phone lying around for some time, and I began contemplating how I could repurpose it. This led me to reflect on the impressive performance of modern smartphones and consider whether they could be utilized as servers.\nSmartphones are equipped with ARM-based processors and run on Android, which is itself built on the Linux kernel. ARM processors are renowned for their energy efficiency1 and have recently found applications in the server space2.\nAs someone who enjoys exploring the full potential of devices, I embarked on a journey to discover how I could leverage the full potential of smartphones.\nSetup Although, you would like to run your programs on phones, but programming on phones typing on screen is a horrifying idea. Fortunately, you dont have to type on your phone, what you can do is you can access its terminal, using protocols like ssh/telnet etc.\nSo, firstly you would need a terminal to control a machine remotely. Unfortunately, there are not, alot of choices available in phone space when it comes to terminal emulators. Termux is one of the few available options.\nAfter you manage to open a terminal remotely, then from there its pretty frictionless. You can install the software of your choice and write, compile and run your programs. You might also find it helpful to root your phone for root privilages, which will help you run all commands. But please beware that rooting can null your warrenty, check with local expert. If termux does\u0026rsquo;nt work for you then there are also other options like kali net hunter.\nSo, in total, we need to install termux, then we would setup ssh.\nTermux Termux is an open source terminal emulator for android. In essence, it provides you with a linux environment, within android, The only difference between actual linux environment and termex is that it is not FHS(File System Hierarcy) compliant, i.e. it does not strictly follow linux file system conventions. The consequences of that are that #! /usr/bin/sh may not work, so you have to watch out the paths. Other than that, it supports almost all commands on linux.\nMoreover, It is an app that does\u0026rsquo;nt interfere with your system so you can run your android as normal, moreover it runs without root privilages. It comes with a large repository of software found at packages.termux.dev.\nBelow are the steps to setup ssh in termux Step 1: Download texmux on playstore, f-droid or from github releases\nStep 2: Update using pkg:\n1 2 pkg update # update the repositories pkg upgrade # upgrade all to latest versions Run this commands\nStep 3: Install ssh 1 pkg install ssh install ssh\nStep 4: Set a password Setup a password that you will use to login\n1 passwd set password and note username\nStep 5: Note your username You will require username and ip address when logging in using ssh, hence note them. Run the command whoami the know your username. This will generally start with \u0026ldquo;a0_\u0026rdquo;\n1 whoami Step 6: Note your IP address You can check your IP address in:\n1 2 3 settings \u0026gt; Wi-Fi \u0026gt; click on the (i) button, on the wifi you are connected to and Look for IPv4 address Step 7: Run ssh doemon in termux On your phone, run the ssh daemon using\n1 sshd Step 8: Login form your computer On your computer, use the following command to login into your phone and access its terminal\n1 ssh \u0026lt;user_name\u0026gt;@\u0026lt;IP_address\u0026gt; -p 8022 The username and IP address we already determined in step 5 and 6 resp. Note that it will promt you for password\nAftermath You can use scp command to transfer files between your computer and phone. In case you want to do development, there are a number of programming packages available in termux, you can find rust, nodejs, python, C/C++ and tools for many other programming languages.\nConclusion So, now you have successfully installed ssh in your android phone. You might find it useful to install vim, git, gcc etc. There is a large repository of packages in termux, which covers pretty much everything your would need.\nFurther Reads Simili, Emanuele, et al. \u0026ldquo;Power Efficiency in HEP (x86 vs. arm).\u0026rdquo; Power (W) 350.400 (2023): 450\u0026#160;\u0026#x21a9;\u0026#xfe0e;\narm_server\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:45763/personal_website/posts/how_to_turn_your_old_smartphone_into_a_home_server/","summary":"\u003c!--\n---\ndate: '2025-07-15T22:33:11+05:30'\ndate: ''\ntitle: 'How_to_turn_your_old_smartphone_into_a_home_server'\n---\n--\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eI had an unused phone lying around for some time, and I began\ncontemplating how I could repurpose it. This led me to reflect on the\nimpressive performance of modern smartphones and consider whether they\ncould be utilized as servers.\u003c/p\u003e\n\u003cp\u003eSmartphones are equipped with ARM-based processors and run on Android,\nwhich is itself built on the Linux kernel. ARM processors are renowned\nfor their energy efficiency\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e and have recently found\napplications in the server space\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e","title":"How to turn your old smartphone into a home server"},{"content":"We need to divide the array nums into k subsets such that the sum of each subset is same.\n$$ k \\times sum\\ of\\ each\\ subset = total\\ sum\\ sum\\ of\\ each\\ subset = total\\ sum\\ \\div k\\ target = total\\ sum\\ \\div k $$\nNow our task is to find all the k subsets in nums whose sum is target.\nMy idea is to structure this as multi-level recursion. We first try to find the $$k^{th}$$ subset, then $$(k-1)^{th}$$, then $$(k-2)^{th} \u0026hellip;$$ until there is only one subset left. The last subset will naturally sum to target. You can only go to $$(k-1)^{th}$$ level when you are able to successfully find $$k^{th}$$ level subset,\nFor example,\n1 2 3 4 5 6 7 .. .. find the 5th subset find the 4th subset find the 3rd subset find the 2nd subset return true Seeing the recursive structure.\n1 2 3 4 5 6 7 8 9 nums = [4,3,2,3,5,2,1] k=4 target = 20 / 4 = 5 suppose you find the 4th subset as: {3,2} from [4,3,2,3,5,2,1] Now your task reduces to finding 3 subsets in [4, ,3,4,2,1] that sum to target=5 recursive call: nums=[4, ,3,4,2,1] k=3 When finding the kth subset. You can simply use pick/not pick backtracking approach. It is important to understant the distinction between same level recursion (at any given k) which operates by deciding weather to pick/drop nums@i.\nAnd the k levels recursion which succeeds/fails by checking if we can form the $$k^{th}$$ subset.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution: def __init__(self): self.nums, self.target, self.used = None, None, None def canPartitionKSubsets(self, nums: List[int], k: int) -\u0026gt; bool: self.nums = nums total = sum(self.nums) self.target = total // k self.used = [False] * len(nums) if total % k != 0: return False self.nums.sort(reverse=True) return self.bt_search(0, k, 0) def bt_search(self, i: int, k: int, cur_sum: int) -\u0026gt; bool: if k == 1: # last subset is sure to sum upto target return True if i \u0026gt;= len(self.nums) or cur_sum \u0026gt; self.target: return False if cur_sum == self.target: # current subset found, return self.bt_search(0, k-1, 0) # explore the next level of k # try picking nums@i in current subset if not self.used[i] and cur_sum + self.nums[i] \u0026lt;= self.target: self.used[i] = True # explore in same level if self.bt_search(i+1, k, cur_sum + self.nums[i]): return True self.used[i] = False # on failure, skip duplicates of nums@i while i+1 \u0026lt; len(self.nums) and self.nums[i] == self.nums[i+1]: i += 1 # do not pick nums@i -\u0026gt; explore in same level return self.bt_search(i+1, k, cur_sum) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_698_partition_to_k_equal_sum_subsets/","summary":"\u003cp\u003eWe need to divide the array \u003ccode\u003enums\u003c/code\u003e into \u003ccode\u003ek\u003c/code\u003e subsets such that the sum of each subset is same.\u003c/p\u003e\n\u003cp\u003e$$\nk \\times sum\\ of\\ each\\ subset = total\\ sum\\\nsum\\ of\\ each\\ subset = total\\ sum\\ \\div k\\\ntarget = total\\ sum\\ \\div k\n$$\u003c/p\u003e\n\u003cp\u003eNow our task is to \u003cstrong\u003efind all the \u003ccode\u003ek\u003c/code\u003e subsets in nums whose sum is \u003ccode\u003etarget\u003c/code\u003e\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eMy idea is to structure this as multi-level recursion. We first try to find the $$k^{th}$$ subset, then $$(k-1)^{th}$$, then $$(k-2)^{th} \u0026hellip;$$ until there is only one subset left. The last subset will naturally sum to \u003ccode\u003etarget\u003c/code\u003e. You can only go to $$(k-1)^{th}$$ level when you are able to successfully find $$k^{th}$$ level subset,\u003c/p\u003e","title":"Leetcode 698: Partition into k equal sum subsets: The art of recursion: mastering double recursion in a single function"},{"content":"For each possible word, we ask the question: What possible queries can lead to this word?.\nFor example consider the word: abd. Below are the possible (prefix, suffix) queries that can return abd\n1 2 3 4 5 6 7 8 9 10 (prefix, suffix) a abd a bd a d ab abd ab bd ab d abd abd abd bd abd d Now, given word.length \u0026lt;= 7. Each word can at maximum generate 7*7=49 such pairs. Can we store all of them in a hashmap? Yes, because the total storage = 49 * number of words = O(n) Which is acceptable for this problem.\nWhat if there is already a value for (prefix,suffix) in current word. Shall we override it. We need the latest index right?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class WordFilter: def __init__(self, words: List[str]): self.map = {} for widx, w in enumerate(words): for i in range( len(w) ): prefix = w[:i+1] for j in range( len(w) ): suffix = w[j:] # for all possible prefix suffix queries that might route # to current word. We set it in dictionary overriding previously # inserted values to get the maximum index key = prefix + \u0026#39;|\u0026#39; + suffix self.map[key] = widx def f(self, pref: str, suff: str) -\u0026gt; int: key = pref + \u0026#39;|\u0026#39; + suff return self.map.get(key, -1) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_745_prefix_and_suffix_search_solution/","summary":"\u003cp\u003eFor each possible word, we ask the question: \u003cstrong\u003eWhat possible queries can lead to this word?\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor example consider the word: \u003ccode\u003eabd\u003c/code\u003e. Below are the possible (prefix, suffix) queries that can return \u003ccode\u003eabd\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(prefix, suffix)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    d\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  d\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  d\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eNow, given word.length \u0026lt;= 7. Each word can at maximum generate \u003ccode\u003e7*7=49\u003c/code\u003e such pairs. Can we store all of them in a hashmap? Yes, because the total storage = \u003ccode\u003e49 * number of words = O(n)\u003c/code\u003e Which is acceptable for this problem.\u003c/p\u003e","title":"Leetcode 745: prefix and suffix search solution"},{"content":"This problem is very similar to lc543, which is about finding the longest edge path in a tree. You can just copy over that code, and add 2 lines in it.\nHere we are doing the same thing as in lc543, however, when we encounter a non-matching child. We treat it as null.\nFor example, here the longest path at root node is highlighted below in red with 6 edges.\nOur algorithm views the tree like this. The longest path of 3 edges is highlighted in red.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int edges( struct TreeNode* node ); int longest_path; int longestUnivaluePath(struct TreeNode* root) { longest_path = 0; edges(root); return longest_path; } int edges( struct TreeNode* node ) { if ( !node ) return -1; int left = edges(node-\u0026gt;left), right = edges(node-\u0026gt;right); // treat child as null if it doesn\u0026#39;t match parent left = (node-\u0026gt;left \u0026amp;\u0026amp; node-\u0026gt;val == node-\u0026gt;left-\u0026gt;val) ? left : -1; right = (node-\u0026gt;right \u0026amp;\u0026amp; node-\u0026gt;val == node-\u0026gt;right-\u0026gt;val) ? right : -1; longest_path = fmax(longest_path, 1+left + 1+right); return 1 + fmax( left, right); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution: def __init__(self): self.ans = 0 def longestUnivaluePath(self, root: Optional[TreeNode]) -\u0026gt; int: self.edges( root ) return self.ans def edges(self, node: Optional[TreeNode]) -\u0026gt; int: if not node: return -1 left, right = self.edges( node.left ), self.edges( node.right ) # if the child is illegitimate. Discard it if not node.left or node.left.val != node.val: left = -1 # treat as null if not node.right or node.right.val != node.val: right = -1 self.ans = max( self.ans, ( 1+left ) + ( 1 + right ) ) return 1 + max( left, right ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function longestUnivaluePath(root: TreeNode | null): number { let ans = 0; const edges = ( node: TreeNode|null ): number =\u0026gt; { if ( !node ) return -1; let left = edges( node.left ), right = edges( node.right ); // if child value doesn\u0026#39;t match -\u0026gt; treat as null left = (node.left \u0026amp;\u0026amp; node.val == node.left.val) ? left : -1; right = (node.right \u0026amp;\u0026amp; node.val == node.right.val) ? right : -1; ans = Math.max( ans, (1 + left) + (1 + right) ); return 1 + Math.max( left, right ); } edges( root ); return ans; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function longestUnivaluePath(root) { let ans = 0; const edges = ( node ) =\u0026gt; { if ( !node ) return -1; let left = edges( node.left ), right = edges( node.right ); // if child value doesn\u0026#39;t match -\u0026gt; treat as null left = (node.left \u0026amp;\u0026amp; node.val == node.left.val) ? left : -1; right = (node.right \u0026amp;\u0026amp; node.val == node.right.val) ? right : -1; ans = Math.max( ans, (1 + left) + (1 + right) ); return 1 + Math.max( left, right ); } edges( root ); return ans; }; ","permalink":"http://localhost:45763/personal_website/posts/solution_to_leetcode_687_longest_univalue_path/","summary":"\u003cp\u003eThis problem is very similar to\n\u003ca href=\"https://leetcode.com/problems/diameter-of-binary-tree/solutions/6824338/solution-for-dummies-by-abdulrahim2002-yzrs/\"\u003elc543\u003c/a\u003e,\nwhich is about finding the longest edge path in a tree. You can just\ncopy over that code, and add 2 lines in it.\u003c/p\u003e\n\u003cp\u003eHere we are doing the same thing as in lc543, however, when we encounter a non-matching child. We treat it as null.\u003c/p\u003e\n\u003cp\u003eFor example, here the longest path at root node is highlighted below in red with 6 edges.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/148ffbfd-0ead-48cd-b45d-8c2575bafd11_1751999234.494938.png\"\u003e\u003c/p\u003e","title":"Solution to Leetcode 687: Longest Univalue Path"},{"content":"I keep track of the top k elements in sorted list. The kth largest element is the smallest of the top k elements.\ne.g. top k(=6) elements: [3,5,7,10,42,56] in sorted order. The kth largest element = 6th largest element = smallest element in above list.\nWhen I insert an element, I simply check if it can make it\u0026rsquo;s place among k largest elements already present in the list. Which it can, if it can defeat the smallest element in our list.\nFor example, we cannot add 2 in the array above since it fails to defeat 3.\nHowever, A number like 15 can be inserted. In which case, we remove the smallest element i.e. 3, to keep the list length=k\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class KthLargest: def __init__(self, k: int, nums: List[int]): self.scores = SortedList() self.limit = k for num in nums: self.add(num) def add(self, val: int) -\u0026gt; int: # if the current element can make space in top k elements if len(self.scores) \u0026lt; self.limit or self.scores[0] \u0026lt; val: self.scores.add(val) # remove smallest if len(self.scores) \u0026gt; self.limit: self.scores.pop(0) # return smallest return self.scores[0] ","permalink":"http://localhost:45763/personal_website/posts/leetcode_703_kth_largest_element_in_a_stream/","summary":"\u003cp\u003eI keep track of the top k elements in sorted list.\nThe kth largest element is the \u003cstrong\u003esmallest of the top k elements\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003ee.g. top k(=6) elements: \u003ccode\u003e[3,5,7,10,42,56]\u003c/code\u003e in sorted order.\nThe kth largest element = 6th largest element = smallest element in above list.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/070564ea-afa3-4108-92e6-7fa76c2fb981_1752504996.0140414.png\"\u003e\u003c/p\u003e\n\u003cp\u003eWhen I insert an element, I simply check if it can make it\u0026rsquo;s place among k largest elements already present in the list. Which it can, if it can defeat the smallest element in our list.\u003c/p\u003e","title":"Leetcode 703: kth largest element in a stream solution in python"},{"content":"When numbers from $$\\in$$ [0,n-1] are sorted in an array of size n. Their sorted position is equal to their index.\nSubset of numbers in array[i:j] can form a partition, if all elements in [i,j) are available in array[i:j].\nFor example [2,0,1] can form a partition, since they are at index 0, 1, 2 respectively. Sorted will involving swapping them at their correct position.\nThe basic idea behind this solution is that we try to identify such partitions, where all elements required to be sorted in [i, j] are available in current partition.\nHere\u0026rsquo;s the visualization of the algorithm, i points to the start of the group and j iterates through the group and checks if the current group needs to be expanded. e points to the end of the current group.\nSince, array[j]=1, we found a number greater than current boundaries. We need to expand the boundary. Hence, new group end is e = array[j].\nIncrement j. We find that array[1] = 0 which is \u0026lt; current end. Increment j again, j=2, Hence, no we exhaust the current group and we move forward to finding the next partition. Increase, current group ending, and reinitialize i=e/\nIn the second group, we have array[j]=2 and we are at index 2. Hence, we do not need to expand this group, since 2 is at right position.\nSimilarly we find the next 2 partitions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int maxChunksToSorted(int* arr, int arrSize) { int cur_gp_end = 0, cnt_gps = 0, i = 0; while ( i \u0026lt; arrSize ) { int j = i; // try to terminate the current group while ( j \u0026lt;= cur_gp_end ) { cur_gp_end = fmax( cur_gp_end, arr[j] ); j++; } i = ++cur_gp_end; cnt_gps++; } return cnt_gps; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_769_max_chunks_to_make_sorted/","summary":"\u003cp\u003eWhen numbers from $$\\in$$ \u003ccode\u003e[0,n-1]\u003c/code\u003e are sorted in an array of size n. Their sorted position is equal to their index.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/07a3b1d2-9478-486f-9f62-3a67e6dde1b3_1752513551.205261.png\"\u003e\u003c/p\u003e\n\u003cp\u003eSubset of numbers in \u003ccode\u003earray[i:j]\u003c/code\u003e can form a partition, if all elements in \u003ccode\u003e[i,j)\u003c/code\u003e are available in \u003ccode\u003earray[i:j]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFor example \u003ccode\u003e[2,0,1]\u003c/code\u003e can form a partition, since they are at index \u003ccode\u003e0, 1, 2\u003c/code\u003e respectively. Sorted will involving swapping them at their correct position.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/77d9235f-d72a-416a-bd77-d8802d7567b0_1752513786.651974.png\"\u003e\u003c/p\u003e\n\u003cp\u003eThe basic idea behind this solution is that we try to identify such partitions, where all elements required to be sorted in \u003ccode\u003e[i, j]\u003c/code\u003e are available in current partition.\u003c/p\u003e","title":"Leetcode 769: Max chunks to make sorted solution"},{"content":"For each word, we basically store all versions of it after removal of 1 character. For example,\n1 2 3 4 5 6 hello -\u0026gt; ello -\u0026gt; removed h@0 hllo -\u0026gt; removed e@1 helo -\u0026gt; removed l@2 helo -\u0026gt; removed l@3 hell -\u0026gt; removed o@4 We can store: wordAfterRemoval,indexOfRemoval in hashmap. So whenever we search for a word like: hexlo then we can try removing it\u0026rsquo;s 2nd index and search: helo,2 in the map, which we will find.\nIn the value we can store the removed character. For example, store key=helo,2 with value=l to indicate that l was removed.\nSo when you match a word like hexlo. Try to search helo,2 in the hashmap. It gives value=l which is !='x' i.e. the removed character in hexlo.\nHowever, there is one problem with this approach. When you add 2 words like: hello and hallo in the map. Then hllo,1 will give e in the first insertion and a in the second. The second overides the first so hello is forgetten by the structure. To avoid this issue, we store both of them (e, a) in a list.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class MagicDictionary { private map = new Map\u0026lt;string,string[]\u0026gt;(); buildDict(dictionary: string[]): void { for ( const word of dictionary ) { for ( let i=0; i \u0026lt; word.length; i++ ) { const wordAfterRemoval = word.slice(0, i) + word.slice(i+1); // key stores wordAfterRemoval,indexOfRemoval as value const key = `${wordAfterRemoval},${i}`; if ( !this.map.has(key) ) this.map.set(key,[]); // values have the removed character this.map.get(key).push( word[i] ) } } } search(word: string): boolean { for ( let i=0; i \u0026lt; word.length; i++ ) { const wordAfterRemoval = word.slice(0, i) + word.slice(i+1); const key = `${wordAfterRemoval},${i}`; if ( !this.map.has(key) ) continue; const removedChars = this.map.get(key); // If there was a word with removed character != word[i] for ( let j=0; j \u0026lt; removedChars.length; j++ ) { if ( removedChars[j] !== word[i] ) return true; } } return false; } } You can also embed the index information by replacing the removed word with _ like in this pyton version:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class MagicDictionary: def __init__(self): self.map = {} def buildDict(self, dictionary: List[str]) -\u0026gt; None: for word in dictionary: for i in range(len(word)): key = word[0:i] + \u0026#39;_\u0026#39; + word[i+1:] if not key in self.map: self.map[key] = [] self.map[key].append(word[i]) def search(self, searchWord: str) -\u0026gt; bool: for i in range(len(searchWord)): key = searchWord[0:i] + \u0026#39;_\u0026#39; + searchWord[i+1:] if key not in self.map: continue for c in self.map[key]: if c != searchWord[i]: return True return False # Your MagicDictionary object will be instantiated and called as such: # obj = MagicDictionary() # obj.buildDict(dictionary) # param_2 = obj.search(searchWord) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_676_magic_dictionary/","summary":"\u003cp\u003eFor each word, we basically store all versions of it after removal of 1 character. For example,\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehello -\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eello -\u0026gt; removed h@0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehllo -\u0026gt; removed e@1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehelo -\u0026gt; removed l@2\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehelo -\u0026gt; removed l@3\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehell -\u0026gt; removed o@4\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eWe can store: \u003ccode\u003ewordAfterRemoval,indexOfRemoval\u003c/code\u003e in hashmap. So whenever we search for a word like: \u003ccode\u003ehexlo\u003c/code\u003e then we can try removing it\u0026rsquo;s 2nd index and search: \u003ccode\u003ehelo,2\u003c/code\u003e in the map, which we will find.\u003c/p\u003e","title":"Leetcode 676: magic dictionary"},{"content":"consider the word \u0026ldquo;catsdogcats\u0026rdquo;. We have the dictionary: [\u0026quot;cat\u0026quot;,\u0026quot;cats\u0026quot;,\u0026quot;catsdogcats\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;dogcatsdog\u0026quot;,\u0026quot;hippopotamuses\u0026quot;,\u0026quot;rat\u0026quot;,\u0026quot;ratcatdogcat\u0026quot;]\nWe iterate over the word: catsdogcats and at each iteration, we ask if the prefix is contained in dictionary.\nIf the prefix is in the dictionary, we recursively call the function on the remaining word (excluding matched prefix)\nis c in dictionary ? is ca in dictionary ? is cat in dictionary ? -\u0026gt; YES call( sdogcats ) \u0026ndash;[1] Prefix cat matched so recursively call with sdogcats\nis s in dictionary ? is sd in dictionary ? \u0026hellip;. is sdogcats in dictionary ? NO We exhausted the word so we return false. Nothing was matched\nBack at the first call, this time we try to match cats Return to [1]\nis cats in dictionary -\u0026gt; YES recursively call on dogcats\nis d in dictionary ?\nis do in dictionary ?\nis dog in dictionary ? -\u0026gt; YES, recursively call on cats\nis c in dictionary ?\nis ca in dictionary ?\nis cat in dictionary ? YES , recursively call(s) \u0026ndash;[2]\nis s in dictionary ? NO -\u0026gt; word exhausted, return false;\nBack at recursive call [2]\nis cats in dictionary ? YES recursively call(``) i.e. empty string When we reach empty string, it means whole of string can be constructed using words in dictionary. Hence return true.\nImport considerations:\nThe dictionary has all the words, which means that catsdogcats will match with itself completely. To avoid words matching with themselves, we tell the function to ignore the catsdogcats word to avoid matching it with itself. Also, we can memoize the results since, dictionary remains the same, only target word and ignore word changes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function findAllConcatenatedWordsInADict(words: string[]): string[] { const dict = new Set\u0026lt;string\u0026gt;( words ); return words.filter( curWord =\u0026gt; canChunk( curWord, curWord, dict ) ); }; function canChunk( target: string, ignore: string, dict: Set\u0026lt;string\u0026gt;, memo = new Map\u0026lt;string, boolean\u0026gt;() ): boolean { if ( !target.length ) return true; const key = target + ignore; if ( memo.has( key ) ) return memo.get( key ); for ( let i=1; i \u0026lt;= target.length; i++ ) { const prefix = target.slice( 0, i ); if ( prefix !== ignore \u0026amp;\u0026amp; dict.has( prefix ) \u0026amp;\u0026amp; canChunk( target.slice( i ), ignore, dict, memo ) ) { memo.set( key, true ); return true; } } memo.set( key, false ); return false; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_472_concatenated_words/","summary":"\u003cp\u003econsider the word \u0026ldquo;catsdogcats\u0026rdquo;. We have the dictionary: \u003ccode\u003e[\u0026quot;cat\u0026quot;,\u0026quot;cats\u0026quot;,\u0026quot;catsdogcats\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;dogcatsdog\u0026quot;,\u0026quot;hippopotamuses\u0026quot;,\u0026quot;rat\u0026quot;,\u0026quot;ratcatdogcat\u0026quot;]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWe iterate over the word: \u003ccode\u003ecatsdogcats\u003c/code\u003e and at each iteration, we ask if the prefix is contained in dictionary.\u003c/p\u003e\n\u003cp\u003eIf the prefix is in the dictionary, we recursively call the function on the remaining word (excluding matched prefix)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eis \u003ccode\u003ec\u003c/code\u003e in dictionary ?\u003c/li\u003e\n\u003cli\u003eis \u003ccode\u003eca\u003c/code\u003e in dictionary ?\u003c/li\u003e\n\u003cli\u003eis \u003ccode\u003ecat\u003c/code\u003e in dictionary ? -\u0026gt; YES       call( \u003ccode\u003esdogcats\u003c/code\u003e ) \u0026ndash;[1]\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePrefix \u003ccode\u003ecat\u003c/code\u003e matched so recursively call with \u003ccode\u003esdogcats\u003c/code\u003e\u003c/p\u003e","title":"Leetcode 472: Concatenated words"},{"content":"The task is to find a subarray with sum of elements = k\nTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\nThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\n$$ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k] $$\nNow we are looking for sub of subarray = T(target). Therefore:\n$$ sum\\ of\\ subarray = prefix\\ [j]\\ -\\ prefix\\ [i-1] = T\\ \\ prefix\\ [i-1] = prefix\\ [j]\\ - T $$\nTherefore, we iterate the prefix array. And at each prefix[j], we search for a previously inserted prefix[i-1] such that prefix[i-1] = prefix[j] - T. We also need the count of such subarrays. At a particular j the number of subarrays where sum=T is the number of i that occured previously such that prefix[i-1] = prefix[j] - T. Index j will form a subarray with each of such previous i\u0026rsquo;s.\nWe must store the mapping: ( prefix[x], count ) in a map.\nSo far so good. But what happens when $$i=0$$. In this case, sum of subarray between indices [0, j] is defined as:\n$$ prefix\\ [j] = \\sum_{k=0}^j nums\\ [k] = T $$\nAt each index j, the code will try to look for prefix[j] - T in the map. When prefix[j]=T itself, then it would look for T-T=0 into the map. Therefore we must keep prefix= 0, count= 1 into the map to account for subarrays starting at index 0.\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 function subarraySum(nums: number[], k: number): number { const map = new Map\u0026lt;number, number\u0026gt;([ [0, 1] ]); let sumk = 0; for ( let j=0; j \u0026lt; nums.length; j++ ) { nums[j] = ( j==0 ) ? nums[j] : nums[j-1] + nums[j]; sumk += map.get( nums[j] - k ) ?? 0; map.set( nums[j], ( map.get(nums[j]) ?? 0 ) + 1 ); } return sumk; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_560_subarray_sub_equal_k_solution/","summary":"\u003cp\u003eThe task is to find a subarray with \u003ccode\u003esum of elements = k\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\u003c/p\u003e\n\u003cp\u003eThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\u003c/p\u003e\n\u003cp\u003e$$\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k]\n$$\u003c/p\u003e","title":"Leetcode 560: Subarray sum equals k"},{"content":"Consider the array: [0,1,1,0,0,1,1,0,1,1] The idea is to turn the 0\u0026rsquo;s into -1\u0026rsquo;s\narray: [-1,1,1,-1,-1,1,1,-1,1,1]\nNow, the task is to find a subarray with sum of elements = 0\nTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\nThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\n$$ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k] $$\nAnd the length of the subarray between indices $$[i,j]$$ is defined as: $$length(i,j) = j-i+1 = j-(i-1) $$\nNow we are looking for sub of subarray = 0. Therefore:\n$$ sum\\ of\\ subarray = prefix\\ [j]\\ -\\ prefix\\ [i-1] = 0\\ prefix\\ [j]\\ =\\ prefix\\ [i-1] $$\nTherefore, we iterate the prefix array. And at each prefix[j], we search for a previously inserted prefix[i-1] such that prefix[j]=prefix[i-1]. We record the length of the current subarray as: length = j-(i-1).\nWe must store the mapping: ( prefix[k], k ) in a map to achieve this.\nSo far so good. But what happens when $$i=0$$. In this case, sum of subarray between indices [0, j] is defined as:\n$$ prefiix\\ [j] = \\sum_{k=0}^j nums\\ [k] $$\nAnd the length of the subarray [0,j] is: $$j+1 = j-(-1)$$\nTherefore we keep a superficial (prefix = 0, index = -1) in the map.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function findMaxLength(nums: number[]): number { const map = new Map\u0026lt;number, number\u0026gt;( [ [0, -1], ] ); let maxLen = 0; for ( let j=0; j \u0026lt; nums.length; j++ ) { let cur = ( nums[j] == 1 ) ? 1 : -1; nums[j] = ( j==0 ) ? cur : cur + nums[j-1]; // prefix sum occured previously at i. Length = j-i if ( map.has( nums[j] ) ) { let i = map.get( nums[j] ); maxLen = Math.max( maxLen, j - i ); } // put the current prefix sum into map if ( !map.has( nums[j] ) ) map.set( nums[j], j ); } return maxLen; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_525_contiguous_array/","summary":"\u003cp\u003eConsider the array: \u003ccode\u003e[0,1,1,0,0,1,1,0,1,1] \u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe idea is to turn the 0\u0026rsquo;s into -1\u0026rsquo;s\u003c/p\u003e\n\u003cp\u003earray: \u003ccode\u003e[-1,1,1,-1,-1,1,1,-1,1,1]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eNow, the task is to find a subarray with \u003ccode\u003esum of elements = 0\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\u003c/p\u003e\n\u003cp\u003eThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\u003c/p\u003e\n\u003cp\u003e$$\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k]\n$$\u003c/p\u003e","title":"Leetcode_525_contiguous_array"},{"content":"The idea is to keep 2 pointers. trail pointer and cur pointer. The list is build in recursive function build(trail, cur) which returns last node of the list we build.\nbuild works as follows:\nwhen there is no child node: simply connect trail and cur and advance both when there is a child node, then recursively call itself with build( trail = cur, cur = cur.child ). The call would connect cur node with the list in the next level. It would return the last node in next level. Then we assign trail = last node in next level and cur = cur.next in current level. This ensures that the next iteration would connect last node in next level to next node in current level. when cur becomes null trail is the last node in current level. return trail Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function flatten(head: _Node | null): _Node | null { const save: _Node = new _Node( -1 ); build( save, head ); if ( save.next ) save.next.prev = null; return save.next; }; function build( trail: _Node | null, cur: _Node | null ): _Node | null { while ( cur ) { if ( !cur.child ) { trail.next = cur; cur.prev = trail; trail = trail.next; cur = cur.next; } else { trail.next = cur; cur.prev = trail; const saveNext = cur.next; const lastNodeFromChildList = build( cur, cur.child ); cur.child = null; cur = saveNext; trail = lastNodeFromChildList; } } return trail; } Complexity Time complexity: $$O(n)$$\nSpace complexity: $$O(n)$$ {recursion stack}\n","permalink":"http://localhost:45763/personal_website/posts/leetcode_430_flattening_multilevel_linked_list/","summary":"\u003cp\u003eThe idea is to keep 2 pointers. \u003ccode\u003etrail\u003c/code\u003e pointer and \u003ccode\u003ecur\u003c/code\u003e pointer. The\nlist is build in recursive function \u003ccode\u003ebuild(trail, cur)\u003c/code\u003e which returns\nlast node of the list we build.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebuild\u003c/code\u003e works as follows:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ewhen there is no \u003ccode\u003echild\u003c/code\u003e node: simply connect \u003ccode\u003etrail\u003c/code\u003e and \u003ccode\u003ecur\u003c/code\u003e and advance both\u003c/li\u003e\n\u003cli\u003ewhen there is a \u003ccode\u003echild\u003c/code\u003e node, then recursively call itself with \u003ccode\u003ebuild( trail = cur, cur = cur.child )\u003c/code\u003e. The call would connect \u003ccode\u003ecur\u003c/code\u003e node with the \u003ccode\u003elist in the next level\u003c/code\u003e. It would return the last node in next level. Then we assign \u003ccode\u003etrail = last node in next level\u003c/code\u003e and \u003ccode\u003ecur = cur.next in current level\u003c/code\u003e. This ensures that the next iteration would connect \u003ccode\u003elast node in next level\u003c/code\u003e to \u003ccode\u003enext node in current level\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003ewhen \u003ccode\u003ecur\u003c/code\u003e becomes \u003ccode\u003enull\u003c/code\u003e \u003ccode\u003etrail\u003c/code\u003e is the last node in current level. \u003ccode\u003ereturn trail\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"code\"\u003eCode\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003eflatten\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ehead\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kr\"\u003econst\u003c/span\u003e   \u003cspan class=\"nx\"\u003esave\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ehead\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003esaveNext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003elastNodeFromChildList\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003esaveNext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003elastNodeFromChildList\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"complexity\"\u003eComplexity\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTime complexity:  $$O(n)$$\u003c/p\u003e","title":"Leetcode 430: Flattening a multilevel linked list"},{"content":"Below is my solution for the leetcode 154: Find minimum in rotated sorted array problem\nIntuition Fact is, that you cannot solve this question in O(log n) time. The reason is because of duplicates.\nConsider a situation like:\n$$ [2,2,2,2,1,2,2] $$\nwhere mid is at 3 and the minium number here is clearly $$1$$. But our binary search algorithm will not be able to figure out in which direction it should go, since starting, ending and middle values are all same. In this case the best we can do is increment mid which makes the worst running time: O(n)\nHowever, it is possible to solve this problem in O(n/2) as explain below.\nApproach We will make use of the fact that a sorted array follows the (min) heap property i.e. in a sorted array, at all parent nodes are smaller than their children.\nAnd if this sorted array is rotated, then the place at which the first violation occurs is the subtree where the answer will be found.\nComplexity Time complexity: $$O(n/2)$$ Space complexity: $$O(1)$$ Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 var findMin = function(a) { /** Approach: You cannot solve this problem in O(log n) since it contains duplicate values. But you can actually solve this problem in O(n/2) by using the fact that a sorted array follows heap property. And if a sorted array is rotated then the heap property no longer holds. to find the minium element traverse the array, and find the first subtree where the heap property does not hold. the minium of the 2 values where the heap property does not satisfy is also minium in the array. Time: O(n/2) Space: O(1) */ let A = a.length; let i = 0; while ( i \u0026lt;= Math.floor(A/2)-1 ) { let root = i; let lc = 2*i + 1; let rc = 2*i + 2; let smallest = root; if ( lc \u0026lt; A \u0026amp;\u0026amp; a[lc] \u0026lt; a[smallest] ) smallest = lc; if ( rc \u0026lt; A \u0026amp;\u0026amp; a[rc] \u0026lt; a[smallest] ) smallest = rc; if ( smallest != root ) /* violation found. the value at smallest is minium */ return a[smallest]; i++; } /* no violation found. Either the array is sorted ar there it is all duplicates, in either case, return the first element. */ return a[0]; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_154_find_minimum_in_rotated_sorted_array/","summary":"\u003cp\u003eBelow is my solution for the \u003ca href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/\"\u003eleetcode 154: Find minimum in rotated\nsorted array problem\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"intuition\"\u003eIntuition\u003c/h1\u003e\n\u003c!-- Describe your first thoughts on how to solve this problem. --\u003e\n\u003cp\u003eFact is, that you \u003cstrong\u003ecannot\u003c/strong\u003e solve this question in \u003cstrong\u003eO(log n)\u003c/strong\u003e time. The reason is because of duplicates.\u003c/p\u003e\n\u003cp\u003eConsider a situation like:\u003c/p\u003e\n\u003cp\u003e$$\n[2,2,2,2,1,2,2]\n$$\u003c/p\u003e\n\u003cp\u003ewhere mid is at 3 and the minium number here is clearly $$1$$. But our binary search algorithm will not be able to figure out in which direction it should go, since starting, ending and middle values are all same. In this case the best we can do is increment mid which makes the worst running time: \u003cstrong\u003eO(n)\u003c/strong\u003e\u003c/p\u003e","title":"Leetcode 154: Find minimum in rotated sorted array"},{"content":"Here\u0026rsquo;s my solution to the Leetcode 315: Count of Smaller Numbers After Self problem using standard merge sort. I just change one line to count while merge procedure.\nSolution Let\u0026rsquo;s build the solution step by step.\nInput: nums = $$[5,2,6,1]$$\nFirst, turn the numbers into [number, index] tuple. So it looks like:\narray = $$ [ [ 5, 0 ], [ 2, 1 ], [ 6, 2 ], [ 1, 3 ] ] $$\nSecond, just write standard merge sort algorithm and sort the array in ascending order by first values.\nThe output is: $$ [ [ 1, 3 ], [ 2, 1 ], [ 5, 0 ], [ 6, 2 ] ] $$\nHere\u0026rsquo;s the trace of the algorithm:\nSimple merge sort implemented 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { tmp.push( a[j] ); j++; } else { tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); merge_sort( array, 0, array.length-1 ); }; So far so good.\nNow let\u0026rsquo;s get back to the question. The question is asking: For each index $$i$$, count all numbers at index $$j$$ such that $$i \u0026lt; j$$ and $$a[i] \u0026gt; a[j]$$. Or, simply put: for each number, find all numbers that appear after it and are smaller than it.\nNow, look at the visualization again, pay attention to the merge procedure (in magenta colour) and observe the following:\nat each merge procedure, we merge 2 consecutive partitions. all numbers in the left partition appear before numbers in right partition in the original array. The partitions are sorted in increasing order. Now, suppose we are merging 2 partitions where, the pointer of left partition is at $$x$$ and pointer of right partition is at $$y$$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [....a,b,c, x ,d,e,f....] [...h,i,j, y, k,l,m....] ^ ^ i j Suppose x \u0026gt; y It follows from observation 2 that: y is one of the numbers that appear to the right of x and is smaller than x ---(1) Also, since partitions are sorted (observation 3): d, e, f .... (i.e. all number that appear to the right of x) are greater than x. ----(2) From (1) and (2) we can conclude that: x, d, e, f, ... (i.e. all numbers to the right of x including x) appear before y. And y is smaller than all these numbers. Hence, required condition satisfied! Now, we just need a counter for each variable, and whenever the condition same as above occurs, we increment the counter for each x,d,e,\u0026hellip;\n1 2 3 4 5 6 7 [....a,b,c, x ,d,e,f....] [...h,i,j, y, k,l,m....] ^ ^ i j while merging: if x \u0026gt; y increment the counters of x, d, e, f, ... Single line changed in standard merge sort algorithm We can use the index at the second position to access the counter of that particular number.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 let counts; const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { /* ____(x \u0026gt; y) so increment counters of x,d,e,...____*/ for ( let p=i; p\u0026lt;=mid; p++ ) counts[ a[p][1] ]++; /*_______________INSERT THIS LINE_____________________*/ tmp.push( a[j] ); j++; } else { tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); counts = new Array(nums.length).fill(0); merge_sort( array, 0, array.length-1 ); return counts; }; That is the whole idea behind this question. Now the above implementation won\u0026rsquo;t work because at each iteration, we are updating whole left partition after i. Making it O(n^2) Optimize To avoid updating the whole partition, we keep a running counter cnt.\nFinal implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 let counts; const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; let cnt = 0; // keep running counter while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { cnt++; // increment counter tmp.push( a[j] ); j++; } else { counts[ a[i][1] ] += cnt; // no more numbers that are // smaller than i tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { counts[ a[i][1] ] += cnt; // if left partition is not over // update left over number counts tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); counts = nums; counts.fill(0); merge_sort( array, 0, array.length-1 ); return counts; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def countSmaller(nums): counts = [0] * len(nums) array = [(num, i) for i, num in enumerate(nums)] def merge_sort(start, end): if start == end: return mid = (start + end) // 2 merge_sort(start, mid) merge_sort(mid + 1, end) merge(start, mid, end) def merge(start, mid, end): temp = [] i, j = start, mid + 1 cnt = 0 while i \u0026lt;= mid and j \u0026lt;= end: if array[i][0] \u0026gt; array[j][0]: cnt += 1 temp.append(array[j]) j += 1 else: counts[array[i][1]] += cnt temp.append(array[i]) i += 1 while i \u0026lt;= mid: counts[array[i][1]] += cnt temp.append(array[i]) i += 1 while j \u0026lt;= end: temp.append(array[j]) j += 1 for i in range(len(temp)): array[start + i] = temp[i] merge_sort(0, len(nums) - 1) return counts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; countSmaller(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; counts(nums.size(), 0); vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; array; for (int i = 0; i \u0026lt; nums.size(); i++) { array.emplace_back(nums[i], i); } function\u0026lt;void(int, int)\u0026gt; merge_sort = [\u0026amp;](int start, int end) { if (start == end) return; int mid = start + (end - start) / 2; merge_sort(start, mid); merge_sort(mid + 1, end); merge(start, mid, end); }; function\u0026lt;void(int, int, int)\u0026gt; merge = [\u0026amp;](int start, int mid, int end) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; temp; int i = start, j = mid + 1; int cnt = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end) { if (array[i].first \u0026gt; array[j].first) { cnt++; temp.push_back(array[j]); j++; } else { counts[array[i].second] += cnt; temp.push_back(array[i]); i++; } } while (i \u0026lt;= mid) { counts[array[i].second] += cnt; temp.push_back(array[i]); i++; } while (j \u0026lt;= end) { temp.push_back(array[j]); j++; } for (int k = 0; k \u0026lt; temp.size(); k++) { array[start + k] = temp[k]; } }; merge_sort(0, nums.size() - 1); return counts; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import java.util.*; class Solution { private int[] counts; private int[][] array; public List\u0026lt;Integer\u0026gt; countSmaller(int[] nums) { counts = new int[nums.length]; array = new int[nums.length][2]; for (int i = 0; i \u0026lt; nums.length; i++) { array[i][0] = nums[i]; array[i][1] = i; } mergeSort(0, nums.length - 1); List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (int count : counts) { result.add(count); } return result; } private void mergeSort(int start, int end) { if (start == end) return; int mid = start + (end - start) / 2; mergeSort(start, mid); mergeSort(mid + 1, end); merge(start, mid, end); } private void merge(int start, int mid, int end) { List\u0026lt;int[]\u0026gt; temp = new ArrayList\u0026lt;\u0026gt;(); int i = start, j = mid + 1; int cnt = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end) { if (array[i][0] \u0026gt; array[j][0]) { cnt++; temp.add(array[j]); j++; } else { counts[array[i][1]] += cnt; temp.add(array[i]); i++; } } while (i \u0026lt;= mid) { counts[array[i][1]] += cnt; temp.add(array[i]); i++; } while (j \u0026lt;= end) { temp.add(array[j]); j++; } for (int k = 0; k \u0026lt; temp.size(); k++) { array[start + k] = temp.get(k); } } } Time: $$O(n\\ log\\ n)$$ Space: $$O(n)$$ ","permalink":"http://localhost:45763/personal_website/posts/leetcode_315_count_of_smaller_numbers_after_self/","summary":"\u003cp\u003eHere\u0026rsquo;s my solution to the \u003ca href=\"https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/\"\u003eLeetcode 315: Count of Smaller Numbers After\nSelf problem\u003c/a\u003e using standard merge sort. I just change one line to\ncount while merge procedure.\u003c/p\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\n\u003cp\u003eLet\u0026rsquo;s build the solution step by step.\u003c/p\u003e\n\u003cp\u003eInput: nums = $$[5,2,6,1]$$\u003c/p\u003e\n\u003cp\u003eFirst, turn the numbers into \u003cstrong\u003e[number, index]\u003c/strong\u003e tuple. So it looks like:\u003c/p\u003e\n\u003cp\u003earray = $$ [ [ 5, 0 ], [ 2, 1 ], [ 6, 2 ], [ 1, 3 ] ] $$\u003c/p\u003e","title":"Leetcode 315: Count of Smaller Numbers After Self"},{"content":"Here\u0026rsquo;s my explanation for the leetcode 306: Additive Number problem\nAdditive Number Problem Problem Recap An additive number is a string of digits where the sequence of numbers formed by splitting the string satisfies the condition that each number (after the first two) is the sum of the two preceding numbers.\nExamples: \u0026quot;112358\u0026quot; is additive because the sequence is 1, 1, 2, 3, 5, 8, and:\n1 + 1 = 2 1 + 2 = 3 2 + 3 = 5 3 + 5 = 8 \u0026quot;199100199\u0026quot; is additive because the sequence is 1, 99, 100, 199, and:\n1 + 99 = 100 99 + 100 = 199 Solution Approach The solution uses a backtracking approach to try all possible splits of the string into sequences of numbers and checks if any of these sequences form an additive sequence.\nDetailed Explanation Helper Function isValid This recursive function checks if the remaining part of the string s forms a valid additive sequence given the first two numbers a and b.\nBase Case: If the remaining string s is empty, it means we\u0026rsquo;ve successfully formed an additive sequence, so return true.\nRecursive Step:\nCompute the sum of a and b and convert it to a string sum. Check if the remaining string s starts with sum: If not, the sequence is invalid  return false. If yes, recursively check the next part of the string with the new pair (b, sum) and the remaining string after removing sum. Main Function isAdditiveNumber Initialization: Get the length of the input string num. Nested Loops: The outer loop (i) determines the end index of the first number a (from index 0 to i). The inner loop (j) determines the end index of the second number b (from index i to j). Leading Zero Check: Skip any splits where a or b have leading zeros unless they are exactly \u0026quot;0\u0026quot;. Example: \u0026quot;02\u0026quot; is invalid, but \u0026quot;0\u0026quot; is valid. Validation: For each valid pair (a, b), call isValid to check if the remaining part of the string forms a valid additive sequence starting with a and b. If isValid returns true, immediately return true from the main function. Final Check: If no valid sequence is found after all possible splits, return false. Example Walkthrough Let\u0026rsquo;s walk through the example num = \u0026quot;112358\u0026quot;:\nFirst Iteration (i = 1, j = 2): a = \u0026quot;1\u0026quot;, b = \u0026quot;1\u0026quot;. No leading zeros  proceed. isValid(1, 1, \u0026quot;2358\u0026quot;): Sum of 1 + 1 = 2. Check if \u0026quot;2358\u0026quot; starts with \u0026quot;2\u0026quot;  Yes. Recursively call isValid(1, 2, \u0026quot;358\u0026quot;): Sum of 1 + 2 = 3. Check if \u0026quot;358\u0026quot; starts with \u0026quot;3\u0026quot;  Yes. Recursively call isValid(2, 3, \u0026quot;58\u0026quot;): Sum of 2 + 3 = 5. Check if \u0026quot;58\u0026quot; starts with \u0026quot;5\u0026quot;  Yes. Recursively call isValid(3, 5, \u0026quot;8\u0026quot;): Sum of 3 + 5 = 8. Check if \u0026quot;8\u0026quot; starts with \u0026quot;8\u0026quot;  Yes. Recursively call isValid(5, 8, \u0026quot;\u0026quot;): Empty string  return true. Since isValid returned true, the main function returns true. Edge Cases Leading Zeros: Correctly skips invalid splits (e.g., \u0026quot;02\u0026quot; unless it\u0026rsquo;s \u0026quot;0\u0026quot;). Single Digit: If input length \u0026lt; 3, returns false. Large Numbers: Uses parseInt, but BigInt is better for very large numbers to avoid precision issues. Time Complexity Nested loops: O(n), where n is the string length. isValid function: O(n) per pair (a, b). Overall: O(n), feasible for reasonably sized strings. Space Complexity O(n) due to recursion stack in the worst case. Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var isAdditiveNumber = function(num) { const isValid = (a, b, s) =\u0026gt; { if (s.length === 0) return true; const sum = (a + b).toString(); return s.startsWith(sum) \u0026amp;\u0026amp; isValid(b, parseInt(sum), s.slice(sum.length)); }; const n = num.length; for (let i = 1; i \u0026lt; n; i++) { for (let j = i + 1; j \u0026lt; n; j++) { const a = num.slice(0, i); const b = num.slice(i, j); if ((a.startsWith(\u0026#39;0\u0026#39;) \u0026amp;\u0026amp; a.length \u0026gt; 1) || (b.startsWith(\u0026#39;0\u0026#39;) \u0026amp;\u0026amp; b.length \u0026gt; 1)) continue; if (isValid(parseInt(a), parseInt(b), num.slice(j))) return true; } } return false; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 var isAdditiveNumber = function(num) { let N = num.length; let check = ( a ) =\u0026gt; { /** check if numbers in an array form fibonacci seqence **/ let A = a.length; if ( A \u0026lt; 3 ) return false; for ( let i=2; i \u0026lt; A; i++ ) if ( Number(a[i]) != Number(a[i-1]) + Number(a[i-2]) || ( a[i].length \u0026gt; 1 \u0026amp;\u0026amp; a[i].startsWith(\u0026#39;0\u0026#39;) ) || ( a[i-1].length \u0026gt; 1 \u0026amp;\u0026amp; a[i-1].startsWith(\u0026#39;0\u0026#39;) ) || ( a[i-2].length \u0026gt; 1 \u0026amp;\u0026amp; a[i-2].startsWith(\u0026#39;0\u0026#39;) ) ) return false; return true; }; let bt_search = ( i, cur = [] ) =\u0026gt; { if ( i \u0026gt; N ) return false; if ( i === N \u0026amp;\u0026amp; check(cur) ) return true; // num[i] starts a new number, explore path cur.push( num[i] ); let new_start = bt_search( i+1, cur ); if ( new_start ) return true; // backtrack, num[i] continues the previous number cur.pop(); if ( i \u0026gt; 0 ) { cur[ cur.length-1 ] += num[i]; let add_prev = bt_search( i+1, cur ); if ( add_prev ) return true; } return false; }; return bt_search( 0 ); }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_306_additive_number/","summary":"\u003cp\u003eHere\u0026rsquo;s my explanation for the \u003ca href=\"https://leetcode.com/problems/additive-number/description/\"\u003eleetcode 306: Additive Number problem\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"additive-number-problem\"\u003eAdditive Number Problem\u003c/h2\u003e\n\u003ch3 id=\"problem-recap\"\u003eProblem Recap\u003c/h3\u003e\n\u003cp\u003eAn \u003cstrong\u003eadditive number\u003c/strong\u003e is a string of digits where the sequence of numbers formed by splitting the string satisfies the condition that each number (after the first two) is the sum of the two preceding numbers.\u003c/p\u003e\n\u003ch4 id=\"examples\"\u003eExamples:\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026quot;112358\u0026quot;\u003c/code\u003e is additive because the sequence is \u003ccode\u003e1, 1, 2, 3, 5, 8\u003c/code\u003e, and:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e1 + 1 = 2\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e1 + 2 = 3\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e2 + 3 = 5\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e3 + 5 = 8\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026quot;199100199\u0026quot;\u003c/code\u003e is additive because the sequence is \u003ccode\u003e1, 99, 100, 199\u003c/code\u003e, and:\u003c/p\u003e","title":"Leetcode 306: Additive number"},{"content":"Here are all possible solutions I could come up with for the longest increasing subsequence problem. leetcode 300\nApproach 1: Generate all possible increasing subsequences We will keep track of a subsequence in an array named cur_subsequence or cur_sub. For each element (a[i]) we have the following 2 options:\nAdd the element to the end of current subsequence.\nNote: The current element can only be included if either the current subsequence is empty or the last element of the current subsequence is smaller than the current element. This is important to maintain the increasing subsequence property.\nIgnore the current element and explore without a[i]\nTime complexity: $$ O(2^N) $$ Space complexity: $$ O(N) $$ // recursion stack + auxilary array 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 var lengthOfLIS = function(a) { let A = a.length; // maximum length of a subsequence seen so far let max_len = 1; let bt_search = ( i, cur_sub = [] ) =\u0026gt; { if ( i \u0026gt;= A ) { max_len = Math.max( max_len, cur_sub.length ); return; } // either select the ith element, or ignore it. // a[i] can be taken when either subsequencee is empty or // last inserted element is smaller if ( !cur_sub.length || cur_sub[ cur_sub.length-1 ] \u0026lt; a[i] ) { cur_sub.push( a[i] ); bt_search( i+1, cur_sub ); cur_sub.pop(); // backtrack } // explore without a[i] included bt_search( i+1, cur_sub ); }; bt_search(0); return max_len; } Approach 2 (Version 1) : Generating all possible subsequences, but change the structure of the recursion to allow memoization Currently, we are keeping track of the current subsequence in an array cur_sub which makes it difficult for us to implement memoization. Notice that we only need previously selected element (to compare if current element is larger) and current length (to find the subsequence length). Hence, we will only use 3 variables: index, previous element index, current length.\nTime complexity: $$ O( N^2 ) $$ Space complexity: $$O( N^3 )$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 var lengthOfLIS = function(a) { /** Write a recurrence relation. Either you take the element @i or your ignore it. In either case, your pick the maximum length. generating all possible increasing subsequences, but not storing the subsequence and using only 3 variables. for each call(index, prev_selected, cur_length) we try to find the maximum length we can form by either selecting or rejecting a[i] This configuration is easy to memoize. **/ let A = a.length; let memo = new Map(); let bt_search = ( i, prev, cur_len = 0 ) =\u0026gt; { // inputs of the function are memoized by turning // them into a String `key` let key = JSON.stringify( [i, prev, cur_len] ); if (memo.has(key)) return memo.get(key); if ( i \u0026gt;= A ) return cur_len; let take = -1, not_take = -1; // a[i] can be taken if prev=null / cur_len=0 // or prev \u0026lt; a[i] if ( cur_len == 0 || prev \u0026lt; a[i] ) take = bt_search( i+1, a[i], cur_len+1 ); // backtrack. do not take a[i] not_take = bt_search( i+1, prev, cur_len ); let res = Math.max( take, not_take ); memo.set(key, res); return memo.get(key); }; return bt_search(0); } Approach 2 (Version 2): Yet another recursive solution, but with better memoization This solution memoizes using only: index of current element (i), index of previously selected element (prev_i).\nThe memoization is done in a matrix of size $$N$$X$$(N+1)$$.\nTime complexity: $$ O( N^2 ) $$ Space complexity: $$O( N^2 )$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 var lengthOfLIS = function(a) { /** Approach 2 (version 2): Instead of storing 3 variables, just store 2 variables. This will enable memoization table to be an NxN matrix. **/ let A = a.length; let memo = new Array( A ).fill(null).map( () =\u0026gt; new Array( A+1 ).fill( null ) ); let bt_search = ( i, prev_i = -1 ) =\u0026gt; { // y is remapped since prev_i is in range [-1,n-1] // but our array ranges is in range [0, n] let x = i, y = prev_i + 1; if ( i \u0026gt;= A ) return 0; if ( memo[x][y] !== null ) return memo[x][y]; let take = -1, not_take = -1; // a[i] can be taken if prev_i = -1 / cur_len=0 or // a[prev_i] \u0026lt; a[i] if ( prev_i == -1 || a[prev_i] \u0026lt; a[i] ) take = 1 + bt_search( i+1, i ); // backtrack. do not take a[i]. The length remains same not_take = bt_search( i+1, prev_i ); let res = Math.max( take, not_take ); memo[x][y] = res; return memo[x][y]; }; return bt_search(0); } Approach 3: Dynamic programming Declare a lis(longest increasing subsequence) array, where lis[i] denotes the length of longest increasing subsequence starting at i and ending at the end of the array. Fill this table from second last element towards first element.\nTo find lis[i] for an element a[i] use the following algorithm:\nFor each i \u0026lt;- n-2 - 0 // find if index i can form an increasing subsequence // with any element on the right of it max_len = 1 For each j \u0026lt;- i+1 - n if ( a[i] \u0026lt; a[j] ) // a[j] is a potential connection point max_len = MAX( max_len, 1 + lis[j] ) lis[i] = max_len The basic intuition behind it is, that we explore all elements to the right of a[i] which can connect with a[i] to form an increasing subsequence. The length of such a subsequence is given by:\n1 (length of a[i]) + length of longest subsequence from a[j] up until the end of the array\nwhich is same as: 1 + lcs[j]\nTime: $$O(n^2)$$ Space: $$O(n)$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 let MAX = Math.max; var lengthOfLIS = function(a) { /** Appraoch 3: Build the dp table manually using loops **/ let A = a.length; let lis = new Array( A ).fill(1); // global maximum, subsequence length from a[i] until end let gmax = 1; for ( let i = A-2; i \u0026gt;= 0; i-- ) { let max_len = 1; for ( let j = i+1; j \u0026lt; A; j++ ) { if ( a[i] \u0026lt; a[j] ) max_len = MAX( max_len, 1+lis[j] ); } lis[i] = max_len; gmax = MAX( max_len, gmax ); } return gmax; } Approach 4: Build an auxilary array, such that the minium elements are always at the end of it Here, we are basically trying to kick out large elements and inserting small elements whereever possible, so that new incoming elements feel welcome attaching themselves to the existing subsequence.\nBuild a auxilary array using the following algorithm:\nsubsequence = [] For each i \u0026lt;- 0 to A-1 if subsequence.last_element \u0026lt; a[i] subsequence.push( a[i] ) else { replace the largest element smaller than or equal to a[i] in subsequence using binary search. } the length of the subsequence is the length of the largest increasing subsequence. Time: $$O(n\\ log n)$$ // n for iteration, and for each iteration binary search O(log n) Space: $$O(n)$$ // auxilary array Note that the array that we actually build here does not represent a valid increasing subsequence. Nor is it the longest increasing subsequence, we just insert the elements using a particularly methodology which ensures its validity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 let MAX = Math.max; let FLOOR = Math.floor; var b_search = ( a, target ) =\u0026gt; { // return the index pf the number \u0026gt;= target let i = 0, j = a.length-1; while ( i \u0026lt;= j ) { let mid = i + FLOOR( (j-i)/2 ); if ( a[mid] == target ) return mid; else if ( a[mid] \u0026lt; target ) i = mid+1; else j = mid-1; } return i; }; var lengthOfLIS = function(a) { /** Approach 4: The idea is to keep the minium elements, such that validity of lis(longest increasing subsequence) for new incoming elements can be calculated quickly **/ let A = a.length; let sub = [ a[0] ]; for ( let i=1; i \u0026lt; A; i++ ) { let lst = sub.length-1; if ( sub[ lst ] \u0026lt; a[i] ) sub.push( a[i] ); else { // find a \u0026#34;write index\u0026#34; where we replace a[i] let wi = b_search( sub, a[i] ); sub[wi] = a[i]; } } return sub.length; } Approach 5: In place algorithm for approach 4 Time: $$O(n\\ logn)$$ Space: $$O(1)$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 let MAX = Math.max; let FLOOR = Math.floor; /* this version is for searching within the same array starting and ending position are requirede */ var b_search = ( a, start, end, target ) =\u0026gt; { // return the index pf the number \u0026gt;= target let i = start, j = end; while ( i \u0026lt;= j ) { let mid = i + FLOOR( (j-i)/2 ); if ( a[mid] == target ) return mid; else if ( a[mid] \u0026lt; target ) i = mid+1; else j = mid-1; } return i; }; var lengthOfLIS = function(a) { /*** Approach 5: Same as the above approach, but in place Hence saving auxilary space. The idea is to keep a variable to mark the end of the subsequence in a itself. **/ let A = a.length; let S = 1; // variable to mark the end of the subsequence for ( let i=1; i \u0026lt; A; i++ ) { if ( a[S-1] \u0026lt; a[i] ) { a[S] = a[i]; S++; } else { // find a \u0026#34;write index\u0026#34; where we replace a[i] let wi = b_search( a, 0, S-1, a[i] ); a[wi] = a[i]; } } return S; } ","permalink":"http://localhost:45763/personal_website/posts/all_possible_solutions_to_longest_increasing_subsequence_problem_leetcode_300/","summary":"\u003cp\u003eHere are all possible solutions I could come up with for the longest\nincreasing subsequence problem. \u003ca href=\"https://leetcode.com/problems/factorial-trailing-zeroes/description/\"\u003eleetcode\n300\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"approach-1-generate-all-possible-increasing-subsequences\"\u003eApproach 1: Generate all possible increasing subsequences\u003c/h1\u003e\n\u003cp\u003eWe will keep track of a subsequence in an array named \u003ccode\u003ecur_subsequence\u003c/code\u003e\nor \u003ccode\u003ecur_sub\u003c/code\u003e. For each element (\u003ccode\u003ea[i]\u003c/code\u003e)  we have the following 2\noptions:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eAdd the element to the end of current subsequence.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eNote: The current element can only be included if\neither the current subsequence is empty or the last\nelement of the current subsequence is smaller than\nthe current element. This is important to maintain\nthe increasing subsequence property.\u003c/em\u003e\u003c/p\u003e","title":"All possible solutions to longest increasing subsequence problem: leetcode 300"},{"content":"Problem link: leetcode 70: climbing stairs\nIntuition You need to climb n stairs, taking 1 or 2 stairs at a time.\nIf n = 2, you can climb like:\n$$1+1 = 2\\times (1) + 0 \\times(2)$$ $$2 = 0 \\times (1) + 1\\times(2) $$ if n = 3, you can climb like:\n$$1+1+1 = 3\\times(1) + 0\\times(2)$$ $$1+2 = 1\\times(1) + 1\\times(2)$$ $$2+1 = 1\\times(1) + 1\\times(2) $$ Basically you first need to decide how many steps of size 1 will you take and how many of size 2 do you need:\nHence, your first task is to solve the equation:\n$$ x \\times 1 + y \\times 2 = n $$\nTo decide the number of 1s and 2s. After you decide upon x and y then you will have calculate $$ \\frac{(x + y)!}{x! , y!} $$\nWhich is nothing but ways of chosing how exactly you will proceed. This is because we are trying to adjust x identical objects and y identical objects in x+y positions. Think of the number of ways you can arrange x men and y women in x + y positions.\nAs an example $$n=3, x=1 $$ and $$y=1$$\nThen you will have $$\\frac{(1 + 1)!}{1! , 1!} =2$$. see above, they are: $$ 1+2 \\ 2+1 $$\nApproach $$ y \\in [0, n/2] $$\nFor each , calculate the corresponding values of $$x$$ using the equation: $$ x \\times 1 + y \\times 2 = n \\ x = n - (2 \\times y ) $$\nthen calculate $$ \\frac{(x + y)!}{x! , y!} $$\nand add this to your counter variable.\nreturn counter.\nComplexity Time complexity: Time: O($$n^2$$)\nSpace: O(1)\nBut it can be reduced, if you can store calculated factorials. Hence, making the time complexity of calculating $$ \\frac{(x + y)!}{x! , y!} $$ -\u0026gt; O(1) and Space complexity O(n)\nTime complexity: O(n) Space complexity: O(n)\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 var permute = (x,y) =\u0026gt; { /* compute (x+y)! / x! y! without computing factorials */ /* which is basically computing x+y x+y-1 x+y-2 .. y+1 / x! */ var denom = 1; for (var i=1; i \u0026lt;= x; i++) denom *= i; var numi = 1; for (var i = y+1; i \u0026lt;= x+y; i++) numi *= i; return numi/denom; }; var climbStairs = function(n) { /* The number of ways in which we can get n by adding only 1 and 2 Let, 1x + 2y = n ---(1) then we need to find the number of integer solutions to this equation. that is S = {x,y | x,y in integers} we need to return |S| i.e. the number of elements in this solution set. from (1) it implies x = n - 2y ---(2) y in range [0,n/2] i.e. consequently x in range [0,n] hence, iterate over y from 0 to n/2 such that y is integer. we find the corrosponding solution using equation 2 */ let n_solutions = 0 ; for (var y=0; y \u0026lt;= Math.floor(n/2); y++ ) { var x = n - (2 * y); n_solutions += permute(x,y); } return (n_solutions); }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_70/","summary":"\u003cp\u003eProblem link: \u003ca href=\"https://leetcode.com/problems/climbing-stairs/description/\"\u003eleetcode 70: climbing stairs\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"intuition\"\u003eIntuition\u003c/h1\u003e\n\u003c!-- Describe your first thoughts on how to solve this problem. --\u003e\n\u003cp\u003eYou need to climb \u003ccode\u003en\u003c/code\u003e stairs, taking 1 or 2 stairs at a time.\u003c/p\u003e\n\u003cp\u003eIf n = 2, you can climb like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$$1+1 = 2\\times (1) + 0 \\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$2 = 0 \\times (1) + 1\\times(2) $$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eif n = 3, you can climb like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$$1+1+1 =  3\\times(1) + 0\\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$1+2   =  1\\times(1) + 1\\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$2+1   =  1\\times(1) + 1\\times(2) $$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBasically you first need to decide how many steps of size 1 will you take and how many of size 2 do you need:\u003c/p\u003e","title":"Leetcode 70: Climbing Stairs"},{"content":"Below is my C solution for the Leetcode problem candy.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 static inline void previous_kids_started_crying(int* kid, int continous_decrease_start, int continous_decrease_end, int* candy) { /* * To satisfy the condition that each child with higher rating than * it\u0026#39;s neighbors must get more candies. We give all children in range * [continous_decrease_start, continous_decrease_end] an extra candy * if the he has candies lower or equal to the kid after it. * * Note that we do not bother the kid before it, since it is known * that the kid before it has more rating than this kid */ if (continous_decrease_start == -1) { exit(1); } for (int i = continous_decrease_end; i \u0026gt;= continous_decrease_start; i--) { if (kid[i] \u0026lt;= kid[i+1]) { int before = kid[i]; kid[i]++; int after = kid[i]; *candy += after - before;; } else { /* chain is broken. We found a satisfied non protesting kid the kids before it must also be non-protesting */ return; } } } int candy(int* kid, int n) { /* * Few things to take care of: * * 1. At a time take a look at 2 children. i.e. iterate the children * in window of 2. * * 2. Each time a candy is given, check if previous child has more * rating, since he will start crying. He/she will protest that the * kid in front of him has less rating than him/her and still got * more/equal candies than him/her. It might even trigger a chain * where the kid previous to the previous kid might also see this * changed state, and if he had a rating more then the kid after him. * then he will also start asking more candies. And the kid behind * that and so on. * * The algorithm runs in linear time, however, if the children are * arranged in decreasing order of rating, then at each iteration all * previous children will start crying. Hence, everybofy needs to be * given more candies. In that case it becomes quadratic * * Space required is constant. * * Best case: * Time: O(n) * Space: O(1) * * Worst Case: * Time: O(n^2) * Space: O(1) */ int candies = 0; int continous_decrease_from = -1; /* First child gets a candy, but save his rating first */ int previous_child_rating = kid[0]; kid[0] = 1; candies++; for (int i = 1; i \u0026lt; n; i++) { if (kid[i] \u0026gt; previous_child_rating) { /* Since this child has more rating than the previous child, this child gets 1 more candy than previous child */ previous_child_rating = kid[i]; kid[i] = kid[i-1]+1; candies += kid[i]; continous_decrease_from = -1; } else if (kid[i] == previous_child_rating){ /* Since this child has equal rating than the previous child, give him 1 candy */ previous_child_rating = kid[i]; kid[i] = 1; candies++; continous_decrease_from = -1; } else { /* Previous child has more rating. Give this child one candy, and after giving : if the previous child had less candy, then we must initiate a chain reaction to do justice to all previous kids to previous children the problem here is that if this child has less rating then his predecessor then he will also start crying. And, the predecesor of this child also has more score then he will also start crying. Hence, we must give candies to them as well to maintain rule. Hence, check if the rule is disturbed, */ if (continous_decrease_from == -1) { /* A period of continous decrease started */ /* Hence, give this child 1 candy and if the previous child will also get 1 candy if he gets */ continous_decrease_from = i-1; previous_child_rating = kid[i]; kid[i] = 1; if (kid[i-1] \u0026gt; kid[i]) { candies ++; } else { kid[i-1] = kid[i] + 1; candies += 2; } } else { /* Give this child a candy, but mind the children behind this child */ previous_child_rating = kid[i]; kid[i] = 1; candies++; previous_kids_started_crying(kid, continous_decrease_from, i-1, \u0026amp;candies); } } } return candies; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_135/","summary":"\u003cp\u003eBelow is my C solution for the Leetcode problem \u003ca href=\"https://leetcode.com/problems/climbing-stairs/description/\"\u003ecandy\u003c/a\u003e.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e  1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 35\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 36\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 37\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 38\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 39\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 40\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 41\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 42\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 43\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 44\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 45\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 46\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 47\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 48\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 49\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 50\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 51\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 52\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 53\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 54\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 55\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 56\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 57\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 58\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 59\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 60\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 61\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 62\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 63\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 64\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 65\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 66\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 67\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 68\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 69\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 70\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 71\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 72\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 73\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 74\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 75\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 76\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 77\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 78\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 79\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 80\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 81\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 82\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 83\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 84\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 85\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 86\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 87\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 88\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 89\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 90\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 91\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 92\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 93\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 94\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 95\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 96\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 97\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 98\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 99\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e100\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e101\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e102\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e103\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e104\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e105\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e106\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e107\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e108\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e109\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e110\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e111\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e112\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e113\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e114\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e115\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e116\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e117\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e118\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e119\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e120\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e121\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e122\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e123\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e124\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e125\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e126\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e127\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e128\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e129\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e130\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e131\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e132\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e133\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e134\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kr\"\u003einline\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eprevious_kids_started_crying\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_end\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ecandy\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * To satisfy the condition that each child with higher rating than\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * it\u0026#39;s neighbors must get more candies. We give all children in range\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * [continous_decrease_start, continous_decrease_end] an extra candy\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * if the he has candies lower or equal to the kid after it.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Note that we do not bother the kid before it, since it is known\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * that the kid before it has more rating than this kid\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e        */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nf\"\u003eexit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_end\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ebefore\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eafter\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ecandy\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003eafter\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ebefore\u003c/span\u003e\u003cspan class=\"p\"\u003e;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* chain is broken. We found a satisfied non protesting kid\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                          the kids before it must also be non-protesting */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ecandy\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Few things to take care of:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * 1. At a time take a look at 2 children. i.e. iterate the children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * in window of 2.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * 2. Each time a candy is given, check if previous child has more\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * rating, since he will start crying. He/she will protest that the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * kid in front of him has less rating than him/her and still got\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * more/equal candies than him/her. It might even trigger a chain\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * where the kid previous to the previous kid might also see this\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * changed state, and if he had a rating more then the kid after him.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * then he will also start asking more candies. And the kid behind\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * that and so on.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * The algorithm runs in linear time, however, if the children are\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * arranged in decreasing order of rating, then at each iteration all\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * previous children will start crying. Hence, everybofy needs to be\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * given more candies. In that case it becomes quadratic\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space required is constant.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Best case:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Time: O(n)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space: O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Worst Case:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Time: O(n^2)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space: O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e         */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/* First child gets a candy, but save his rating first */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Since this child has more rating than the previous\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         child, this child gets 1 more candy than previous\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         child */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Since this child has equal rating than the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         previous child, give him 1 candy */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Previous child has more rating. Give this child one\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candy, and after giving : if the previous child had less\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candy, then we must initiate a chain reaction to do\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        justice to all previous kids to previous children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        the problem here is that if this child has less rating\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        then his predecessor then he will also start crying.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        And, the predecesor of this child also has more score\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        then he will also start crying. Hence, we must give\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candies to them as well to maintain rule. Hence, check\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        if the rule is disturbed,\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* A period of continous decrease started */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* Hence, give this child 1 candy and if the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                                   previous child will also get 1 candy if he gets  */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* Give this child a candy, but mind the children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                                  behind this child */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"nf\"\u003eprevious_kids_started_crying\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Leetcode 135: Candy"},{"content":"Introduction Linux is the kernel that powers the modern computing world. Its everywherefrom all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isnt about why Linux dominates the tech world; its about how I started contributing to the Linux Kerneland how you can too.\nHow Kernel Development Works Kernel development thrives on the Linux Kernel Mailing List (LKML), the nerve center of Linuxs open-source ecosystem. The beauty of open source? Anyone can contribute. Your task is to send patches (essentially the output of git diff refurbushed into an email).\nIf your patch solves a real problem or adds value, experienced developers will jump in with questions about your intent and rationale. Heres a pro tip: dont explain the how of your code; let the code speak for itself. Instead, focus on explaining why your change is needed.\nThe LKML community is incredibly supportive \u0026ndash; theyll critique your code, point out mistakes, and suggest improvements. Sure, it might feel overwhelming initially, but resources like the LFD103 course can guide you through the basics: generating patches, submitting them to LKML, compiling, and booting the kernel.\nFor me, just setting up my mail client and understanding LKML discussions took about a month. But once you clear these initial hurdles, things get easier. If youre struggling, feel free to check out my notesthey might save you some time.\nMy Background For years, kernel developers seemed like magicians to medoing impossibly cool things with computers. My fascination started after I stumbled upon a video of someone working on the kernel. It was mesmerizing!\nIn my second semester, I discovered the book The C Programming Language, and it sparked my love for C. The control C offers is unmatched, but it comes with its fair share of challengesbugs galore!\nSurprisingly, I wasnt a Linux user until recently. When I finally switched from Windows to Linux, everything just clicked. Concepts that once felt abstract suddenly made sense. On Windows, troubleshooting often felt like solving a mystery even Microsoft couldnt decode. On Linux, it felt like someone handed me the keys to the entire system.\nWhile working on kernel contributions, I read Linux Device Drivers, a book authored by seasoned kernel developers. It gave me a deeper understanding of the kernels inner workings. If youre serious about kernel development or writing drivers, this book is a must-read.\nWhat to Contribute The hardest part of contributing to the Linux Kernel is figuring out what to work on. The kernel is vasttheres everything from GPU drivers to network stack development.\nSince the kernels primary job is managing hardware, driver development is a hotspot of activity. New devices constantly hit the market, and they need drivers. If you have an electronics background and access to hardware, driver development is an excellent starting point.\nIf hardware isnt your thing (like in my case), here are some alternatives:\nkselftest: A testing framework for kernel functionality. Core subsystems: The backbone of the kernela great way to learn the essentials. syzbot reports: A kernel fuzzer that uncovers bugs by feeding the kernel random data. These reports are a goldmine for learning about common mistakes. Another beginner-friendly option is upgrading deprecated APIs. These updates are highly appreciated because they improve the kernels maintainability and security. Its not always a simple find-and-replaceyoull need to understand the codebut its a rewarding way to start.\nAnd dont underestimate fixing spelling and grammar errors in the documentation or comments. While it might sound trivial, its a fantastic way to learn the workflow: creating patches, submitting them, and receiving feedback. Tools like codespell can help you automate finding these errors.\nMy first-ever patch was a simple typo fix, but I made the classic rookie mistake of introducing two changes while documenting only one. Lesson learned!\nOnce you start contributing, youll notice issues everywhere. Even just following discussions on LKML can teach you a ton about how seasoned developers think and work.\nConclusion Kernel development might seem intimidating at first, but trust me, its worth the effort. Youll not only become a stronger developer but also gain a deep understanding of how computers work. Youll build expertise in both kernel and userspace development, and your Git skills will level up immenselya must-have for any programmer.\nThe learning opportunities in kernel development are unparalleled, often rivaling (or even exceeding) those at top tech companies. So if youre considering it, dont hesitatedive in! You might be surprised by how much youll grow.\nGood Luck!\nReferences ","permalink":"http://localhost:45763/personal_website/posts/highlights_from_linux_kernel_mentorship_program_2024/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux is the kernel that powers the modern computing world. Its everywherefrom all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isnt about \u003cem\u003ewhy\u003c/em\u003e Linux dominates the tech world; its about how I started contributing to the Linux Kerneland how you can too.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"how-kernel-development-works\"\u003eHow Kernel Development Works\u003c/h2\u003e\n\u003cp\u003eKernel development thrives on the Linux Kernel Mailing List (LKML), the\nnerve center of Linuxs open-source ecosystem. The beauty of open\nsource? Anyone can contribute. Your task is to send patches (essentially\nthe output of \u003ccode\u003egit diff\u003c/code\u003e refurbushed into an email).\u003c/p\u003e","title":"Highlights from Linux Kernel Mentorship Program 2024 by Abdul Rahim"},{"content":"Introduction Computer memory is usually implemented as a file system. While tampering with data is easy to detect, unauthorized access to memory is a more complex task falling within the domain of Intrusion Detection Systems (IDS). Most intrusion detection systems focus on analyzing network traffic or using machine learning techniques to identify suspicious patterns, we explore if we can employ merkel trees for this task.\nIf unauthorized memory access cannot be detected, users would never know that the system was compromised. Detecting tampered files is straightforward: you can hash the contents of a file, and if the hash changes you might conclude that the file changed. However, detecting memory access is more complicated. Although Linux keeps track of the last access timestamp, available via the stat command1, it only tracks file accesses that use the read() syscall2.\nMerkel Trees Merkle trees are a data structure in which hashes are stored rather than data. Leaf nodes store hashes of particular data blocks, while other nodes store hashes of their children. Merkle trees are widely used in blockchains for their ability to detect data tampering. They provide a robust mechanism to detect tampering in multiple distinct data items. If any data item in a leaf node changes, the whole tree becomes invalidated because it changes the hashes of all nodes up the tree.\nFig. 1: A Merkle tree is a data structure in which each node contains a hash. All non-leaf nodes contain hashes of their children, and all leaf nodes contain hashes of the underlying data.\nMerkel tree as directory tree Now, what we want to do is to augment the directory tree as a merkel tree. To be exact the inode structure (See inode doc for more details).\nDoing this would make us have hashes for children in directory tree. And the benefit of that is whenever the child inodes change, the current inode would change. And there\u0026rsquo;s 2 fields that each node would contain, the last seen hash (expected hash) of it\u0026rsquo;s child and the current hash of the same child. And when the current hash changes to a different value from expected hash, then we can imply that the child inode changed.\nBut one question is that if memory can be accessed bare metal, then the protections done in software doesn\u0026rsquo;t really make any sense. One possible solution to this problem is employing encryption.\nThe encryption should be performed in hardware, and the memory access system calls should define protocols for decrypting the underlying memory. The same system call would update necessary variables of the file in question, such as access time. The memory access system call needs to be implemented so that when one accesses memory, the data is decrypted and other functions are performed.\nBelow is a detailed description.\nArchitecture File system in most operating systems follow a hierarchical structure. We augment this with a Merkle tree, where a node is attached to each file in the file system. These nodes form a Merkle tree, where each node contains the hash of its children (in the case of non-leaf nodes) or the hash of the file data (in the case of files). Additionally, a pollution flag is attached to each node to detect illegal access.\nEach node will also has an expected hash, which is the hash of the node when the subtree below that node was last valid.\nWorking The pollution flag is set if expected_hash != hash, which occurs only on illegal access. I will explain this in a moment.\nWhen a user or process requests memory, it will go through the memory access system call, requiring authentication. Once the authentication is successful, the underlying data is decrypted and returned, the access time is updated, and all the hashes up to the root are updated along with the expected hash (note that the expected hash changes on authorized access). The tree remains valid.\nIf the authentication fails, the memory is not returned, but the access time changes. Consequently, when the tree is re-evaluated, the hash of this node changes since it incorporates the access time, but the expected hash remains the same, setting the pollution flag for this node.\nSince the parent of this node uses its hash, the parent\u0026rsquo;s hash also changes. However, its expected hash remains the same, leading to its invalidation. This process continues up the tree, invalidating the whole tree.\nThe benefit of this approach is that all other nodes remain valid. If one tries to determine which file was accessed and the timestamp, it is easy to identify the exact file by following the invalid nodes from top to bottom.\nRefrences stat man page\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nread syscall\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:45763/personal_website/posts/merkel_trees_and_computer_memory/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003c!-- mine\nComputer memory is usually implemented as a file system. While tampering\nof data is easy to detect, unauthorised access to memory is a more\ncomplex task. A problem that lies in the domain of Intrusion Detection\nSystems. While, most intrusion detection focus on analyzing network\ntraffic, or machine learning techniques to identify suspicious patterns.\nWe propose a method that works within the system, providing robust\naccess detection.\n--\u003e\n\u003cp\u003eComputer memory is usually implemented as a file system. While tampering\nwith data is easy to detect, unauthorized access to memory is a more\ncomplex task falling within the domain of Intrusion Detection Systems\n(IDS). Most intrusion detection systems focus on analyzing network traffic or\nusing machine learning techniques to identify suspicious patterns, we\nexplore if we can employ merkel trees for this task.\u003c/p\u003e","title":"Merkel Trees and computer memory"},{"content":"Introduction When you install vim, a usual requirement as with all text editors is the ability to copy to/from system clipboard so you can lets say, copy something into your vim session from firefox or vice versa, however copy pasting in terminal editors is not as straight forward as with GUI editors. In vim if you want to copy something into an auxilary space (anticipating it would be used later, so you can paste from this auxilary space) is achieved by registers.\nThe register that represents system clipboard is + register. Anything that you copy into this register is available in system clipboard.\nHow to use registers to copy/paste To copy a text into a register, select it in visual mode and press \u0026quot;\u0026lt;register_name\u0026gt;y to yank the contents into the given register. And to paste the contents of a particular register at current position, use \u0026quot;\u0026lt;register_name\u0026gt;p.\nTo use system clipboard, you just have to substitute \u0026ldquo;+\u0026rdquo; for register name in the above commands.\nclipboard support But the + register wont work unless you have clipboard support with your vim installation. By default there is no clipboard support in vim.\nTo check if your vim installation has clipboard support use:\n1 2 3 $ vim --version | grep clipboard +clipboard +keymap +printer +vertsplit +ex_extra +mouse_netterm +syntax +xterm_clipboard or inside of vim, you can run the command:\n1 :echo has(\u0026#39;clipboard\u0026#39;) If the output is 0, your installation doesnt have clipboard support.\nCompiling vim Now there are 2 solutions to this problem:\nEither install gvim: Or compile vim from sources with clipboard support Let\u0026rsquo;s see how each of them can be done.\nInstall gvim To install gvim run:\nOn Debian:\n1 sudo apt install vim-gtk On Fedora\n1 sudo dnf install gvim To compile vim with clipboard support Below are the simple steps:\nStep 1: Grab the sources Clone the repository:\n1 2 git clone https://github.com/vim/vim.git vim cd vim Step 2: Install dependencies Install the required libraries and tools to build vim, for example gcc, x11 etc. Note that you only need them to compile vim and you are free to delete them once you are done.\nOn Debian:\n1 sudo apt install build-essential libx11-dev libncurses5-dev On Fedora:\n1 2 3 4 sudo dnf groupinstall \u0026#34;Development Tools\u0026#34; sudo yum install gcc sudo yum groupinstall \u0026#34;X Software Development\u0026#34; sudo dnf install libX11-devel ncurses-devel Also, you need to remove the existing installation(if any).\nOn Debian\n1 sudo apt remove vim On Fedora\n1 sudo dnf remove vim gvim Step 3: Configure and Compile Configure vim with features of your choice\n1 2 3 4 5 6 7 ./configure \\\\ --enable-cscope \\\\ --enable-gui=auto \\\\ --enable-gtk2-check \\\\ --enable-gnome-check \\\\ --with-features=huge \\\\ --with-x Then compile and install with:\n1 2 make sudo make install Conclusion In this article we learned how can we compile vim with clipboard support, you can also tweak configuration according to your requirements. There are many configuration options available.\n","permalink":"http://localhost:45763/personal_website/posts/how_to_compile_vim_with_clipboard_support/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eWhen you install vim, a usual requirement as with all text editors is\nthe ability to copy to/from system clipboard so you can lets say, copy\nsomething into your vim session from firefox or vice versa, however copy\npasting in terminal editors is not as straight forward as with GUI\neditors. In vim if you want to copy something into an auxilary space\n(anticipating it would be used later, so you can paste from this\nauxilary space) is achieved by \u003cstrong\u003eregisters\u003c/strong\u003e.\u003c/p\u003e","title":"How to compile vim with clipboard support"},{"content":" Introduction I had an unused phone lying around for some time, and I began contemplating how I could repurpose it. This led me to reflect on the impressive performance of modern smartphones and consider whether they could be utilized as servers.\nSmartphones are equipped with ARM-based processors and run on Android, which is itself built on the Linux kernel. ARM processors are renowned for their energy efficiency1 and have recently found applications in the server space2.\nAs someone who enjoys exploring the full potential of devices, I embarked on a journey to discover how I could leverage the full potential of smartphones.\nSetup Although, you would like to run your programs on phones, but programming on phones typing on screen is a horrifying idea. Fortunately, you dont have to type on your phone, what you can do is you can access its terminal, using protocols like ssh/telnet etc.\nSo, firstly you would need a terminal to control a machine remotely. Unfortunately, there are not, alot of choices available in phone space when it comes to terminal emulators. Termux is one of the few available options.\nAfter you manage to open a terminal remotely, then from there its pretty frictionless. You can install the software of your choice and write, compile and run your programs. You might also find it helpful to root your phone for root privilages, which will help you run all commands. But please beware that rooting can null your warrenty, check with local expert. If termux does\u0026rsquo;nt work for you then there are also other options like kali net hunter.\nSo, in total, we need to install termux, then we would setup ssh.\nTermux Termux is an open source terminal emulator for android. In essence, it provides you with a linux environment, within android, The only difference between actual linux environment and termex is that it is not FHS(File System Hierarcy) compliant, i.e. it does not strictly follow linux file system conventions. The consequences of that are that #! /usr/bin/sh may not work, so you have to watch out the paths. Other than that, it supports almost all commands on linux.\nMoreover, It is an app that does\u0026rsquo;nt interfere with your system so you can run your android as normal, moreover it runs without root privilages. It comes with a large repository of software found at packages.termux.dev.\nBelow are the steps to setup ssh in termux Step 1: Download texmux on playstore, f-droid or from github releases\nStep 2: Update using pkg:\n1 2 pkg update # update the repositories pkg upgrade # upgrade all to latest versions Run this commands\nStep 3: Install ssh 1 pkg install ssh install ssh\nStep 4: Set a password Setup a password that you will use to login\n1 passwd set password and note username\nStep 5: Note your username You will require username and ip address when logging in using ssh, hence note them. Run the command whoami the know your username. This will generally start with \u0026ldquo;a0_\u0026rdquo;\n1 whoami Step 6: Note your IP address You can check your IP address in:\n1 2 3 settings \u0026gt; Wi-Fi \u0026gt; click on the (i) button, on the wifi you are connected to and Look for IPv4 address Step 7: Run ssh doemon in termux On your phone, run the ssh daemon using\n1 sshd Step 8: Login form your computer On your computer, use the following command to login into your phone and access its terminal\n1 ssh \u0026lt;user_name\u0026gt;@\u0026lt;IP_address\u0026gt; -p 8022 The username and IP address we already determined in step 5 and 6 resp. Note that it will promt you for password\nAftermath You can use scp command to transfer files between your computer and phone. In case you want to do development, there are a number of programming packages available in termux, you can find rust, nodejs, python, C/C++ and tools for many other programming languages.\nConclusion So, now you have successfully installed ssh in your android phone. You might find it useful to install vim, git, gcc etc. There is a large repository of packages in termux, which covers pretty much everything your would need.\nFurther Reads Simili, Emanuele, et al. \u0026ldquo;Power Efficiency in HEP (x86 vs. arm).\u0026rdquo; Power (W) 350.400 (2023): 450\u0026#160;\u0026#x21a9;\u0026#xfe0e;\narm_server\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:45763/personal_website/posts/how_to_turn_your_old_smartphone_into_a_home_server/","summary":"\u003c!--\n---\ndate: '2025-07-15T22:33:11+05:30'\ndate: ''\ntitle: 'How_to_turn_your_old_smartphone_into_a_home_server'\n---\n--\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eI had an unused phone lying around for some time, and I began\ncontemplating how I could repurpose it. This led me to reflect on the\nimpressive performance of modern smartphones and consider whether they\ncould be utilized as servers.\u003c/p\u003e\n\u003cp\u003eSmartphones are equipped with ARM-based processors and run on Android,\nwhich is itself built on the Linux kernel. ARM processors are renowned\nfor their energy efficiency\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e and have recently found\napplications in the server space\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e","title":"How to turn your old smartphone into a home server"},{"content":"When nums[i] \u0026gt; nums[j], it is global inversion. Local inversion is special case of global inversion with j=i+1\nConsider the array: [0,1,2,3,4,5]\nIf i swap a random element by 2 positions (either to left or right). I will always create 2 inversions.\nLikewise, if I swap a random element by 3 positions. I end up creating 3 inversions.\nSimilarly if I swap an element by 4 positions. I end up creating 4 inversions.\nNote that for each swap made above, we created a single local inversion. This means that whever we swap 2 elements, we end up creating 1 local inversion and k global inversions. Where k means element swapped k number of positions away.\nNow, we need number of local inversions = number of global inversions. This can only happen when local inversion is itself the global inversion.\nHence, for each swap we should only create 1 inversion, THEREFORE K=1\n1 2 3 4 5 6 7 8 bool isIdealPermutation(int* nums, int numsSize) { for (int i=0; i \u0026lt; numsSize; i++) { if ( abs(nums[i]-i) \u0026gt; 1 ) return false; } return true; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_775_global_and_local_inversions_solution/","summary":"\u003cp\u003eWhen \u003ccode\u003enums[i] \u0026gt; nums[j]\u003c/code\u003e, it is global inversion. Local inversion is special case of global inversion with \u003ccode\u003ej=i+1\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eConsider the array: \u003ccode\u003e[0,1,2,3,4,5]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/2f3eb772-cc4d-4006-adec-d2937264734b_1752435521.47083.png\"\u003e\u003c/p\u003e\n\u003cp\u003eIf i swap a random element by 2 positions (either to left or right). I will always create 2 inversions.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/36424827-47b3-4fab-b464-6a02cbd9a953_1752435463.2740006.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/c9cefbb6-24e0-419e-8e4e-69178894068a_1752435700.7604558.png\"\u003e\u003c/p\u003e\n\u003cp\u003eLikewise, if I swap a random element by 3 positions. I end up creating 3 inversions.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/a5633f7f-c730-4671-8262-daed0eba9b80_1752435799.3669355.png\"\u003e\u003c/p\u003e\n\u003cp\u003eSimilarly if I swap an element by 4 positions. I end up creating 4 inversions.\u003c/p\u003e","title":"Leetcode 775: Global and local inversions solution"},{"content":"We need to divide the array nums into k subsets such that the sum of each subset is same.\n$$ k \\times sum\\ of\\ each\\ subset = total\\ sum\\ sum\\ of\\ each\\ subset = total\\ sum\\ \\div k\\ target = total\\ sum\\ \\div k $$\nNow our task is to find all the k subsets in nums whose sum is target.\nMy idea is to structure this as multi-level recursion. We first try to find the $$k^{th}$$ subset, then $$(k-1)^{th}$$, then $$(k-2)^{th} \u0026hellip;$$ until there is only one subset left. The last subset will naturally sum to target. You can only go to $$(k-1)^{th}$$ level when you are able to successfully find $$k^{th}$$ level subset,\nFor example,\n1 2 3 4 5 6 7 .. .. find the 5th subset find the 4th subset find the 3rd subset find the 2nd subset return true Seeing the recursive structure.\n1 2 3 4 5 6 7 8 9 nums = [4,3,2,3,5,2,1] k=4 target = 20 / 4 = 5 suppose you find the 4th subset as: {3,2} from [4,3,2,3,5,2,1] Now your task reduces to finding 3 subsets in [4, ,3,4,2,1] that sum to target=5 recursive call: nums=[4, ,3,4,2,1] k=3 When finding the kth subset. You can simply use pick/not pick backtracking approach. It is important to understant the distinction between same level recursion (at any given k) which operates by deciding weather to pick/drop nums@i.\nAnd the k levels recursion which succeeds/fails by checking if we can form the $$k^{th}$$ subset.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution: def __init__(self): self.nums, self.target, self.used = None, None, None def canPartitionKSubsets(self, nums: List[int], k: int) -\u0026gt; bool: self.nums = nums total = sum(self.nums) self.target = total // k self.used = [False] * len(nums) if total % k != 0: return False self.nums.sort(reverse=True) return self.bt_search(0, k, 0) def bt_search(self, i: int, k: int, cur_sum: int) -\u0026gt; bool: if k == 1: # last subset is sure to sum upto target return True if i \u0026gt;= len(self.nums) or cur_sum \u0026gt; self.target: return False if cur_sum == self.target: # current subset found, return self.bt_search(0, k-1, 0) # explore the next level of k # try picking nums@i in current subset if not self.used[i] and cur_sum + self.nums[i] \u0026lt;= self.target: self.used[i] = True # explore in same level if self.bt_search(i+1, k, cur_sum + self.nums[i]): return True self.used[i] = False # on failure, skip duplicates of nums@i while i+1 \u0026lt; len(self.nums) and self.nums[i] == self.nums[i+1]: i += 1 # do not pick nums@i -\u0026gt; explore in same level return self.bt_search(i+1, k, cur_sum) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_698_partition_to_k_equal_sum_subsets/","summary":"\u003cp\u003eWe need to divide the array \u003ccode\u003enums\u003c/code\u003e into \u003ccode\u003ek\u003c/code\u003e subsets such that the sum of each subset is same.\u003c/p\u003e\n\u003cp\u003e$$\nk \\times sum\\ of\\ each\\ subset = total\\ sum\\\nsum\\ of\\ each\\ subset = total\\ sum\\ \\div k\\\ntarget = total\\ sum\\ \\div k\n$$\u003c/p\u003e\n\u003cp\u003eNow our task is to \u003cstrong\u003efind all the \u003ccode\u003ek\u003c/code\u003e subsets in nums whose sum is \u003ccode\u003etarget\u003c/code\u003e\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eMy idea is to structure this as multi-level recursion. We first try to find the $$k^{th}$$ subset, then $$(k-1)^{th}$$, then $$(k-2)^{th} \u0026hellip;$$ until there is only one subset left. The last subset will naturally sum to \u003ccode\u003etarget\u003c/code\u003e. You can only go to $$(k-1)^{th}$$ level when you are able to successfully find $$k^{th}$$ level subset,\u003c/p\u003e","title":"Leetcode 698: Partition into k equal sum subsets: The art of recursion: mastering double recursion in a single function"},{"content":"For each possible word, we ask the question: What possible queries can lead to this word?.\nFor example consider the word: abd. Below are the possible (prefix, suffix) queries that can return abd\n1 2 3 4 5 6 7 8 9 10 (prefix, suffix) a abd a bd a d ab abd ab bd ab d abd abd abd bd abd d Now, given word.length \u0026lt;= 7. Each word can at maximum generate 7*7=49 such pairs. Can we store all of them in a hashmap? Yes, because the total storage = 49 * number of words = O(n) Which is acceptable for this problem.\nWhat if there is already a value for (prefix,suffix) in current word. Shall we override it. We need the latest index right?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class WordFilter: def __init__(self, words: List[str]): self.map = {} for widx, w in enumerate(words): for i in range( len(w) ): prefix = w[:i+1] for j in range( len(w) ): suffix = w[j:] # for all possible prefix suffix queries that might route # to current word. We set it in dictionary overriding previously # inserted values to get the maximum index key = prefix + \u0026#39;|\u0026#39; + suffix self.map[key] = widx def f(self, pref: str, suff: str) -\u0026gt; int: key = pref + \u0026#39;|\u0026#39; + suff return self.map.get(key, -1) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_745_prefix_and_suffix_search_solution/","summary":"\u003cp\u003eFor each possible word, we ask the question: \u003cstrong\u003eWhat possible queries can lead to this word?\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor example consider the word: \u003ccode\u003eabd\u003c/code\u003e. Below are the possible (prefix, suffix) queries that can return \u003ccode\u003eabd\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(prefix, suffix)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    d\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  d\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  d\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eNow, given word.length \u0026lt;= 7. Each word can at maximum generate \u003ccode\u003e7*7=49\u003c/code\u003e such pairs. Can we store all of them in a hashmap? Yes, because the total storage = \u003ccode\u003e49 * number of words = O(n)\u003c/code\u003e Which is acceptable for this problem.\u003c/p\u003e","title":"Leetcode 745: prefix and suffix search solution"},{"content":"This problem is very similar to lc543, which is about finding the longest edge path in a tree. You can just copy over that code, and add 2 lines in it.\nHere we are doing the same thing as in lc543, however, when we encounter a non-matching child. We treat it as null.\nFor example, here the longest path at root node is highlighted below in red with 6 edges.\nOur algorithm views the tree like this. The longest path of 3 edges is highlighted in red.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int edges( struct TreeNode* node ); int longest_path; int longestUnivaluePath(struct TreeNode* root) { longest_path = 0; edges(root); return longest_path; } int edges( struct TreeNode* node ) { if ( !node ) return -1; int left = edges(node-\u0026gt;left), right = edges(node-\u0026gt;right); // treat child as null if it doesn\u0026#39;t match parent left = (node-\u0026gt;left \u0026amp;\u0026amp; node-\u0026gt;val == node-\u0026gt;left-\u0026gt;val) ? left : -1; right = (node-\u0026gt;right \u0026amp;\u0026amp; node-\u0026gt;val == node-\u0026gt;right-\u0026gt;val) ? right : -1; longest_path = fmax(longest_path, 1+left + 1+right); return 1 + fmax( left, right); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution: def __init__(self): self.ans = 0 def longestUnivaluePath(self, root: Optional[TreeNode]) -\u0026gt; int: self.edges( root ) return self.ans def edges(self, node: Optional[TreeNode]) -\u0026gt; int: if not node: return -1 left, right = self.edges( node.left ), self.edges( node.right ) # if the child is illegitimate. Discard it if not node.left or node.left.val != node.val: left = -1 # treat as null if not node.right or node.right.val != node.val: right = -1 self.ans = max( self.ans, ( 1+left ) + ( 1 + right ) ) return 1 + max( left, right ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function longestUnivaluePath(root: TreeNode | null): number { let ans = 0; const edges = ( node: TreeNode|null ): number =\u0026gt; { if ( !node ) return -1; let left = edges( node.left ), right = edges( node.right ); // if child value doesn\u0026#39;t match -\u0026gt; treat as null left = (node.left \u0026amp;\u0026amp; node.val == node.left.val) ? left : -1; right = (node.right \u0026amp;\u0026amp; node.val == node.right.val) ? right : -1; ans = Math.max( ans, (1 + left) + (1 + right) ); return 1 + Math.max( left, right ); } edges( root ); return ans; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function longestUnivaluePath(root) { let ans = 0; const edges = ( node ) =\u0026gt; { if ( !node ) return -1; let left = edges( node.left ), right = edges( node.right ); // if child value doesn\u0026#39;t match -\u0026gt; treat as null left = (node.left \u0026amp;\u0026amp; node.val == node.left.val) ? left : -1; right = (node.right \u0026amp;\u0026amp; node.val == node.right.val) ? right : -1; ans = Math.max( ans, (1 + left) + (1 + right) ); return 1 + Math.max( left, right ); } edges( root ); return ans; }; ","permalink":"http://localhost:45763/personal_website/posts/solution_to_leetcode_687_longest_univalue_path/","summary":"\u003cp\u003eThis problem is very similar to\n\u003ca href=\"https://leetcode.com/problems/diameter-of-binary-tree/solutions/6824338/solution-for-dummies-by-abdulrahim2002-yzrs/\"\u003elc543\u003c/a\u003e,\nwhich is about finding the longest edge path in a tree. You can just\ncopy over that code, and add 2 lines in it.\u003c/p\u003e\n\u003cp\u003eHere we are doing the same thing as in lc543, however, when we encounter a non-matching child. We treat it as null.\u003c/p\u003e\n\u003cp\u003eFor example, here the longest path at root node is highlighted below in red with 6 edges.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/148ffbfd-0ead-48cd-b45d-8c2575bafd11_1751999234.494938.png\"\u003e\u003c/p\u003e","title":"Solution to Leetcode 687: Longest Univalue Path"},{"content":"I keep track of the top k elements in sorted list. The kth largest element is the smallest of the top k elements.\ne.g. top k(=6) elements: [3,5,7,10,42,56] in sorted order. The kth largest element = 6th largest element = smallest element in above list.\nWhen I insert an element, I simply check if it can make it\u0026rsquo;s place among k largest elements already present in the list. Which it can, if it can defeat the smallest element in our list.\nFor example, we cannot add 2 in the array above since it fails to defeat 3.\nHowever, A number like 15 can be inserted. In which case, we remove the smallest element i.e. 3, to keep the list length=k\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class KthLargest: def __init__(self, k: int, nums: List[int]): self.scores = SortedList() self.limit = k for num in nums: self.add(num) def add(self, val: int) -\u0026gt; int: # if the current element can make space in top k elements if len(self.scores) \u0026lt; self.limit or self.scores[0] \u0026lt; val: self.scores.add(val) # remove smallest if len(self.scores) \u0026gt; self.limit: self.scores.pop(0) # return smallest return self.scores[0] ","permalink":"http://localhost:45763/personal_website/posts/leetcode_703_kth_largest_element_in_a_stream/","summary":"\u003cp\u003eI keep track of the top k elements in sorted list.\nThe kth largest element is the \u003cstrong\u003esmallest of the top k elements\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003ee.g. top k(=6) elements: \u003ccode\u003e[3,5,7,10,42,56]\u003c/code\u003e in sorted order.\nThe kth largest element = 6th largest element = smallest element in above list.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/070564ea-afa3-4108-92e6-7fa76c2fb981_1752504996.0140414.png\"\u003e\u003c/p\u003e\n\u003cp\u003eWhen I insert an element, I simply check if it can make it\u0026rsquo;s place among k largest elements already present in the list. Which it can, if it can defeat the smallest element in our list.\u003c/p\u003e","title":"Leetcode 703: kth largest element in a stream solution in python"},{"content":"When numbers from $$\\in$$ [0,n-1] are sorted in an array of size n. Their sorted position is equal to their index.\nSubset of numbers in array[i:j] can form a partition, if all elements in [i,j) are available in array[i:j].\nFor example [2,0,1] can form a partition, since they are at index 0, 1, 2 respectively. Sorted will involving swapping them at their correct position.\nThe basic idea behind this solution is that we try to identify such partitions, where all elements required to be sorted in [i, j] are available in current partition.\nHere\u0026rsquo;s the visualization of the algorithm, i points to the start of the group and j iterates through the group and checks if the current group needs to be expanded. e points to the end of the current group.\nSince, array[j]=1, we found a number greater than current boundaries. We need to expand the boundary. Hence, new group end is e = array[j].\nIncrement j. We find that array[1] = 0 which is \u0026lt; current end. Increment j again, j=2, Hence, no we exhaust the current group and we move forward to finding the next partition. Increase, current group ending, and reinitialize i=e/\nIn the second group, we have array[j]=2 and we are at index 2. Hence, we do not need to expand this group, since 2 is at right position.\nSimilarly we find the next 2 partitions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int maxChunksToSorted(int* arr, int arrSize) { int cur_gp_end = 0, cnt_gps = 0, i = 0; while ( i \u0026lt; arrSize ) { int j = i; // try to terminate the current group while ( j \u0026lt;= cur_gp_end ) { cur_gp_end = fmax( cur_gp_end, arr[j] ); j++; } i = ++cur_gp_end; cnt_gps++; } return cnt_gps; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_769_max_chunks_to_make_sorted/","summary":"\u003cp\u003eWhen numbers from $$\\in$$ \u003ccode\u003e[0,n-1]\u003c/code\u003e are sorted in an array of size n. Their sorted position is equal to their index.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/07a3b1d2-9478-486f-9f62-3a67e6dde1b3_1752513551.205261.png\"\u003e\u003c/p\u003e\n\u003cp\u003eSubset of numbers in \u003ccode\u003earray[i:j]\u003c/code\u003e can form a partition, if all elements in \u003ccode\u003e[i,j)\u003c/code\u003e are available in \u003ccode\u003earray[i:j]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFor example \u003ccode\u003e[2,0,1]\u003c/code\u003e can form a partition, since they are at index \u003ccode\u003e0, 1, 2\u003c/code\u003e respectively. Sorted will involving swapping them at their correct position.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/77d9235f-d72a-416a-bd77-d8802d7567b0_1752513786.651974.png\"\u003e\u003c/p\u003e\n\u003cp\u003eThe basic idea behind this solution is that we try to identify such partitions, where all elements required to be sorted in \u003ccode\u003e[i, j]\u003c/code\u003e are available in current partition.\u003c/p\u003e","title":"Leetcode 769: Max chunks to make sorted solution"},{"content":"For each word, we basically store all versions of it after removal of 1 character. For example,\n1 2 3 4 5 6 hello -\u0026gt; ello -\u0026gt; removed h@0 hllo -\u0026gt; removed e@1 helo -\u0026gt; removed l@2 helo -\u0026gt; removed l@3 hell -\u0026gt; removed o@4 We can store: wordAfterRemoval,indexOfRemoval in hashmap. So whenever we search for a word like: hexlo then we can try removing it\u0026rsquo;s 2nd index and search: helo,2 in the map, which we will find.\nIn the value we can store the removed character. For example, store key=helo,2 with value=l to indicate that l was removed.\nSo when you match a word like hexlo. Try to search helo,2 in the hashmap. It gives value=l which is !='x' i.e. the removed character in hexlo.\nHowever, there is one problem with this approach. When you add 2 words like: hello and hallo in the map. Then hllo,1 will give e in the first insertion and a in the second. The second overides the first so hello is forgetten by the structure. To avoid this issue, we store both of them (e, a) in a list.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class MagicDictionary { private map = new Map\u0026lt;string,string[]\u0026gt;(); buildDict(dictionary: string[]): void { for ( const word of dictionary ) { for ( let i=0; i \u0026lt; word.length; i++ ) { const wordAfterRemoval = word.slice(0, i) + word.slice(i+1); // key stores wordAfterRemoval,indexOfRemoval as value const key = `${wordAfterRemoval},${i}`; if ( !this.map.has(key) ) this.map.set(key,[]); // values have the removed character this.map.get(key).push( word[i] ) } } } search(word: string): boolean { for ( let i=0; i \u0026lt; word.length; i++ ) { const wordAfterRemoval = word.slice(0, i) + word.slice(i+1); const key = `${wordAfterRemoval},${i}`; if ( !this.map.has(key) ) continue; const removedChars = this.map.get(key); // If there was a word with removed character != word[i] for ( let j=0; j \u0026lt; removedChars.length; j++ ) { if ( removedChars[j] !== word[i] ) return true; } } return false; } } You can also embed the index information by replacing the removed word with _ like in this pyton version:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class MagicDictionary: def __init__(self): self.map = {} def buildDict(self, dictionary: List[str]) -\u0026gt; None: for word in dictionary: for i in range(len(word)): key = word[0:i] + \u0026#39;_\u0026#39; + word[i+1:] if not key in self.map: self.map[key] = [] self.map[key].append(word[i]) def search(self, searchWord: str) -\u0026gt; bool: for i in range(len(searchWord)): key = searchWord[0:i] + \u0026#39;_\u0026#39; + searchWord[i+1:] if key not in self.map: continue for c in self.map[key]: if c != searchWord[i]: return True return False # Your MagicDictionary object will be instantiated and called as such: # obj = MagicDictionary() # obj.buildDict(dictionary) # param_2 = obj.search(searchWord) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_676_magic_dictionary/","summary":"\u003cp\u003eFor each word, we basically store all versions of it after removal of 1 character. For example,\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehello -\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eello -\u0026gt; removed h@0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehllo -\u0026gt; removed e@1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehelo -\u0026gt; removed l@2\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehelo -\u0026gt; removed l@3\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehell -\u0026gt; removed o@4\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eWe can store: \u003ccode\u003ewordAfterRemoval,indexOfRemoval\u003c/code\u003e in hashmap. So whenever we search for a word like: \u003ccode\u003ehexlo\u003c/code\u003e then we can try removing it\u0026rsquo;s 2nd index and search: \u003ccode\u003ehelo,2\u003c/code\u003e in the map, which we will find.\u003c/p\u003e","title":"Leetcode 676: magic dictionary"},{"content":"consider the word \u0026ldquo;catsdogcats\u0026rdquo;. We have the dictionary: [\u0026quot;cat\u0026quot;,\u0026quot;cats\u0026quot;,\u0026quot;catsdogcats\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;dogcatsdog\u0026quot;,\u0026quot;hippopotamuses\u0026quot;,\u0026quot;rat\u0026quot;,\u0026quot;ratcatdogcat\u0026quot;]\nWe iterate over the word: catsdogcats and at each iteration, we ask if the prefix is contained in dictionary.\nIf the prefix is in the dictionary, we recursively call the function on the remaining word (excluding matched prefix)\nis c in dictionary ? is ca in dictionary ? is cat in dictionary ? -\u0026gt; YES call( sdogcats ) \u0026ndash;[1] Prefix cat matched so recursively call with sdogcats\nis s in dictionary ? is sd in dictionary ? \u0026hellip;. is sdogcats in dictionary ? NO We exhausted the word so we return false. Nothing was matched\nBack at the first call, this time we try to match cats Return to [1]\nis cats in dictionary -\u0026gt; YES recursively call on dogcats\nis d in dictionary ?\nis do in dictionary ?\nis dog in dictionary ? -\u0026gt; YES, recursively call on cats\nis c in dictionary ?\nis ca in dictionary ?\nis cat in dictionary ? YES , recursively call(s) \u0026ndash;[2]\nis s in dictionary ? NO -\u0026gt; word exhausted, return false;\nBack at recursive call [2]\nis cats in dictionary ? YES recursively call(``) i.e. empty string When we reach empty string, it means whole of string can be constructed using words in dictionary. Hence return true.\nImport considerations:\nThe dictionary has all the words, which means that catsdogcats will match with itself completely. To avoid words matching with themselves, we tell the function to ignore the catsdogcats word to avoid matching it with itself. Also, we can memoize the results since, dictionary remains the same, only target word and ignore word changes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function findAllConcatenatedWordsInADict(words: string[]): string[] { const dict = new Set\u0026lt;string\u0026gt;( words ); return words.filter( curWord =\u0026gt; canChunk( curWord, curWord, dict ) ); }; function canChunk( target: string, ignore: string, dict: Set\u0026lt;string\u0026gt;, memo = new Map\u0026lt;string, boolean\u0026gt;() ): boolean { if ( !target.length ) return true; const key = target + ignore; if ( memo.has( key ) ) return memo.get( key ); for ( let i=1; i \u0026lt;= target.length; i++ ) { const prefix = target.slice( 0, i ); if ( prefix !== ignore \u0026amp;\u0026amp; dict.has( prefix ) \u0026amp;\u0026amp; canChunk( target.slice( i ), ignore, dict, memo ) ) { memo.set( key, true ); return true; } } memo.set( key, false ); return false; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_472_concatenated_words/","summary":"\u003cp\u003econsider the word \u0026ldquo;catsdogcats\u0026rdquo;. We have the dictionary: \u003ccode\u003e[\u0026quot;cat\u0026quot;,\u0026quot;cats\u0026quot;,\u0026quot;catsdogcats\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;dogcatsdog\u0026quot;,\u0026quot;hippopotamuses\u0026quot;,\u0026quot;rat\u0026quot;,\u0026quot;ratcatdogcat\u0026quot;]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWe iterate over the word: \u003ccode\u003ecatsdogcats\u003c/code\u003e and at each iteration, we ask if the prefix is contained in dictionary.\u003c/p\u003e\n\u003cp\u003eIf the prefix is in the dictionary, we recursively call the function on the remaining word (excluding matched prefix)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eis \u003ccode\u003ec\u003c/code\u003e in dictionary ?\u003c/li\u003e\n\u003cli\u003eis \u003ccode\u003eca\u003c/code\u003e in dictionary ?\u003c/li\u003e\n\u003cli\u003eis \u003ccode\u003ecat\u003c/code\u003e in dictionary ? -\u0026gt; YES       call( \u003ccode\u003esdogcats\u003c/code\u003e ) \u0026ndash;[1]\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePrefix \u003ccode\u003ecat\u003c/code\u003e matched so recursively call with \u003ccode\u003esdogcats\u003c/code\u003e\u003c/p\u003e","title":"Leetcode 472: Concatenated words"},{"content":"The task is to find a subarray with sum of elements = k\nTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\nThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\n$$ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k] $$\nNow we are looking for sub of subarray = T(target). Therefore:\n$$ sum\\ of\\ subarray = prefix\\ [j]\\ -\\ prefix\\ [i-1] = T\\ \\ prefix\\ [i-1] = prefix\\ [j]\\ - T $$\nTherefore, we iterate the prefix array. And at each prefix[j], we search for a previously inserted prefix[i-1] such that prefix[i-1] = prefix[j] - T. We also need the count of such subarrays. At a particular j the number of subarrays where sum=T is the number of i that occured previously such that prefix[i-1] = prefix[j] - T. Index j will form a subarray with each of such previous i\u0026rsquo;s.\nWe must store the mapping: ( prefix[x], count ) in a map.\nSo far so good. But what happens when $$i=0$$. In this case, sum of subarray between indices [0, j] is defined as:\n$$ prefix\\ [j] = \\sum_{k=0}^j nums\\ [k] = T $$\nAt each index j, the code will try to look for prefix[j] - T in the map. When prefix[j]=T itself, then it would look for T-T=0 into the map. Therefore we must keep prefix= 0, count= 1 into the map to account for subarrays starting at index 0.\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 function subarraySum(nums: number[], k: number): number { const map = new Map\u0026lt;number, number\u0026gt;([ [0, 1] ]); let sumk = 0; for ( let j=0; j \u0026lt; nums.length; j++ ) { nums[j] = ( j==0 ) ? nums[j] : nums[j-1] + nums[j]; sumk += map.get( nums[j] - k ) ?? 0; map.set( nums[j], ( map.get(nums[j]) ?? 0 ) + 1 ); } return sumk; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_560_subarray_sub_equal_k_solution/","summary":"\u003cp\u003eThe task is to find a subarray with \u003ccode\u003esum of elements = k\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\u003c/p\u003e\n\u003cp\u003eThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\u003c/p\u003e\n\u003cp\u003e$$\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k]\n$$\u003c/p\u003e","title":"Leetcode 560: Subarray sum equals k"},{"content":"Consider the array: [0,1,1,0,0,1,1,0,1,1] The idea is to turn the 0\u0026rsquo;s into -1\u0026rsquo;s\narray: [-1,1,1,-1,-1,1,1,-1,1,1]\nNow, the task is to find a subarray with sum of elements = 0\nTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\nThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\n$$ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k] $$\nAnd the length of the subarray between indices $$[i,j]$$ is defined as: $$length(i,j) = j-i+1 = j-(i-1) $$\nNow we are looking for sub of subarray = 0. Therefore:\n$$ sum\\ of\\ subarray = prefix\\ [j]\\ -\\ prefix\\ [i-1] = 0\\ prefix\\ [j]\\ =\\ prefix\\ [i-1] $$\nTherefore, we iterate the prefix array. And at each prefix[j], we search for a previously inserted prefix[i-1] such that prefix[j]=prefix[i-1]. We record the length of the current subarray as: length = j-(i-1).\nWe must store the mapping: ( prefix[k], k ) in a map to achieve this.\nSo far so good. But what happens when $$i=0$$. In this case, sum of subarray between indices [0, j] is defined as:\n$$ prefiix\\ [j] = \\sum_{k=0}^j nums\\ [k] $$\nAnd the length of the subarray [0,j] is: $$j+1 = j-(-1)$$\nTherefore we keep a superficial (prefix = 0, index = -1) in the map.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function findMaxLength(nums: number[]): number { const map = new Map\u0026lt;number, number\u0026gt;( [ [0, -1], ] ); let maxLen = 0; for ( let j=0; j \u0026lt; nums.length; j++ ) { let cur = ( nums[j] == 1 ) ? 1 : -1; nums[j] = ( j==0 ) ? cur : cur + nums[j-1]; // prefix sum occured previously at i. Length = j-i if ( map.has( nums[j] ) ) { let i = map.get( nums[j] ); maxLen = Math.max( maxLen, j - i ); } // put the current prefix sum into map if ( !map.has( nums[j] ) ) map.set( nums[j], j ); } return maxLen; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_525_contiguous_array/","summary":"\u003cp\u003eConsider the array: \u003ccode\u003e[0,1,1,0,0,1,1,0,1,1] \u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe idea is to turn the 0\u0026rsquo;s into -1\u0026rsquo;s\u003c/p\u003e\n\u003cp\u003earray: \u003ccode\u003e[-1,1,1,-1,-1,1,1,-1,1,1]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eNow, the task is to find a subarray with \u003ccode\u003esum of elements = 0\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\u003c/p\u003e\n\u003cp\u003eThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\u003c/p\u003e\n\u003cp\u003e$$\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k]\n$$\u003c/p\u003e","title":"Leetcode_525_contiguous_array"},{"content":"The idea is to keep 2 pointers. trail pointer and cur pointer. The list is build in recursive function build(trail, cur) which returns last node of the list we build.\nbuild works as follows:\nwhen there is no child node: simply connect trail and cur and advance both when there is a child node, then recursively call itself with build( trail = cur, cur = cur.child ). The call would connect cur node with the list in the next level. It would return the last node in next level. Then we assign trail = last node in next level and cur = cur.next in current level. This ensures that the next iteration would connect last node in next level to next node in current level. when cur becomes null trail is the last node in current level. return trail Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function flatten(head: _Node | null): _Node | null { const save: _Node = new _Node( -1 ); build( save, head ); if ( save.next ) save.next.prev = null; return save.next; }; function build( trail: _Node | null, cur: _Node | null ): _Node | null { while ( cur ) { if ( !cur.child ) { trail.next = cur; cur.prev = trail; trail = trail.next; cur = cur.next; } else { trail.next = cur; cur.prev = trail; const saveNext = cur.next; const lastNodeFromChildList = build( cur, cur.child ); cur.child = null; cur = saveNext; trail = lastNodeFromChildList; } } return trail; } Complexity Time complexity: $$O(n)$$\nSpace complexity: $$O(n)$$ {recursion stack}\n","permalink":"http://localhost:45763/personal_website/posts/leetcode_430_flattening_multilevel_linked_list/","summary":"\u003cp\u003eThe idea is to keep 2 pointers. \u003ccode\u003etrail\u003c/code\u003e pointer and \u003ccode\u003ecur\u003c/code\u003e pointer. The\nlist is build in recursive function \u003ccode\u003ebuild(trail, cur)\u003c/code\u003e which returns\nlast node of the list we build.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebuild\u003c/code\u003e works as follows:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ewhen there is no \u003ccode\u003echild\u003c/code\u003e node: simply connect \u003ccode\u003etrail\u003c/code\u003e and \u003ccode\u003ecur\u003c/code\u003e and advance both\u003c/li\u003e\n\u003cli\u003ewhen there is a \u003ccode\u003echild\u003c/code\u003e node, then recursively call itself with \u003ccode\u003ebuild( trail = cur, cur = cur.child )\u003c/code\u003e. The call would connect \u003ccode\u003ecur\u003c/code\u003e node with the \u003ccode\u003elist in the next level\u003c/code\u003e. It would return the last node in next level. Then we assign \u003ccode\u003etrail = last node in next level\u003c/code\u003e and \u003ccode\u003ecur = cur.next in current level\u003c/code\u003e. This ensures that the next iteration would connect \u003ccode\u003elast node in next level\u003c/code\u003e to \u003ccode\u003enext node in current level\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003ewhen \u003ccode\u003ecur\u003c/code\u003e becomes \u003ccode\u003enull\u003c/code\u003e \u003ccode\u003etrail\u003c/code\u003e is the last node in current level. \u003ccode\u003ereturn trail\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"code\"\u003eCode\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003eflatten\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ehead\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kr\"\u003econst\u003c/span\u003e   \u003cspan class=\"nx\"\u003esave\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ehead\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003esaveNext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003elastNodeFromChildList\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003esaveNext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003elastNodeFromChildList\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"complexity\"\u003eComplexity\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTime complexity:  $$O(n)$$\u003c/p\u003e","title":"Leetcode 430: Flattening a multilevel linked list"},{"content":"Below is my solution for the leetcode 154: Find minimum in rotated sorted array problem\nIntuition Fact is, that you cannot solve this question in O(log n) time. The reason is because of duplicates.\nConsider a situation like:\n$$ [2,2,2,2,1,2,2] $$\nwhere mid is at 3 and the minium number here is clearly $$1$$. But our binary search algorithm will not be able to figure out in which direction it should go, since starting, ending and middle values are all same. In this case the best we can do is increment mid which makes the worst running time: O(n)\nHowever, it is possible to solve this problem in O(n/2) as explain below.\nApproach We will make use of the fact that a sorted array follows the (min) heap property i.e. in a sorted array, at all parent nodes are smaller than their children.\nAnd if this sorted array is rotated, then the place at which the first violation occurs is the subtree where the answer will be found.\nComplexity Time complexity: $$O(n/2)$$ Space complexity: $$O(1)$$ Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 var findMin = function(a) { /** Approach: You cannot solve this problem in O(log n) since it contains duplicate values. But you can actually solve this problem in O(n/2) by using the fact that a sorted array follows heap property. And if a sorted array is rotated then the heap property no longer holds. to find the minium element traverse the array, and find the first subtree where the heap property does not hold. the minium of the 2 values where the heap property does not satisfy is also minium in the array. Time: O(n/2) Space: O(1) */ let A = a.length; let i = 0; while ( i \u0026lt;= Math.floor(A/2)-1 ) { let root = i; let lc = 2*i + 1; let rc = 2*i + 2; let smallest = root; if ( lc \u0026lt; A \u0026amp;\u0026amp; a[lc] \u0026lt; a[smallest] ) smallest = lc; if ( rc \u0026lt; A \u0026amp;\u0026amp; a[rc] \u0026lt; a[smallest] ) smallest = rc; if ( smallest != root ) /* violation found. the value at smallest is minium */ return a[smallest]; i++; } /* no violation found. Either the array is sorted ar there it is all duplicates, in either case, return the first element. */ return a[0]; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_154_find_minimum_in_rotated_sorted_array/","summary":"\u003cp\u003eBelow is my solution for the \u003ca href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/\"\u003eleetcode 154: Find minimum in rotated\nsorted array problem\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"intuition\"\u003eIntuition\u003c/h1\u003e\n\u003c!-- Describe your first thoughts on how to solve this problem. --\u003e\n\u003cp\u003eFact is, that you \u003cstrong\u003ecannot\u003c/strong\u003e solve this question in \u003cstrong\u003eO(log n)\u003c/strong\u003e time. The reason is because of duplicates.\u003c/p\u003e\n\u003cp\u003eConsider a situation like:\u003c/p\u003e\n\u003cp\u003e$$\n[2,2,2,2,1,2,2]\n$$\u003c/p\u003e\n\u003cp\u003ewhere mid is at 3 and the minium number here is clearly $$1$$. But our binary search algorithm will not be able to figure out in which direction it should go, since starting, ending and middle values are all same. In this case the best we can do is increment mid which makes the worst running time: \u003cstrong\u003eO(n)\u003c/strong\u003e\u003c/p\u003e","title":"Leetcode 154: Find minimum in rotated sorted array"},{"content":"Here\u0026rsquo;s my solution to the Leetcode 315: Count of Smaller Numbers After Self problem using standard merge sort. I just change one line to count while merge procedure.\nSolution Let\u0026rsquo;s build the solution step by step.\nInput: nums = $$[5,2,6,1]$$\nFirst, turn the numbers into [number, index] tuple. So it looks like:\narray = $$ [ [ 5, 0 ], [ 2, 1 ], [ 6, 2 ], [ 1, 3 ] ] $$\nSecond, just write standard merge sort algorithm and sort the array in ascending order by first values.\nThe output is: $$ [ [ 1, 3 ], [ 2, 1 ], [ 5, 0 ], [ 6, 2 ] ] $$\nHere\u0026rsquo;s the trace of the algorithm:\nSimple merge sort implemented 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { tmp.push( a[j] ); j++; } else { tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); merge_sort( array, 0, array.length-1 ); }; So far so good.\nNow let\u0026rsquo;s get back to the question. The question is asking: For each index $$i$$, count all numbers at index $$j$$ such that $$i \u0026lt; j$$ and $$a[i] \u0026gt; a[j]$$. Or, simply put: for each number, find all numbers that appear after it and are smaller than it.\nNow, look at the visualization again, pay attention to the merge procedure (in magenta colour) and observe the following:\nat each merge procedure, we merge 2 consecutive partitions. all numbers in the left partition appear before numbers in right partition in the original array. The partitions are sorted in increasing order. Now, suppose we are merging 2 partitions where, the pointer of left partition is at $$x$$ and pointer of right partition is at $$y$$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [....a,b,c, x ,d,e,f....] [...h,i,j, y, k,l,m....] ^ ^ i j Suppose x \u0026gt; y It follows from observation 2 that: y is one of the numbers that appear to the right of x and is smaller than x ---(1) Also, since partitions are sorted (observation 3): d, e, f .... (i.e. all number that appear to the right of x) are greater than x. ----(2) From (1) and (2) we can conclude that: x, d, e, f, ... (i.e. all numbers to the right of x including x) appear before y. And y is smaller than all these numbers. Hence, required condition satisfied! Now, we just need a counter for each variable, and whenever the condition same as above occurs, we increment the counter for each x,d,e,\u0026hellip;\n1 2 3 4 5 6 7 [....a,b,c, x ,d,e,f....] [...h,i,j, y, k,l,m....] ^ ^ i j while merging: if x \u0026gt; y increment the counters of x, d, e, f, ... Single line changed in standard merge sort algorithm We can use the index at the second position to access the counter of that particular number.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 let counts; const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { /* ____(x \u0026gt; y) so increment counters of x,d,e,...____*/ for ( let p=i; p\u0026lt;=mid; p++ ) counts[ a[p][1] ]++; /*_______________INSERT THIS LINE_____________________*/ tmp.push( a[j] ); j++; } else { tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); counts = new Array(nums.length).fill(0); merge_sort( array, 0, array.length-1 ); return counts; }; That is the whole idea behind this question. Now the above implementation won\u0026rsquo;t work because at each iteration, we are updating whole left partition after i. Making it O(n^2) Optimize To avoid updating the whole partition, we keep a running counter cnt.\nFinal implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 let counts; const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; let cnt = 0; // keep running counter while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { cnt++; // increment counter tmp.push( a[j] ); j++; } else { counts[ a[i][1] ] += cnt; // no more numbers that are // smaller than i tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { counts[ a[i][1] ] += cnt; // if left partition is not over // update left over number counts tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); counts = nums; counts.fill(0); merge_sort( array, 0, array.length-1 ); return counts; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def countSmaller(nums): counts = [0] * len(nums) array = [(num, i) for i, num in enumerate(nums)] def merge_sort(start, end): if start == end: return mid = (start + end) // 2 merge_sort(start, mid) merge_sort(mid + 1, end) merge(start, mid, end) def merge(start, mid, end): temp = [] i, j = start, mid + 1 cnt = 0 while i \u0026lt;= mid and j \u0026lt;= end: if array[i][0] \u0026gt; array[j][0]: cnt += 1 temp.append(array[j]) j += 1 else: counts[array[i][1]] += cnt temp.append(array[i]) i += 1 while i \u0026lt;= mid: counts[array[i][1]] += cnt temp.append(array[i]) i += 1 while j \u0026lt;= end: temp.append(array[j]) j += 1 for i in range(len(temp)): array[start + i] = temp[i] merge_sort(0, len(nums) - 1) return counts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; countSmaller(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; counts(nums.size(), 0); vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; array; for (int i = 0; i \u0026lt; nums.size(); i++) { array.emplace_back(nums[i], i); } function\u0026lt;void(int, int)\u0026gt; merge_sort = [\u0026amp;](int start, int end) { if (start == end) return; int mid = start + (end - start) / 2; merge_sort(start, mid); merge_sort(mid + 1, end); merge(start, mid, end); }; function\u0026lt;void(int, int, int)\u0026gt; merge = [\u0026amp;](int start, int mid, int end) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; temp; int i = start, j = mid + 1; int cnt = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end) { if (array[i].first \u0026gt; array[j].first) { cnt++; temp.push_back(array[j]); j++; } else { counts[array[i].second] += cnt; temp.push_back(array[i]); i++; } } while (i \u0026lt;= mid) { counts[array[i].second] += cnt; temp.push_back(array[i]); i++; } while (j \u0026lt;= end) { temp.push_back(array[j]); j++; } for (int k = 0; k \u0026lt; temp.size(); k++) { array[start + k] = temp[k]; } }; merge_sort(0, nums.size() - 1); return counts; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import java.util.*; class Solution { private int[] counts; private int[][] array; public List\u0026lt;Integer\u0026gt; countSmaller(int[] nums) { counts = new int[nums.length]; array = new int[nums.length][2]; for (int i = 0; i \u0026lt; nums.length; i++) { array[i][0] = nums[i]; array[i][1] = i; } mergeSort(0, nums.length - 1); List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (int count : counts) { result.add(count); } return result; } private void mergeSort(int start, int end) { if (start == end) return; int mid = start + (end - start) / 2; mergeSort(start, mid); mergeSort(mid + 1, end); merge(start, mid, end); } private void merge(int start, int mid, int end) { List\u0026lt;int[]\u0026gt; temp = new ArrayList\u0026lt;\u0026gt;(); int i = start, j = mid + 1; int cnt = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end) { if (array[i][0] \u0026gt; array[j][0]) { cnt++; temp.add(array[j]); j++; } else { counts[array[i][1]] += cnt; temp.add(array[i]); i++; } } while (i \u0026lt;= mid) { counts[array[i][1]] += cnt; temp.add(array[i]); i++; } while (j \u0026lt;= end) { temp.add(array[j]); j++; } for (int k = 0; k \u0026lt; temp.size(); k++) { array[start + k] = temp.get(k); } } } Time: $$O(n\\ log\\ n)$$ Space: $$O(n)$$ ","permalink":"http://localhost:45763/personal_website/posts/leetcode_315_count_of_smaller_numbers_after_self/","summary":"\u003cp\u003eHere\u0026rsquo;s my solution to the \u003ca href=\"https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/\"\u003eLeetcode 315: Count of Smaller Numbers After\nSelf problem\u003c/a\u003e using standard merge sort. I just change one line to\ncount while merge procedure.\u003c/p\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\n\u003cp\u003eLet\u0026rsquo;s build the solution step by step.\u003c/p\u003e\n\u003cp\u003eInput: nums = $$[5,2,6,1]$$\u003c/p\u003e\n\u003cp\u003eFirst, turn the numbers into \u003cstrong\u003e[number, index]\u003c/strong\u003e tuple. So it looks like:\u003c/p\u003e\n\u003cp\u003earray = $$ [ [ 5, 0 ], [ 2, 1 ], [ 6, 2 ], [ 1, 3 ] ] $$\u003c/p\u003e","title":"Leetcode 315: Count of Smaller Numbers After Self"},{"content":"Here\u0026rsquo;s my explanation for the leetcode 306: Additive Number problem\nAdditive Number Problem Problem Recap An additive number is a string of digits where the sequence of numbers formed by splitting the string satisfies the condition that each number (after the first two) is the sum of the two preceding numbers.\nExamples: \u0026quot;112358\u0026quot; is additive because the sequence is 1, 1, 2, 3, 5, 8, and:\n1 + 1 = 2 1 + 2 = 3 2 + 3 = 5 3 + 5 = 8 \u0026quot;199100199\u0026quot; is additive because the sequence is 1, 99, 100, 199, and:\n1 + 99 = 100 99 + 100 = 199 Solution Approach The solution uses a backtracking approach to try all possible splits of the string into sequences of numbers and checks if any of these sequences form an additive sequence.\nDetailed Explanation Helper Function isValid This recursive function checks if the remaining part of the string s forms a valid additive sequence given the first two numbers a and b.\nBase Case: If the remaining string s is empty, it means we\u0026rsquo;ve successfully formed an additive sequence, so return true.\nRecursive Step:\nCompute the sum of a and b and convert it to a string sum. Check if the remaining string s starts with sum: If not, the sequence is invalid  return false. If yes, recursively check the next part of the string with the new pair (b, sum) and the remaining string after removing sum. Main Function isAdditiveNumber Initialization: Get the length of the input string num. Nested Loops: The outer loop (i) determines the end index of the first number a (from index 0 to i). The inner loop (j) determines the end index of the second number b (from index i to j). Leading Zero Check: Skip any splits where a or b have leading zeros unless they are exactly \u0026quot;0\u0026quot;. Example: \u0026quot;02\u0026quot; is invalid, but \u0026quot;0\u0026quot; is valid. Validation: For each valid pair (a, b), call isValid to check if the remaining part of the string forms a valid additive sequence starting with a and b. If isValid returns true, immediately return true from the main function. Final Check: If no valid sequence is found after all possible splits, return false. Example Walkthrough Let\u0026rsquo;s walk through the example num = \u0026quot;112358\u0026quot;:\nFirst Iteration (i = 1, j = 2): a = \u0026quot;1\u0026quot;, b = \u0026quot;1\u0026quot;. No leading zeros  proceed. isValid(1, 1, \u0026quot;2358\u0026quot;): Sum of 1 + 1 = 2. Check if \u0026quot;2358\u0026quot; starts with \u0026quot;2\u0026quot;  Yes. Recursively call isValid(1, 2, \u0026quot;358\u0026quot;): Sum of 1 + 2 = 3. Check if \u0026quot;358\u0026quot; starts with \u0026quot;3\u0026quot;  Yes. Recursively call isValid(2, 3, \u0026quot;58\u0026quot;): Sum of 2 + 3 = 5. Check if \u0026quot;58\u0026quot; starts with \u0026quot;5\u0026quot;  Yes. Recursively call isValid(3, 5, \u0026quot;8\u0026quot;): Sum of 3 + 5 = 8. Check if \u0026quot;8\u0026quot; starts with \u0026quot;8\u0026quot;  Yes. Recursively call isValid(5, 8, \u0026quot;\u0026quot;): Empty string  return true. Since isValid returned true, the main function returns true. Edge Cases Leading Zeros: Correctly skips invalid splits (e.g., \u0026quot;02\u0026quot; unless it\u0026rsquo;s \u0026quot;0\u0026quot;). Single Digit: If input length \u0026lt; 3, returns false. Large Numbers: Uses parseInt, but BigInt is better for very large numbers to avoid precision issues. Time Complexity Nested loops: O(n), where n is the string length. isValid function: O(n) per pair (a, b). Overall: O(n), feasible for reasonably sized strings. Space Complexity O(n) due to recursion stack in the worst case. Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var isAdditiveNumber = function(num) { const isValid = (a, b, s) =\u0026gt; { if (s.length === 0) return true; const sum = (a + b).toString(); return s.startsWith(sum) \u0026amp;\u0026amp; isValid(b, parseInt(sum), s.slice(sum.length)); }; const n = num.length; for (let i = 1; i \u0026lt; n; i++) { for (let j = i + 1; j \u0026lt; n; j++) { const a = num.slice(0, i); const b = num.slice(i, j); if ((a.startsWith(\u0026#39;0\u0026#39;) \u0026amp;\u0026amp; a.length \u0026gt; 1) || (b.startsWith(\u0026#39;0\u0026#39;) \u0026amp;\u0026amp; b.length \u0026gt; 1)) continue; if (isValid(parseInt(a), parseInt(b), num.slice(j))) return true; } } return false; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 var isAdditiveNumber = function(num) { let N = num.length; let check = ( a ) =\u0026gt; { /** check if numbers in an array form fibonacci seqence **/ let A = a.length; if ( A \u0026lt; 3 ) return false; for ( let i=2; i \u0026lt; A; i++ ) if ( Number(a[i]) != Number(a[i-1]) + Number(a[i-2]) || ( a[i].length \u0026gt; 1 \u0026amp;\u0026amp; a[i].startsWith(\u0026#39;0\u0026#39;) ) || ( a[i-1].length \u0026gt; 1 \u0026amp;\u0026amp; a[i-1].startsWith(\u0026#39;0\u0026#39;) ) || ( a[i-2].length \u0026gt; 1 \u0026amp;\u0026amp; a[i-2].startsWith(\u0026#39;0\u0026#39;) ) ) return false; return true; }; let bt_search = ( i, cur = [] ) =\u0026gt; { if ( i \u0026gt; N ) return false; if ( i === N \u0026amp;\u0026amp; check(cur) ) return true; // num[i] starts a new number, explore path cur.push( num[i] ); let new_start = bt_search( i+1, cur ); if ( new_start ) return true; // backtrack, num[i] continues the previous number cur.pop(); if ( i \u0026gt; 0 ) { cur[ cur.length-1 ] += num[i]; let add_prev = bt_search( i+1, cur ); if ( add_prev ) return true; } return false; }; return bt_search( 0 ); }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_306_additive_number/","summary":"\u003cp\u003eHere\u0026rsquo;s my explanation for the \u003ca href=\"https://leetcode.com/problems/additive-number/description/\"\u003eleetcode 306: Additive Number problem\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"additive-number-problem\"\u003eAdditive Number Problem\u003c/h2\u003e\n\u003ch3 id=\"problem-recap\"\u003eProblem Recap\u003c/h3\u003e\n\u003cp\u003eAn \u003cstrong\u003eadditive number\u003c/strong\u003e is a string of digits where the sequence of numbers formed by splitting the string satisfies the condition that each number (after the first two) is the sum of the two preceding numbers.\u003c/p\u003e\n\u003ch4 id=\"examples\"\u003eExamples:\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026quot;112358\u0026quot;\u003c/code\u003e is additive because the sequence is \u003ccode\u003e1, 1, 2, 3, 5, 8\u003c/code\u003e, and:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e1 + 1 = 2\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e1 + 2 = 3\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e2 + 3 = 5\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e3 + 5 = 8\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026quot;199100199\u0026quot;\u003c/code\u003e is additive because the sequence is \u003ccode\u003e1, 99, 100, 199\u003c/code\u003e, and:\u003c/p\u003e","title":"Leetcode 306: Additive number"},{"content":"Here are all possible solutions I could come up with for the longest increasing subsequence problem. leetcode 300\nApproach 1: Generate all possible increasing subsequences We will keep track of a subsequence in an array named cur_subsequence or cur_sub. For each element (a[i]) we have the following 2 options:\nAdd the element to the end of current subsequence.\nNote: The current element can only be included if either the current subsequence is empty or the last element of the current subsequence is smaller than the current element. This is important to maintain the increasing subsequence property.\nIgnore the current element and explore without a[i]\nTime complexity: $$ O(2^N) $$ Space complexity: $$ O(N) $$ // recursion stack + auxilary array 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 var lengthOfLIS = function(a) { let A = a.length; // maximum length of a subsequence seen so far let max_len = 1; let bt_search = ( i, cur_sub = [] ) =\u0026gt; { if ( i \u0026gt;= A ) { max_len = Math.max( max_len, cur_sub.length ); return; } // either select the ith element, or ignore it. // a[i] can be taken when either subsequencee is empty or // last inserted element is smaller if ( !cur_sub.length || cur_sub[ cur_sub.length-1 ] \u0026lt; a[i] ) { cur_sub.push( a[i] ); bt_search( i+1, cur_sub ); cur_sub.pop(); // backtrack } // explore without a[i] included bt_search( i+1, cur_sub ); }; bt_search(0); return max_len; } Approach 2 (Version 1) : Generating all possible subsequences, but change the structure of the recursion to allow memoization Currently, we are keeping track of the current subsequence in an array cur_sub which makes it difficult for us to implement memoization. Notice that we only need previously selected element (to compare if current element is larger) and current length (to find the subsequence length). Hence, we will only use 3 variables: index, previous element index, current length.\nTime complexity: $$ O( N^2 ) $$ Space complexity: $$O( N^3 )$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 var lengthOfLIS = function(a) { /** Write a recurrence relation. Either you take the element @i or your ignore it. In either case, your pick the maximum length. generating all possible increasing subsequences, but not storing the subsequence and using only 3 variables. for each call(index, prev_selected, cur_length) we try to find the maximum length we can form by either selecting or rejecting a[i] This configuration is easy to memoize. **/ let A = a.length; let memo = new Map(); let bt_search = ( i, prev, cur_len = 0 ) =\u0026gt; { // inputs of the function are memoized by turning // them into a String `key` let key = JSON.stringify( [i, prev, cur_len] ); if (memo.has(key)) return memo.get(key); if ( i \u0026gt;= A ) return cur_len; let take = -1, not_take = -1; // a[i] can be taken if prev=null / cur_len=0 // or prev \u0026lt; a[i] if ( cur_len == 0 || prev \u0026lt; a[i] ) take = bt_search( i+1, a[i], cur_len+1 ); // backtrack. do not take a[i] not_take = bt_search( i+1, prev, cur_len ); let res = Math.max( take, not_take ); memo.set(key, res); return memo.get(key); }; return bt_search(0); } Approach 2 (Version 2): Yet another recursive solution, but with better memoization This solution memoizes using only: index of current element (i), index of previously selected element (prev_i).\nThe memoization is done in a matrix of size $$N$$X$$(N+1)$$.\nTime complexity: $$ O( N^2 ) $$ Space complexity: $$O( N^2 )$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 var lengthOfLIS = function(a) { /** Approach 2 (version 2): Instead of storing 3 variables, just store 2 variables. This will enable memoization table to be an NxN matrix. **/ let A = a.length; let memo = new Array( A ).fill(null).map( () =\u0026gt; new Array( A+1 ).fill( null ) ); let bt_search = ( i, prev_i = -1 ) =\u0026gt; { // y is remapped since prev_i is in range [-1,n-1] // but our array ranges is in range [0, n] let x = i, y = prev_i + 1; if ( i \u0026gt;= A ) return 0; if ( memo[x][y] !== null ) return memo[x][y]; let take = -1, not_take = -1; // a[i] can be taken if prev_i = -1 / cur_len=0 or // a[prev_i] \u0026lt; a[i] if ( prev_i == -1 || a[prev_i] \u0026lt; a[i] ) take = 1 + bt_search( i+1, i ); // backtrack. do not take a[i]. The length remains same not_take = bt_search( i+1, prev_i ); let res = Math.max( take, not_take ); memo[x][y] = res; return memo[x][y]; }; return bt_search(0); } Approach 3: Dynamic programming Declare a lis(longest increasing subsequence) array, where lis[i] denotes the length of longest increasing subsequence starting at i and ending at the end of the array. Fill this table from second last element towards first element.\nTo find lis[i] for an element a[i] use the following algorithm:\nFor each i \u0026lt;- n-2 - 0 // find if index i can form an increasing subsequence // with any element on the right of it max_len = 1 For each j \u0026lt;- i+1 - n if ( a[i] \u0026lt; a[j] ) // a[j] is a potential connection point max_len = MAX( max_len, 1 + lis[j] ) lis[i] = max_len The basic intuition behind it is, that we explore all elements to the right of a[i] which can connect with a[i] to form an increasing subsequence. The length of such a subsequence is given by:\n1 (length of a[i]) + length of longest subsequence from a[j] up until the end of the array\nwhich is same as: 1 + lcs[j]\nTime: $$O(n^2)$$ Space: $$O(n)$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 let MAX = Math.max; var lengthOfLIS = function(a) { /** Appraoch 3: Build the dp table manually using loops **/ let A = a.length; let lis = new Array( A ).fill(1); // global maximum, subsequence length from a[i] until end let gmax = 1; for ( let i = A-2; i \u0026gt;= 0; i-- ) { let max_len = 1; for ( let j = i+1; j \u0026lt; A; j++ ) { if ( a[i] \u0026lt; a[j] ) max_len = MAX( max_len, 1+lis[j] ); } lis[i] = max_len; gmax = MAX( max_len, gmax ); } return gmax; } Approach 4: Build an auxilary array, such that the minium elements are always at the end of it Here, we are basically trying to kick out large elements and inserting small elements whereever possible, so that new incoming elements feel welcome attaching themselves to the existing subsequence.\nBuild a auxilary array using the following algorithm:\nsubsequence = [] For each i \u0026lt;- 0 to A-1 if subsequence.last_element \u0026lt; a[i] subsequence.push( a[i] ) else { replace the largest element smaller than or equal to a[i] in subsequence using binary search. } the length of the subsequence is the length of the largest increasing subsequence. Time: $$O(n\\ log n)$$ // n for iteration, and for each iteration binary search O(log n) Space: $$O(n)$$ // auxilary array Note that the array that we actually build here does not represent a valid increasing subsequence. Nor is it the longest increasing subsequence, we just insert the elements using a particularly methodology which ensures its validity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 let MAX = Math.max; let FLOOR = Math.floor; var b_search = ( a, target ) =\u0026gt; { // return the index pf the number \u0026gt;= target let i = 0, j = a.length-1; while ( i \u0026lt;= j ) { let mid = i + FLOOR( (j-i)/2 ); if ( a[mid] == target ) return mid; else if ( a[mid] \u0026lt; target ) i = mid+1; else j = mid-1; } return i; }; var lengthOfLIS = function(a) { /** Approach 4: The idea is to keep the minium elements, such that validity of lis(longest increasing subsequence) for new incoming elements can be calculated quickly **/ let A = a.length; let sub = [ a[0] ]; for ( let i=1; i \u0026lt; A; i++ ) { let lst = sub.length-1; if ( sub[ lst ] \u0026lt; a[i] ) sub.push( a[i] ); else { // find a \u0026#34;write index\u0026#34; where we replace a[i] let wi = b_search( sub, a[i] ); sub[wi] = a[i]; } } return sub.length; } Approach 5: In place algorithm for approach 4 Time: $$O(n\\ logn)$$ Space: $$O(1)$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 let MAX = Math.max; let FLOOR = Math.floor; /* this version is for searching within the same array starting and ending position are requirede */ var b_search = ( a, start, end, target ) =\u0026gt; { // return the index pf the number \u0026gt;= target let i = start, j = end; while ( i \u0026lt;= j ) { let mid = i + FLOOR( (j-i)/2 ); if ( a[mid] == target ) return mid; else if ( a[mid] \u0026lt; target ) i = mid+1; else j = mid-1; } return i; }; var lengthOfLIS = function(a) { /*** Approach 5: Same as the above approach, but in place Hence saving auxilary space. The idea is to keep a variable to mark the end of the subsequence in a itself. **/ let A = a.length; let S = 1; // variable to mark the end of the subsequence for ( let i=1; i \u0026lt; A; i++ ) { if ( a[S-1] \u0026lt; a[i] ) { a[S] = a[i]; S++; } else { // find a \u0026#34;write index\u0026#34; where we replace a[i] let wi = b_search( a, 0, S-1, a[i] ); a[wi] = a[i]; } } return S; } ","permalink":"http://localhost:45763/personal_website/posts/all_possible_solutions_to_longest_increasing_subsequence_problem_leetcode_300/","summary":"\u003cp\u003eHere are all possible solutions I could come up with for the longest\nincreasing subsequence problem. \u003ca href=\"https://leetcode.com/problems/factorial-trailing-zeroes/description/\"\u003eleetcode\n300\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"approach-1-generate-all-possible-increasing-subsequences\"\u003eApproach 1: Generate all possible increasing subsequences\u003c/h1\u003e\n\u003cp\u003eWe will keep track of a subsequence in an array named \u003ccode\u003ecur_subsequence\u003c/code\u003e\nor \u003ccode\u003ecur_sub\u003c/code\u003e. For each element (\u003ccode\u003ea[i]\u003c/code\u003e)  we have the following 2\noptions:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eAdd the element to the end of current subsequence.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eNote: The current element can only be included if\neither the current subsequence is empty or the last\nelement of the current subsequence is smaller than\nthe current element. This is important to maintain\nthe increasing subsequence property.\u003c/em\u003e\u003c/p\u003e","title":"All possible solutions to longest increasing subsequence problem: leetcode 300"},{"content":"Problem link: leetcode 70: climbing stairs\nIntuition You need to climb n stairs, taking 1 or 2 stairs at a time.\nIf n = 2, you can climb like:\n$$1+1 = 2\\times (1) + 0 \\times(2)$$ $$2 = 0 \\times (1) + 1\\times(2) $$ if n = 3, you can climb like:\n$$1+1+1 = 3\\times(1) + 0\\times(2)$$ $$1+2 = 1\\times(1) + 1\\times(2)$$ $$2+1 = 1\\times(1) + 1\\times(2) $$ Basically you first need to decide how many steps of size 1 will you take and how many of size 2 do you need:\nHence, your first task is to solve the equation:\n$$ x \\times 1 + y \\times 2 = n $$\nTo decide the number of 1s and 2s. After you decide upon x and y then you will have calculate $$ \\frac{(x + y)!}{x! , y!} $$\nWhich is nothing but ways of chosing how exactly you will proceed. This is because we are trying to adjust x identical objects and y identical objects in x+y positions. Think of the number of ways you can arrange x men and y women in x + y positions.\nAs an example $$n=3, x=1 $$ and $$y=1$$\nThen you will have $$\\frac{(1 + 1)!}{1! , 1!} =2$$. see above, they are: $$ 1+2 \\ 2+1 $$\nApproach $$ y \\in [0, n/2] $$\nFor each , calculate the corresponding values of $$x$$ using the equation: $$ x \\times 1 + y \\times 2 = n \\ x = n - (2 \\times y ) $$\nthen calculate $$ \\frac{(x + y)!}{x! , y!} $$\nand add this to your counter variable.\nreturn counter.\nComplexity Time complexity: Time: O($$n^2$$)\nSpace: O(1)\nBut it can be reduced, if you can store calculated factorials. Hence, making the time complexity of calculating $$ \\frac{(x + y)!}{x! , y!} $$ -\u0026gt; O(1) and Space complexity O(n)\nTime complexity: O(n) Space complexity: O(n)\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 var permute = (x,y) =\u0026gt; { /* compute (x+y)! / x! y! without computing factorials */ /* which is basically computing x+y x+y-1 x+y-2 .. y+1 / x! */ var denom = 1; for (var i=1; i \u0026lt;= x; i++) denom *= i; var numi = 1; for (var i = y+1; i \u0026lt;= x+y; i++) numi *= i; return numi/denom; }; var climbStairs = function(n) { /* The number of ways in which we can get n by adding only 1 and 2 Let, 1x + 2y = n ---(1) then we need to find the number of integer solutions to this equation. that is S = {x,y | x,y in integers} we need to return |S| i.e. the number of elements in this solution set. from (1) it implies x = n - 2y ---(2) y in range [0,n/2] i.e. consequently x in range [0,n] hence, iterate over y from 0 to n/2 such that y is integer. we find the corrosponding solution using equation 2 */ let n_solutions = 0 ; for (var y=0; y \u0026lt;= Math.floor(n/2); y++ ) { var x = n - (2 * y); n_solutions += permute(x,y); } return (n_solutions); }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_70/","summary":"\u003cp\u003eProblem link: \u003ca href=\"https://leetcode.com/problems/climbing-stairs/description/\"\u003eleetcode 70: climbing stairs\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"intuition\"\u003eIntuition\u003c/h1\u003e\n\u003c!-- Describe your first thoughts on how to solve this problem. --\u003e\n\u003cp\u003eYou need to climb \u003ccode\u003en\u003c/code\u003e stairs, taking 1 or 2 stairs at a time.\u003c/p\u003e\n\u003cp\u003eIf n = 2, you can climb like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$$1+1 = 2\\times (1) + 0 \\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$2 = 0 \\times (1) + 1\\times(2) $$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eif n = 3, you can climb like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$$1+1+1 =  3\\times(1) + 0\\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$1+2   =  1\\times(1) + 1\\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$2+1   =  1\\times(1) + 1\\times(2) $$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBasically you first need to decide how many steps of size 1 will you take and how many of size 2 do you need:\u003c/p\u003e","title":"Leetcode 70: Climbing Stairs"},{"content":"Below is my C solution for the Leetcode problem candy.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 static inline void previous_kids_started_crying(int* kid, int continous_decrease_start, int continous_decrease_end, int* candy) { /* * To satisfy the condition that each child with higher rating than * it\u0026#39;s neighbors must get more candies. We give all children in range * [continous_decrease_start, continous_decrease_end] an extra candy * if the he has candies lower or equal to the kid after it. * * Note that we do not bother the kid before it, since it is known * that the kid before it has more rating than this kid */ if (continous_decrease_start == -1) { exit(1); } for (int i = continous_decrease_end; i \u0026gt;= continous_decrease_start; i--) { if (kid[i] \u0026lt;= kid[i+1]) { int before = kid[i]; kid[i]++; int after = kid[i]; *candy += after - before;; } else { /* chain is broken. We found a satisfied non protesting kid the kids before it must also be non-protesting */ return; } } } int candy(int* kid, int n) { /* * Few things to take care of: * * 1. At a time take a look at 2 children. i.e. iterate the children * in window of 2. * * 2. Each time a candy is given, check if previous child has more * rating, since he will start crying. He/she will protest that the * kid in front of him has less rating than him/her and still got * more/equal candies than him/her. It might even trigger a chain * where the kid previous to the previous kid might also see this * changed state, and if he had a rating more then the kid after him. * then he will also start asking more candies. And the kid behind * that and so on. * * The algorithm runs in linear time, however, if the children are * arranged in decreasing order of rating, then at each iteration all * previous children will start crying. Hence, everybofy needs to be * given more candies. In that case it becomes quadratic * * Space required is constant. * * Best case: * Time: O(n) * Space: O(1) * * Worst Case: * Time: O(n^2) * Space: O(1) */ int candies = 0; int continous_decrease_from = -1; /* First child gets a candy, but save his rating first */ int previous_child_rating = kid[0]; kid[0] = 1; candies++; for (int i = 1; i \u0026lt; n; i++) { if (kid[i] \u0026gt; previous_child_rating) { /* Since this child has more rating than the previous child, this child gets 1 more candy than previous child */ previous_child_rating = kid[i]; kid[i] = kid[i-1]+1; candies += kid[i]; continous_decrease_from = -1; } else if (kid[i] == previous_child_rating){ /* Since this child has equal rating than the previous child, give him 1 candy */ previous_child_rating = kid[i]; kid[i] = 1; candies++; continous_decrease_from = -1; } else { /* Previous child has more rating. Give this child one candy, and after giving : if the previous child had less candy, then we must initiate a chain reaction to do justice to all previous kids to previous children the problem here is that if this child has less rating then his predecessor then he will also start crying. And, the predecesor of this child also has more score then he will also start crying. Hence, we must give candies to them as well to maintain rule. Hence, check if the rule is disturbed, */ if (continous_decrease_from == -1) { /* A period of continous decrease started */ /* Hence, give this child 1 candy and if the previous child will also get 1 candy if he gets */ continous_decrease_from = i-1; previous_child_rating = kid[i]; kid[i] = 1; if (kid[i-1] \u0026gt; kid[i]) { candies ++; } else { kid[i-1] = kid[i] + 1; candies += 2; } } else { /* Give this child a candy, but mind the children behind this child */ previous_child_rating = kid[i]; kid[i] = 1; candies++; previous_kids_started_crying(kid, continous_decrease_from, i-1, \u0026amp;candies); } } } return candies; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_135/","summary":"\u003cp\u003eBelow is my C solution for the Leetcode problem \u003ca href=\"https://leetcode.com/problems/climbing-stairs/description/\"\u003ecandy\u003c/a\u003e.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e  1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 35\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 36\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 37\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 38\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 39\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 40\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 41\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 42\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 43\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 44\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 45\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 46\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 47\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 48\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 49\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 50\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 51\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 52\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 53\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 54\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 55\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 56\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 57\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 58\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 59\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 60\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 61\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 62\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 63\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 64\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 65\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 66\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 67\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 68\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 69\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 70\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 71\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 72\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 73\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 74\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 75\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 76\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 77\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 78\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 79\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 80\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 81\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 82\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 83\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 84\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 85\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 86\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 87\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 88\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 89\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 90\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 91\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 92\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 93\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 94\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 95\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 96\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 97\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 98\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 99\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e100\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e101\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e102\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e103\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e104\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e105\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e106\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e107\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e108\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e109\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e110\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e111\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e112\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e113\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e114\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e115\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e116\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e117\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e118\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e119\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e120\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e121\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e122\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e123\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e124\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e125\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e126\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e127\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e128\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e129\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e130\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e131\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e132\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e133\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e134\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kr\"\u003einline\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eprevious_kids_started_crying\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_end\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ecandy\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * To satisfy the condition that each child with higher rating than\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * it\u0026#39;s neighbors must get more candies. We give all children in range\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * [continous_decrease_start, continous_decrease_end] an extra candy\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * if the he has candies lower or equal to the kid after it.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Note that we do not bother the kid before it, since it is known\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * that the kid before it has more rating than this kid\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e        */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nf\"\u003eexit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_end\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ebefore\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eafter\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ecandy\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003eafter\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ebefore\u003c/span\u003e\u003cspan class=\"p\"\u003e;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* chain is broken. We found a satisfied non protesting kid\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                          the kids before it must also be non-protesting */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ecandy\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Few things to take care of:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * 1. At a time take a look at 2 children. i.e. iterate the children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * in window of 2.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * 2. Each time a candy is given, check if previous child has more\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * rating, since he will start crying. He/she will protest that the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * kid in front of him has less rating than him/her and still got\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * more/equal candies than him/her. It might even trigger a chain\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * where the kid previous to the previous kid might also see this\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * changed state, and if he had a rating more then the kid after him.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * then he will also start asking more candies. And the kid behind\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * that and so on.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * The algorithm runs in linear time, however, if the children are\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * arranged in decreasing order of rating, then at each iteration all\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * previous children will start crying. Hence, everybofy needs to be\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * given more candies. In that case it becomes quadratic\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space required is constant.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Best case:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Time: O(n)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space: O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Worst Case:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Time: O(n^2)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space: O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e         */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/* First child gets a candy, but save his rating first */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Since this child has more rating than the previous\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         child, this child gets 1 more candy than previous\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         child */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Since this child has equal rating than the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         previous child, give him 1 candy */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Previous child has more rating. Give this child one\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candy, and after giving : if the previous child had less\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candy, then we must initiate a chain reaction to do\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        justice to all previous kids to previous children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        the problem here is that if this child has less rating\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        then his predecessor then he will also start crying.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        And, the predecesor of this child also has more score\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        then he will also start crying. Hence, we must give\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candies to them as well to maintain rule. Hence, check\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        if the rule is disturbed,\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* A period of continous decrease started */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* Hence, give this child 1 candy and if the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                                   previous child will also get 1 candy if he gets  */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* Give this child a candy, but mind the children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                                  behind this child */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"nf\"\u003eprevious_kids_started_crying\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Leetcode 135: Candy"},{"content":"Introduction Linux is the kernel that powers the modern computing world. Its everywherefrom all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isnt about why Linux dominates the tech world; its about how I started contributing to the Linux Kerneland how you can too.\nHow Kernel Development Works Kernel development thrives on the Linux Kernel Mailing List (LKML), the nerve center of Linuxs open-source ecosystem. The beauty of open source? Anyone can contribute. Your task is to send patches (essentially the output of git diff refurbushed into an email).\nIf your patch solves a real problem or adds value, experienced developers will jump in with questions about your intent and rationale. Heres a pro tip: dont explain the how of your code; let the code speak for itself. Instead, focus on explaining why your change is needed.\nThe LKML community is incredibly supportive \u0026ndash; theyll critique your code, point out mistakes, and suggest improvements. Sure, it might feel overwhelming initially, but resources like the LFD103 course can guide you through the basics: generating patches, submitting them to LKML, compiling, and booting the kernel.\nFor me, just setting up my mail client and understanding LKML discussions took about a month. But once you clear these initial hurdles, things get easier. If youre struggling, feel free to check out my notesthey might save you some time.\nMy Background For years, kernel developers seemed like magicians to medoing impossibly cool things with computers. My fascination started after I stumbled upon a video of someone working on the kernel. It was mesmerizing!\nIn my second semester, I discovered the book The C Programming Language, and it sparked my love for C. The control C offers is unmatched, but it comes with its fair share of challengesbugs galore!\nSurprisingly, I wasnt a Linux user until recently. When I finally switched from Windows to Linux, everything just clicked. Concepts that once felt abstract suddenly made sense. On Windows, troubleshooting often felt like solving a mystery even Microsoft couldnt decode. On Linux, it felt like someone handed me the keys to the entire system.\nWhile working on kernel contributions, I read Linux Device Drivers, a book authored by seasoned kernel developers. It gave me a deeper understanding of the kernels inner workings. If youre serious about kernel development or writing drivers, this book is a must-read.\nWhat to Contribute The hardest part of contributing to the Linux Kernel is figuring out what to work on. The kernel is vasttheres everything from GPU drivers to network stack development.\nSince the kernels primary job is managing hardware, driver development is a hotspot of activity. New devices constantly hit the market, and they need drivers. If you have an electronics background and access to hardware, driver development is an excellent starting point.\nIf hardware isnt your thing (like in my case), here are some alternatives:\nkselftest: A testing framework for kernel functionality. Core subsystems: The backbone of the kernela great way to learn the essentials. syzbot reports: A kernel fuzzer that uncovers bugs by feeding the kernel random data. These reports are a goldmine for learning about common mistakes. Another beginner-friendly option is upgrading deprecated APIs. These updates are highly appreciated because they improve the kernels maintainability and security. Its not always a simple find-and-replaceyoull need to understand the codebut its a rewarding way to start.\nAnd dont underestimate fixing spelling and grammar errors in the documentation or comments. While it might sound trivial, its a fantastic way to learn the workflow: creating patches, submitting them, and receiving feedback. Tools like codespell can help you automate finding these errors.\nMy first-ever patch was a simple typo fix, but I made the classic rookie mistake of introducing two changes while documenting only one. Lesson learned!\nOnce you start contributing, youll notice issues everywhere. Even just following discussions on LKML can teach you a ton about how seasoned developers think and work.\nConclusion Kernel development might seem intimidating at first, but trust me, its worth the effort. Youll not only become a stronger developer but also gain a deep understanding of how computers work. Youll build expertise in both kernel and userspace development, and your Git skills will level up immenselya must-have for any programmer.\nThe learning opportunities in kernel development are unparalleled, often rivaling (or even exceeding) those at top tech companies. So if youre considering it, dont hesitatedive in! You might be surprised by how much youll grow.\nGood Luck!\nReferences ","permalink":"http://localhost:45763/personal_website/posts/highlights_from_linux_kernel_mentorship_program_2024/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux is the kernel that powers the modern computing world. Its everywherefrom all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isnt about \u003cem\u003ewhy\u003c/em\u003e Linux dominates the tech world; its about how I started contributing to the Linux Kerneland how you can too.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"how-kernel-development-works\"\u003eHow Kernel Development Works\u003c/h2\u003e\n\u003cp\u003eKernel development thrives on the Linux Kernel Mailing List (LKML), the\nnerve center of Linuxs open-source ecosystem. The beauty of open\nsource? Anyone can contribute. Your task is to send patches (essentially\nthe output of \u003ccode\u003egit diff\u003c/code\u003e refurbushed into an email).\u003c/p\u003e","title":"Highlights from Linux Kernel Mentorship Program 2024 by Abdul Rahim"},{"content":"Introduction Computer memory is usually implemented as a file system. While tampering with data is easy to detect, unauthorized access to memory is a more complex task falling within the domain of Intrusion Detection Systems (IDS). Most intrusion detection systems focus on analyzing network traffic or using machine learning techniques to identify suspicious patterns, we explore if we can employ merkel trees for this task.\nIf unauthorized memory access cannot be detected, users would never know that the system was compromised. Detecting tampered files is straightforward: you can hash the contents of a file, and if the hash changes you might conclude that the file changed. However, detecting memory access is more complicated. Although Linux keeps track of the last access timestamp, available via the stat command1, it only tracks file accesses that use the read() syscall2.\nMerkel Trees Merkle trees are a data structure in which hashes are stored rather than data. Leaf nodes store hashes of particular data blocks, while other nodes store hashes of their children. Merkle trees are widely used in blockchains for their ability to detect data tampering. They provide a robust mechanism to detect tampering in multiple distinct data items. If any data item in a leaf node changes, the whole tree becomes invalidated because it changes the hashes of all nodes up the tree.\nFig. 1: A Merkle tree is a data structure in which each node contains a hash. All non-leaf nodes contain hashes of their children, and all leaf nodes contain hashes of the underlying data.\nMerkel tree as directory tree Now, what we want to do is to augment the directory tree as a merkel tree. To be exact the inode structure (See inode doc for more details).\nDoing this would make us have hashes for children in directory tree. And the benefit of that is whenever the child inodes change, the current inode would change. And there\u0026rsquo;s 2 fields that each node would contain, the last seen hash (expected hash) of it\u0026rsquo;s child and the current hash of the same child. And when the current hash changes to a different value from expected hash, then we can imply that the child inode changed.\nBut one question is that if memory can be accessed bare metal, then the protections done in software doesn\u0026rsquo;t really make any sense. One possible solution to this problem is employing encryption.\nThe encryption should be performed in hardware, and the memory access system calls should define protocols for decrypting the underlying memory. The same system call would update necessary variables of the file in question, such as access time. The memory access system call needs to be implemented so that when one accesses memory, the data is decrypted and other functions are performed.\nBelow is a detailed description.\nArchitecture File system in most operating systems follow a hierarchical structure. We augment this with a Merkle tree, where a node is attached to each file in the file system. These nodes form a Merkle tree, where each node contains the hash of its children (in the case of non-leaf nodes) or the hash of the file data (in the case of files). Additionally, a pollution flag is attached to each node to detect illegal access.\nEach node will also has an expected hash, which is the hash of the node when the subtree below that node was last valid.\nWorking The pollution flag is set if expected_hash != hash, which occurs only on illegal access. I will explain this in a moment.\nWhen a user or process requests memory, it will go through the memory access system call, requiring authentication. Once the authentication is successful, the underlying data is decrypted and returned, the access time is updated, and all the hashes up to the root are updated along with the expected hash (note that the expected hash changes on authorized access). The tree remains valid.\nIf the authentication fails, the memory is not returned, but the access time changes. Consequently, when the tree is re-evaluated, the hash of this node changes since it incorporates the access time, but the expected hash remains the same, setting the pollution flag for this node.\nSince the parent of this node uses its hash, the parent\u0026rsquo;s hash also changes. However, its expected hash remains the same, leading to its invalidation. This process continues up the tree, invalidating the whole tree.\nThe benefit of this approach is that all other nodes remain valid. If one tries to determine which file was accessed and the timestamp, it is easy to identify the exact file by following the invalid nodes from top to bottom.\nRefrences stat man page\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nread syscall\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:45763/personal_website/posts/merkel_trees_and_computer_memory/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003c!-- mine\nComputer memory is usually implemented as a file system. While tampering\nof data is easy to detect, unauthorised access to memory is a more\ncomplex task. A problem that lies in the domain of Intrusion Detection\nSystems. While, most intrusion detection focus on analyzing network\ntraffic, or machine learning techniques to identify suspicious patterns.\nWe propose a method that works within the system, providing robust\naccess detection.\n--\u003e\n\u003cp\u003eComputer memory is usually implemented as a file system. While tampering\nwith data is easy to detect, unauthorized access to memory is a more\ncomplex task falling within the domain of Intrusion Detection Systems\n(IDS). Most intrusion detection systems focus on analyzing network traffic or\nusing machine learning techniques to identify suspicious patterns, we\nexplore if we can employ merkel trees for this task.\u003c/p\u003e","title":"Merkel Trees and computer memory"},{"content":"Introduction When you install vim, a usual requirement as with all text editors is the ability to copy to/from system clipboard so you can lets say, copy something into your vim session from firefox or vice versa, however copy pasting in terminal editors is not as straight forward as with GUI editors. In vim if you want to copy something into an auxilary space (anticipating it would be used later, so you can paste from this auxilary space) is achieved by registers.\nThe register that represents system clipboard is + register. Anything that you copy into this register is available in system clipboard.\nHow to use registers to copy/paste To copy a text into a register, select it in visual mode and press \u0026quot;\u0026lt;register_name\u0026gt;y to yank the contents into the given register. And to paste the contents of a particular register at current position, use \u0026quot;\u0026lt;register_name\u0026gt;p.\nTo use system clipboard, you just have to substitute \u0026ldquo;+\u0026rdquo; for register name in the above commands.\nclipboard support But the + register wont work unless you have clipboard support with your vim installation. By default there is no clipboard support in vim.\nTo check if your vim installation has clipboard support use:\n1 2 3 $ vim --version | grep clipboard +clipboard +keymap +printer +vertsplit +ex_extra +mouse_netterm +syntax +xterm_clipboard or inside of vim, you can run the command:\n1 :echo has(\u0026#39;clipboard\u0026#39;) If the output is 0, your installation doesnt have clipboard support.\nCompiling vim Now there are 2 solutions to this problem:\nEither install gvim: Or compile vim from sources with clipboard support Let\u0026rsquo;s see how each of them can be done.\nInstall gvim To install gvim run:\nOn Debian:\n1 sudo apt install vim-gtk On Fedora\n1 sudo dnf install gvim To compile vim with clipboard support Below are the simple steps:\nStep 1: Grab the sources Clone the repository:\n1 2 git clone https://github.com/vim/vim.git vim cd vim Step 2: Install dependencies Install the required libraries and tools to build vim, for example gcc, x11 etc. Note that you only need them to compile vim and you are free to delete them once you are done.\nOn Debian:\n1 sudo apt install build-essential libx11-dev libncurses5-dev On Fedora:\n1 2 3 4 sudo dnf groupinstall \u0026#34;Development Tools\u0026#34; sudo yum install gcc sudo yum groupinstall \u0026#34;X Software Development\u0026#34; sudo dnf install libX11-devel ncurses-devel Also, you need to remove the existing installation(if any).\nOn Debian\n1 sudo apt remove vim On Fedora\n1 sudo dnf remove vim gvim Step 3: Configure and Compile Configure vim with features of your choice\n1 2 3 4 5 6 7 ./configure \\\\ --enable-cscope \\\\ --enable-gui=auto \\\\ --enable-gtk2-check \\\\ --enable-gnome-check \\\\ --with-features=huge \\\\ --with-x Then compile and install with:\n1 2 make sudo make install Conclusion In this article we learned how can we compile vim with clipboard support, you can also tweak configuration according to your requirements. There are many configuration options available.\n","permalink":"http://localhost:45763/personal_website/posts/how_to_compile_vim_with_clipboard_support/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eWhen you install vim, a usual requirement as with all text editors is\nthe ability to copy to/from system clipboard so you can lets say, copy\nsomething into your vim session from firefox or vice versa, however copy\npasting in terminal editors is not as straight forward as with GUI\neditors. In vim if you want to copy something into an auxilary space\n(anticipating it would be used later, so you can paste from this\nauxilary space) is achieved by \u003cstrong\u003eregisters\u003c/strong\u003e.\u003c/p\u003e","title":"How to compile vim with clipboard support"},{"content":" Introduction I had an unused phone lying around for some time, and I began contemplating how I could repurpose it. This led me to reflect on the impressive performance of modern smartphones and consider whether they could be utilized as servers.\nSmartphones are equipped with ARM-based processors and run on Android, which is itself built on the Linux kernel. ARM processors are renowned for their energy efficiency1 and have recently found applications in the server space2.\nAs someone who enjoys exploring the full potential of devices, I embarked on a journey to discover how I could leverage the full potential of smartphones.\nSetup Although, you would like to run your programs on phones, but programming on phones typing on screen is a horrifying idea. Fortunately, you dont have to type on your phone, what you can do is you can access its terminal, using protocols like ssh/telnet etc.\nSo, firstly you would need a terminal to control a machine remotely. Unfortunately, there are not, alot of choices available in phone space when it comes to terminal emulators. Termux is one of the few available options.\nAfter you manage to open a terminal remotely, then from there its pretty frictionless. You can install the software of your choice and write, compile and run your programs. You might also find it helpful to root your phone for root privilages, which will help you run all commands. But please beware that rooting can null your warrenty, check with local expert. If termux does\u0026rsquo;nt work for you then there are also other options like kali net hunter.\nSo, in total, we need to install termux, then we would setup ssh.\nTermux Termux is an open source terminal emulator for android. In essence, it provides you with a linux environment, within android, The only difference between actual linux environment and termex is that it is not FHS(File System Hierarcy) compliant, i.e. it does not strictly follow linux file system conventions. The consequences of that are that #! /usr/bin/sh may not work, so you have to watch out the paths. Other than that, it supports almost all commands on linux.\nMoreover, It is an app that does\u0026rsquo;nt interfere with your system so you can run your android as normal, moreover it runs without root privilages. It comes with a large repository of software found at packages.termux.dev.\nBelow are the steps to setup ssh in termux Step 1: Download texmux on playstore, f-droid or from github releases\nStep 2: Update using pkg:\n1 2 pkg update # update the repositories pkg upgrade # upgrade all to latest versions Run this commands\nStep 3: Install ssh 1 pkg install ssh install ssh\nStep 4: Set a password Setup a password that you will use to login\n1 passwd set password and note username\nStep 5: Note your username You will require username and ip address when logging in using ssh, hence note them. Run the command whoami the know your username. This will generally start with \u0026ldquo;a0_\u0026rdquo;\n1 whoami Step 6: Note your IP address You can check your IP address in:\n1 2 3 settings \u0026gt; Wi-Fi \u0026gt; click on the (i) button, on the wifi you are connected to and Look for IPv4 address Step 7: Run ssh doemon in termux On your phone, run the ssh daemon using\n1 sshd Step 8: Login form your computer On your computer, use the following command to login into your phone and access its terminal\n1 ssh \u0026lt;user_name\u0026gt;@\u0026lt;IP_address\u0026gt; -p 8022 The username and IP address we already determined in step 5 and 6 resp. Note that it will promt you for password\nAftermath You can use scp command to transfer files between your computer and phone. In case you want to do development, there are a number of programming packages available in termux, you can find rust, nodejs, python, C/C++ and tools for many other programming languages.\nConclusion So, now you have successfully installed ssh in your android phone. You might find it useful to install vim, git, gcc etc. There is a large repository of packages in termux, which covers pretty much everything your would need.\nFurther Reads Simili, Emanuele, et al. \u0026ldquo;Power Efficiency in HEP (x86 vs. arm).\u0026rdquo; Power (W) 350.400 (2023): 450\u0026#160;\u0026#x21a9;\u0026#xfe0e;\narm_server\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:45763/personal_website/posts/how_to_turn_your_old_smartphone_into_a_home_server/","summary":"\u003c!--\n---\ndate: '2025-07-15T22:33:11+05:30'\ndate: ''\ntitle: 'How_to_turn_your_old_smartphone_into_a_home_server'\n---\n--\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eI had an unused phone lying around for some time, and I began\ncontemplating how I could repurpose it. This led me to reflect on the\nimpressive performance of modern smartphones and consider whether they\ncould be utilized as servers.\u003c/p\u003e\n\u003cp\u003eSmartphones are equipped with ARM-based processors and run on Android,\nwhich is itself built on the Linux kernel. ARM processors are renowned\nfor their energy efficiency\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e and have recently found\napplications in the server space\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e","title":"How to turn your old smartphone into a home server"},{"content":"When nums[i] \u0026gt; nums[j], it is global inversion. Local inversion is special case of global inversion with j=i+1\nConsider the array: [0,1,2,3,4,5]\nIf i swap a random element by 2 positions (either to left or right). I will always create 2 inversions.\nLikewise, if I swap a random element by 3 positions. I end up creating 3 inversions.\nSimilarly if I swap an element by 4 positions. I end up creating 4 inversions.\nNote that for each swap made above, we created a single local inversion. This means that whever we swap 2 elements, we end up creating 1 local inversion and k global inversions. Where k means element swapped k number of positions away.\nNow, we need number of local inversions = number of global inversions. This can only happen when local inversion is itself the global inversion.\nHence, for each swap we should only create 1 inversion, THEREFORE K=1\n1 2 3 4 5 6 7 8 bool isIdealPermutation(int* nums, int numsSize) { for (int i=0; i \u0026lt; numsSize; i++) { if ( abs(nums[i]-i) \u0026gt; 1 ) return false; } return true; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_775_global_and_local_inversions_solution/","summary":"\u003cp\u003eWhen \u003ccode\u003enums[i] \u0026gt; nums[j]\u003c/code\u003e, it is global inversion. Local inversion is special case of global inversion with \u003ccode\u003ej=i+1\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eConsider the array: \u003ccode\u003e[0,1,2,3,4,5]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/2f3eb772-cc4d-4006-adec-d2937264734b_1752435521.47083.png\"\u003e\u003c/p\u003e\n\u003cp\u003eIf i swap a random element by 2 positions (either to left or right). I will always create 2 inversions.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/36424827-47b3-4fab-b464-6a02cbd9a953_1752435463.2740006.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/c9cefbb6-24e0-419e-8e4e-69178894068a_1752435700.7604558.png\"\u003e\u003c/p\u003e\n\u003cp\u003eLikewise, if I swap a random element by 3 positions. I end up creating 3 inversions.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/a5633f7f-c730-4671-8262-daed0eba9b80_1752435799.3669355.png\"\u003e\u003c/p\u003e\n\u003cp\u003eSimilarly if I swap an element by 4 positions. I end up creating 4 inversions.\u003c/p\u003e","title":"Leetcode 775: Global and local inversions solution"},{"content":"We need to divide the array nums into k subsets such that the sum of each subset is same.\n$$ k \\times sum\\ of\\ each\\ subset = total\\ sum\\ sum\\ of\\ each\\ subset = total\\ sum\\ \\div k\\ target = total\\ sum\\ \\div k $$\nNow our task is to find all the k subsets in nums whose sum is target.\nMy idea is to structure this as multi-level recursion. We first try to find the $$k^{th}$$ subset, then $$(k-1)^{th}$$, then $$(k-2)^{th} \u0026hellip;$$ until there is only one subset left. The last subset will naturally sum to target. You can only go to $$(k-1)^{th}$$ level when you are able to successfully find $$k^{th}$$ level subset,\nFor example,\n1 2 3 4 5 6 7 .. .. find the 5th subset find the 4th subset find the 3rd subset find the 2nd subset return true Seeing the recursive structure.\n1 2 3 4 5 6 7 8 9 nums = [4,3,2,3,5,2,1] k=4 target = 20 / 4 = 5 suppose you find the 4th subset as: {3,2} from [4,3,2,3,5,2,1] Now your task reduces to finding 3 subsets in [4, ,3,4,2,1] that sum to target=5 recursive call: nums=[4, ,3,4,2,1] k=3 When finding the kth subset. You can simply use pick/not pick backtracking approach. It is important to understant the distinction between same level recursion (at any given k) which operates by deciding weather to pick/drop nums@i.\nAnd the k levels recursion which succeeds/fails by checking if we can form the $$k^{th}$$ subset.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution: def __init__(self): self.nums, self.target, self.used = None, None, None def canPartitionKSubsets(self, nums: List[int], k: int) -\u0026gt; bool: self.nums = nums total = sum(self.nums) self.target = total // k self.used = [False] * len(nums) if total % k != 0: return False self.nums.sort(reverse=True) return self.bt_search(0, k, 0) def bt_search(self, i: int, k: int, cur_sum: int) -\u0026gt; bool: if k == 1: # last subset is sure to sum upto target return True if i \u0026gt;= len(self.nums) or cur_sum \u0026gt; self.target: return False if cur_sum == self.target: # current subset found, return self.bt_search(0, k-1, 0) # explore the next level of k # try picking nums@i in current subset if not self.used[i] and cur_sum + self.nums[i] \u0026lt;= self.target: self.used[i] = True # explore in same level if self.bt_search(i+1, k, cur_sum + self.nums[i]): return True self.used[i] = False # on failure, skip duplicates of nums@i while i+1 \u0026lt; len(self.nums) and self.nums[i] == self.nums[i+1]: i += 1 # do not pick nums@i -\u0026gt; explore in same level return self.bt_search(i+1, k, cur_sum) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_698_partition_to_k_equal_sum_subsets/","summary":"\u003cp\u003eWe need to divide the array \u003ccode\u003enums\u003c/code\u003e into \u003ccode\u003ek\u003c/code\u003e subsets such that the sum of each subset is same.\u003c/p\u003e\n\u003cp\u003e$$\nk \\times sum\\ of\\ each\\ subset = total\\ sum\\\nsum\\ of\\ each\\ subset = total\\ sum\\ \\div k\\\ntarget = total\\ sum\\ \\div k\n$$\u003c/p\u003e\n\u003cp\u003eNow our task is to \u003cstrong\u003efind all the \u003ccode\u003ek\u003c/code\u003e subsets in nums whose sum is \u003ccode\u003etarget\u003c/code\u003e\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eMy idea is to structure this as multi-level recursion. We first try to find the $$k^{th}$$ subset, then $$(k-1)^{th}$$, then $$(k-2)^{th} \u0026hellip;$$ until there is only one subset left. The last subset will naturally sum to \u003ccode\u003etarget\u003c/code\u003e. You can only go to $$(k-1)^{th}$$ level when you are able to successfully find $$k^{th}$$ level subset,\u003c/p\u003e","title":"Leetcode 698: Partition into k equal sum subsets: The art of recursion: mastering double recursion in a single function"},{"content":"For each possible word, we ask the question: What possible queries can lead to this word?.\nFor example consider the word: abd. Below are the possible (prefix, suffix) queries that can return abd\n1 2 3 4 5 6 7 8 9 10 (prefix, suffix) a abd a bd a d ab abd ab bd ab d abd abd abd bd abd d Now, given word.length \u0026lt;= 7. Each word can at maximum generate 7*7=49 such pairs. Can we store all of them in a hashmap? Yes, because the total storage = 49 * number of words = O(n) Which is acceptable for this problem.\nWhat if there is already a value for (prefix,suffix) in current word. Shall we override it. We need the latest index right?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class WordFilter: def __init__(self, words: List[str]): self.map = {} for widx, w in enumerate(words): for i in range( len(w) ): prefix = w[:i+1] for j in range( len(w) ): suffix = w[j:] # for all possible prefix suffix queries that might route # to current word. We set it in dictionary overriding previously # inserted values to get the maximum index key = prefix + \u0026#39;|\u0026#39; + suffix self.map[key] = widx def f(self, pref: str, suff: str) -\u0026gt; int: key = pref + \u0026#39;|\u0026#39; + suff return self.map.get(key, -1) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_745_prefix_and_suffix_search_solution/","summary":"\u003cp\u003eFor each possible word, we ask the question: \u003cstrong\u003eWhat possible queries can lead to this word?\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor example consider the word: \u003ccode\u003eabd\u003c/code\u003e. Below are the possible (prefix, suffix) queries that can return \u003ccode\u003eabd\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(prefix, suffix)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    d\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  d\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  d\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eNow, given word.length \u0026lt;= 7. Each word can at maximum generate \u003ccode\u003e7*7=49\u003c/code\u003e such pairs. Can we store all of them in a hashmap? Yes, because the total storage = \u003ccode\u003e49 * number of words = O(n)\u003c/code\u003e Which is acceptable for this problem.\u003c/p\u003e","title":"Leetcode 745: prefix and suffix search solution"},{"content":"This problem is very similar to lc543, which is about finding the longest edge path in a tree. You can just copy over that code, and add 2 lines in it.\nHere we are doing the same thing as in lc543, however, when we encounter a non-matching child. We treat it as null.\nFor example, here the longest path at root node is highlighted below in red with 6 edges.\nOur algorithm views the tree like this. The longest path of 3 edges is highlighted in red.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int edges( struct TreeNode* node ); int longest_path; int longestUnivaluePath(struct TreeNode* root) { longest_path = 0; edges(root); return longest_path; } int edges( struct TreeNode* node ) { if ( !node ) return -1; int left = edges(node-\u0026gt;left), right = edges(node-\u0026gt;right); // treat child as null if it doesn\u0026#39;t match parent left = (node-\u0026gt;left \u0026amp;\u0026amp; node-\u0026gt;val == node-\u0026gt;left-\u0026gt;val) ? left : -1; right = (node-\u0026gt;right \u0026amp;\u0026amp; node-\u0026gt;val == node-\u0026gt;right-\u0026gt;val) ? right : -1; longest_path = fmax(longest_path, 1+left + 1+right); return 1 + fmax( left, right); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution: def __init__(self): self.ans = 0 def longestUnivaluePath(self, root: Optional[TreeNode]) -\u0026gt; int: self.edges( root ) return self.ans def edges(self, node: Optional[TreeNode]) -\u0026gt; int: if not node: return -1 left, right = self.edges( node.left ), self.edges( node.right ) # if the child is illegitimate. Discard it if not node.left or node.left.val != node.val: left = -1 # treat as null if not node.right or node.right.val != node.val: right = -1 self.ans = max( self.ans, ( 1+left ) + ( 1 + right ) ) return 1 + max( left, right ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function longestUnivaluePath(root: TreeNode | null): number { let ans = 0; const edges = ( node: TreeNode|null ): number =\u0026gt; { if ( !node ) return -1; let left = edges( node.left ), right = edges( node.right ); // if child value doesn\u0026#39;t match -\u0026gt; treat as null left = (node.left \u0026amp;\u0026amp; node.val == node.left.val) ? left : -1; right = (node.right \u0026amp;\u0026amp; node.val == node.right.val) ? right : -1; ans = Math.max( ans, (1 + left) + (1 + right) ); return 1 + Math.max( left, right ); } edges( root ); return ans; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function longestUnivaluePath(root) { let ans = 0; const edges = ( node ) =\u0026gt; { if ( !node ) return -1; let left = edges( node.left ), right = edges( node.right ); // if child value doesn\u0026#39;t match -\u0026gt; treat as null left = (node.left \u0026amp;\u0026amp; node.val == node.left.val) ? left : -1; right = (node.right \u0026amp;\u0026amp; node.val == node.right.val) ? right : -1; ans = Math.max( ans, (1 + left) + (1 + right) ); return 1 + Math.max( left, right ); } edges( root ); return ans; }; ","permalink":"http://localhost:45763/personal_website/posts/solution_to_leetcode_687_longest_univalue_path/","summary":"\u003cp\u003eThis problem is very similar to\n\u003ca href=\"https://leetcode.com/problems/diameter-of-binary-tree/solutions/6824338/solution-for-dummies-by-abdulrahim2002-yzrs/\"\u003elc543\u003c/a\u003e,\nwhich is about finding the longest edge path in a tree. You can just\ncopy over that code, and add 2 lines in it.\u003c/p\u003e\n\u003cp\u003eHere we are doing the same thing as in lc543, however, when we encounter a non-matching child. We treat it as null.\u003c/p\u003e\n\u003cp\u003eFor example, here the longest path at root node is highlighted below in red with 6 edges.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/148ffbfd-0ead-48cd-b45d-8c2575bafd11_1751999234.494938.png\"\u003e\u003c/p\u003e","title":"Solution to Leetcode 687: Longest Univalue Path"},{"content":"I keep track of the top k elements in sorted list. The kth largest element is the smallest of the top k elements.\ne.g. top k(=6) elements: [3,5,7,10,42,56] in sorted order. The kth largest element = 6th largest element = smallest element in above list.\nWhen I insert an element, I simply check if it can make it\u0026rsquo;s place among k largest elements already present in the list. Which it can, if it can defeat the smallest element in our list.\nFor example, we cannot add 2 in the array above since it fails to defeat 3.\nHowever, A number like 15 can be inserted. In which case, we remove the smallest element i.e. 3, to keep the list length=k\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class KthLargest: def __init__(self, k: int, nums: List[int]): self.scores = SortedList() self.limit = k for num in nums: self.add(num) def add(self, val: int) -\u0026gt; int: # if the current element can make space in top k elements if len(self.scores) \u0026lt; self.limit or self.scores[0] \u0026lt; val: self.scores.add(val) # remove smallest if len(self.scores) \u0026gt; self.limit: self.scores.pop(0) # return smallest return self.scores[0] ","permalink":"http://localhost:45763/personal_website/posts/leetcode_703_kth_largest_element_in_a_stream/","summary":"\u003cp\u003eI keep track of the top k elements in sorted list.\nThe kth largest element is the \u003cstrong\u003esmallest of the top k elements\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003ee.g. top k(=6) elements: \u003ccode\u003e[3,5,7,10,42,56]\u003c/code\u003e in sorted order.\nThe kth largest element = 6th largest element = smallest element in above list.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/070564ea-afa3-4108-92e6-7fa76c2fb981_1752504996.0140414.png\"\u003e\u003c/p\u003e\n\u003cp\u003eWhen I insert an element, I simply check if it can make it\u0026rsquo;s place among k largest elements already present in the list. Which it can, if it can defeat the smallest element in our list.\u003c/p\u003e","title":"Leetcode 703: kth largest element in a stream solution in python"},{"content":"When numbers from $$\\in$$ [0,n-1] are sorted in an array of size n. Their sorted position is equal to their index.\nSubset of numbers in array[i:j] can form a partition, if all elements in [i,j) are available in array[i:j].\nFor example [2,0,1] can form a partition, since they are at index 0, 1, 2 respectively. Sorted will involving swapping them at their correct position.\nThe basic idea behind this solution is that we try to identify such partitions, where all elements required to be sorted in [i, j] are available in current partition.\nHere\u0026rsquo;s the visualization of the algorithm, i points to the start of the group and j iterates through the group and checks if the current group needs to be expanded. e points to the end of the current group.\nSince, array[j]=1, we found a number greater than current boundaries. We need to expand the boundary. Hence, new group end is e = array[j].\nIncrement j. We find that array[1] = 0 which is \u0026lt; current end. Increment j again, j=2, Hence, no we exhaust the current group and we move forward to finding the next partition. Increase, current group ending, and reinitialize i=e/\nIn the second group, we have array[j]=2 and we are at index 2. Hence, we do not need to expand this group, since 2 is at right position.\nSimilarly we find the next 2 partitions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int maxChunksToSorted(int* arr, int arrSize) { int cur_gp_end = 0, cnt_gps = 0, i = 0; while ( i \u0026lt; arrSize ) { int j = i; // try to terminate the current group while ( j \u0026lt;= cur_gp_end ) { cur_gp_end = fmax( cur_gp_end, arr[j] ); j++; } i = ++cur_gp_end; cnt_gps++; } return cnt_gps; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_769_max_chunks_to_make_sorted/","summary":"\u003cp\u003eWhen numbers from $$\\in$$ \u003ccode\u003e[0,n-1]\u003c/code\u003e are sorted in an array of size n. Their sorted position is equal to their index.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/07a3b1d2-9478-486f-9f62-3a67e6dde1b3_1752513551.205261.png\"\u003e\u003c/p\u003e\n\u003cp\u003eSubset of numbers in \u003ccode\u003earray[i:j]\u003c/code\u003e can form a partition, if all elements in \u003ccode\u003e[i,j)\u003c/code\u003e are available in \u003ccode\u003earray[i:j]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFor example \u003ccode\u003e[2,0,1]\u003c/code\u003e can form a partition, since they are at index \u003ccode\u003e0, 1, 2\u003c/code\u003e respectively. Sorted will involving swapping them at their correct position.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/77d9235f-d72a-416a-bd77-d8802d7567b0_1752513786.651974.png\"\u003e\u003c/p\u003e\n\u003cp\u003eThe basic idea behind this solution is that we try to identify such partitions, where all elements required to be sorted in \u003ccode\u003e[i, j]\u003c/code\u003e are available in current partition.\u003c/p\u003e","title":"Leetcode 769: Max chunks to make sorted solution"},{"content":"For each word, we basically store all versions of it after removal of 1 character. For example,\n1 2 3 4 5 6 hello -\u0026gt; ello -\u0026gt; removed h@0 hllo -\u0026gt; removed e@1 helo -\u0026gt; removed l@2 helo -\u0026gt; removed l@3 hell -\u0026gt; removed o@4 We can store: wordAfterRemoval,indexOfRemoval in hashmap. So whenever we search for a word like: hexlo then we can try removing it\u0026rsquo;s 2nd index and search: helo,2 in the map, which we will find.\nIn the value we can store the removed character. For example, store key=helo,2 with value=l to indicate that l was removed.\nSo when you match a word like hexlo. Try to search helo,2 in the hashmap. It gives value=l which is !='x' i.e. the removed character in hexlo.\nHowever, there is one problem with this approach. When you add 2 words like: hello and hallo in the map. Then hllo,1 will give e in the first insertion and a in the second. The second overides the first so hello is forgetten by the structure. To avoid this issue, we store both of them (e, a) in a list.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class MagicDictionary { private map = new Map\u0026lt;string,string[]\u0026gt;(); buildDict(dictionary: string[]): void { for ( const word of dictionary ) { for ( let i=0; i \u0026lt; word.length; i++ ) { const wordAfterRemoval = word.slice(0, i) + word.slice(i+1); // key stores wordAfterRemoval,indexOfRemoval as value const key = `${wordAfterRemoval},${i}`; if ( !this.map.has(key) ) this.map.set(key,[]); // values have the removed character this.map.get(key).push( word[i] ) } } } search(word: string): boolean { for ( let i=0; i \u0026lt; word.length; i++ ) { const wordAfterRemoval = word.slice(0, i) + word.slice(i+1); const key = `${wordAfterRemoval},${i}`; if ( !this.map.has(key) ) continue; const removedChars = this.map.get(key); // If there was a word with removed character != word[i] for ( let j=0; j \u0026lt; removedChars.length; j++ ) { if ( removedChars[j] !== word[i] ) return true; } } return false; } } You can also embed the index information by replacing the removed word with _ like in this pyton version:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class MagicDictionary: def __init__(self): self.map = {} def buildDict(self, dictionary: List[str]) -\u0026gt; None: for word in dictionary: for i in range(len(word)): key = word[0:i] + \u0026#39;_\u0026#39; + word[i+1:] if not key in self.map: self.map[key] = [] self.map[key].append(word[i]) def search(self, searchWord: str) -\u0026gt; bool: for i in range(len(searchWord)): key = searchWord[0:i] + \u0026#39;_\u0026#39; + searchWord[i+1:] if key not in self.map: continue for c in self.map[key]: if c != searchWord[i]: return True return False # Your MagicDictionary object will be instantiated and called as such: # obj = MagicDictionary() # obj.buildDict(dictionary) # param_2 = obj.search(searchWord) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_676_magic_dictionary/","summary":"\u003cp\u003eFor each word, we basically store all versions of it after removal of 1 character. For example,\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehello -\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eello -\u0026gt; removed h@0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehllo -\u0026gt; removed e@1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehelo -\u0026gt; removed l@2\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehelo -\u0026gt; removed l@3\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehell -\u0026gt; removed o@4\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eWe can store: \u003ccode\u003ewordAfterRemoval,indexOfRemoval\u003c/code\u003e in hashmap. So whenever we search for a word like: \u003ccode\u003ehexlo\u003c/code\u003e then we can try removing it\u0026rsquo;s 2nd index and search: \u003ccode\u003ehelo,2\u003c/code\u003e in the map, which we will find.\u003c/p\u003e","title":"Leetcode 676: magic dictionary"},{"content":"consider the word \u0026ldquo;catsdogcats\u0026rdquo;. We have the dictionary: [\u0026quot;cat\u0026quot;,\u0026quot;cats\u0026quot;,\u0026quot;catsdogcats\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;dogcatsdog\u0026quot;,\u0026quot;hippopotamuses\u0026quot;,\u0026quot;rat\u0026quot;,\u0026quot;ratcatdogcat\u0026quot;]\nWe iterate over the word: catsdogcats and at each iteration, we ask if the prefix is contained in dictionary.\nIf the prefix is in the dictionary, we recursively call the function on the remaining word (excluding matched prefix)\nis c in dictionary ? is ca in dictionary ? is cat in dictionary ? -\u0026gt; YES call( sdogcats ) \u0026ndash;[1] Prefix cat matched so recursively call with sdogcats\nis s in dictionary ? is sd in dictionary ? \u0026hellip;. is sdogcats in dictionary ? NO We exhausted the word so we return false. Nothing was matched\nBack at the first call, this time we try to match cats Return to [1]\nis cats in dictionary -\u0026gt; YES recursively call on dogcats\nis d in dictionary ?\nis do in dictionary ?\nis dog in dictionary ? -\u0026gt; YES, recursively call on cats\nis c in dictionary ?\nis ca in dictionary ?\nis cat in dictionary ? YES , recursively call(s) \u0026ndash;[2]\nis s in dictionary ? NO -\u0026gt; word exhausted, return false;\nBack at recursive call [2]\nis cats in dictionary ? YES recursively call(``) i.e. empty string When we reach empty string, it means whole of string can be constructed using words in dictionary. Hence return true.\nImport considerations:\nThe dictionary has all the words, which means that catsdogcats will match with itself completely. To avoid words matching with themselves, we tell the function to ignore the catsdogcats word to avoid matching it with itself. Also, we can memoize the results since, dictionary remains the same, only target word and ignore word changes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function findAllConcatenatedWordsInADict(words: string[]): string[] { const dict = new Set\u0026lt;string\u0026gt;( words ); return words.filter( curWord =\u0026gt; canChunk( curWord, curWord, dict ) ); }; function canChunk( target: string, ignore: string, dict: Set\u0026lt;string\u0026gt;, memo = new Map\u0026lt;string, boolean\u0026gt;() ): boolean { if ( !target.length ) return true; const key = target + ignore; if ( memo.has( key ) ) return memo.get( key ); for ( let i=1; i \u0026lt;= target.length; i++ ) { const prefix = target.slice( 0, i ); if ( prefix !== ignore \u0026amp;\u0026amp; dict.has( prefix ) \u0026amp;\u0026amp; canChunk( target.slice( i ), ignore, dict, memo ) ) { memo.set( key, true ); return true; } } memo.set( key, false ); return false; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_472_concatenated_words/","summary":"\u003cp\u003econsider the word \u0026ldquo;catsdogcats\u0026rdquo;. We have the dictionary: \u003ccode\u003e[\u0026quot;cat\u0026quot;,\u0026quot;cats\u0026quot;,\u0026quot;catsdogcats\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;dogcatsdog\u0026quot;,\u0026quot;hippopotamuses\u0026quot;,\u0026quot;rat\u0026quot;,\u0026quot;ratcatdogcat\u0026quot;]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWe iterate over the word: \u003ccode\u003ecatsdogcats\u003c/code\u003e and at each iteration, we ask if the prefix is contained in dictionary.\u003c/p\u003e\n\u003cp\u003eIf the prefix is in the dictionary, we recursively call the function on the remaining word (excluding matched prefix)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eis \u003ccode\u003ec\u003c/code\u003e in dictionary ?\u003c/li\u003e\n\u003cli\u003eis \u003ccode\u003eca\u003c/code\u003e in dictionary ?\u003c/li\u003e\n\u003cli\u003eis \u003ccode\u003ecat\u003c/code\u003e in dictionary ? -\u0026gt; YES       call( \u003ccode\u003esdogcats\u003c/code\u003e ) \u0026ndash;[1]\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePrefix \u003ccode\u003ecat\u003c/code\u003e matched so recursively call with \u003ccode\u003esdogcats\u003c/code\u003e\u003c/p\u003e","title":"Leetcode 472: Concatenated words"},{"content":"The task is to find a subarray with sum of elements = k\nTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\nThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\n$$ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k] $$\nNow we are looking for sub of subarray = T(target). Therefore:\n$$ sum\\ of\\ subarray = prefix\\ [j]\\ -\\ prefix\\ [i-1] = T\\ \\ prefix\\ [i-1] = prefix\\ [j]\\ - T $$\nTherefore, we iterate the prefix array. And at each prefix[j], we search for a previously inserted prefix[i-1] such that prefix[i-1] = prefix[j] - T. We also need the count of such subarrays. At a particular j the number of subarrays where sum=T is the number of i that occured previously such that prefix[i-1] = prefix[j] - T. Index j will form a subarray with each of such previous i\u0026rsquo;s.\nWe must store the mapping: ( prefix[x], count ) in a map.\nSo far so good. But what happens when $$i=0$$. In this case, sum of subarray between indices [0, j] is defined as:\n$$ prefix\\ [j] = \\sum_{k=0}^j nums\\ [k] = T $$\nAt each index j, the code will try to look for prefix[j] - T in the map. When prefix[j]=T itself, then it would look for T-T=0 into the map. Therefore we must keep prefix= 0, count= 1 into the map to account for subarrays starting at index 0.\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 function subarraySum(nums: number[], k: number): number { const map = new Map\u0026lt;number, number\u0026gt;([ [0, 1] ]); let sumk = 0; for ( let j=0; j \u0026lt; nums.length; j++ ) { nums[j] = ( j==0 ) ? nums[j] : nums[j-1] + nums[j]; sumk += map.get( nums[j] - k ) ?? 0; map.set( nums[j], ( map.get(nums[j]) ?? 0 ) + 1 ); } return sumk; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_560_subarray_sub_equal_k_solution/","summary":"\u003cp\u003eThe task is to find a subarray with \u003ccode\u003esum of elements = k\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\u003c/p\u003e\n\u003cp\u003eThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\u003c/p\u003e\n\u003cp\u003e$$\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k]\n$$\u003c/p\u003e","title":"Leetcode 560: Subarray sum equals k"},{"content":"Consider the array: [0,1,1,0,0,1,1,0,1,1] The idea is to turn the 0\u0026rsquo;s into -1\u0026rsquo;s\narray: [-1,1,1,-1,-1,1,1,-1,1,1]\nNow, the task is to find a subarray with sum of elements = 0\nTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\nThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\n$$ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k] $$\nAnd the length of the subarray between indices $$[i,j]$$ is defined as: $$length(i,j) = j-i+1 = j-(i-1) $$\nNow we are looking for sub of subarray = 0. Therefore:\n$$ sum\\ of\\ subarray = prefix\\ [j]\\ -\\ prefix\\ [i-1] = 0\\ prefix\\ [j]\\ =\\ prefix\\ [i-1] $$\nTherefore, we iterate the prefix array. And at each prefix[j], we search for a previously inserted prefix[i-1] such that prefix[j]=prefix[i-1]. We record the length of the current subarray as: length = j-(i-1).\nWe must store the mapping: ( prefix[k], k ) in a map to achieve this.\nSo far so good. But what happens when $$i=0$$. In this case, sum of subarray between indices [0, j] is defined as:\n$$ prefiix\\ [j] = \\sum_{k=0}^j nums\\ [k] $$\nAnd the length of the subarray [0,j] is: $$j+1 = j-(-1)$$\nTherefore we keep a superficial (prefix = 0, index = -1) in the map.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function findMaxLength(nums: number[]): number { const map = new Map\u0026lt;number, number\u0026gt;( [ [0, -1], ] ); let maxLen = 0; for ( let j=0; j \u0026lt; nums.length; j++ ) { let cur = ( nums[j] == 1 ) ? 1 : -1; nums[j] = ( j==0 ) ? cur : cur + nums[j-1]; // prefix sum occured previously at i. Length = j-i if ( map.has( nums[j] ) ) { let i = map.get( nums[j] ); maxLen = Math.max( maxLen, j - i ); } // put the current prefix sum into map if ( !map.has( nums[j] ) ) map.set( nums[j], j ); } return maxLen; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_525_contiguous_array/","summary":"\u003cp\u003eConsider the array: \u003ccode\u003e[0,1,1,0,0,1,1,0,1,1] \u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe idea is to turn the 0\u0026rsquo;s into -1\u0026rsquo;s\u003c/p\u003e\n\u003cp\u003earray: \u003ccode\u003e[-1,1,1,-1,-1,1,1,-1,1,1]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eNow, the task is to find a subarray with \u003ccode\u003esum of elements = 0\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\u003c/p\u003e\n\u003cp\u003eThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\u003c/p\u003e\n\u003cp\u003e$$\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k]\n$$\u003c/p\u003e","title":"Leetcode_525_contiguous_array"},{"content":"The idea is to keep 2 pointers. trail pointer and cur pointer. The list is build in recursive function build(trail, cur) which returns last node of the list we build.\nbuild works as follows:\nwhen there is no child node: simply connect trail and cur and advance both when there is a child node, then recursively call itself with build( trail = cur, cur = cur.child ). The call would connect cur node with the list in the next level. It would return the last node in next level. Then we assign trail = last node in next level and cur = cur.next in current level. This ensures that the next iteration would connect last node in next level to next node in current level. when cur becomes null trail is the last node in current level. return trail Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function flatten(head: _Node | null): _Node | null { const save: _Node = new _Node( -1 ); build( save, head ); if ( save.next ) save.next.prev = null; return save.next; }; function build( trail: _Node | null, cur: _Node | null ): _Node | null { while ( cur ) { if ( !cur.child ) { trail.next = cur; cur.prev = trail; trail = trail.next; cur = cur.next; } else { trail.next = cur; cur.prev = trail; const saveNext = cur.next; const lastNodeFromChildList = build( cur, cur.child ); cur.child = null; cur = saveNext; trail = lastNodeFromChildList; } } return trail; } Complexity Time complexity: $$O(n)$$\nSpace complexity: $$O(n)$$ {recursion stack}\n","permalink":"http://localhost:45763/personal_website/posts/leetcode_430_flattening_multilevel_linked_list/","summary":"\u003cp\u003eThe idea is to keep 2 pointers. \u003ccode\u003etrail\u003c/code\u003e pointer and \u003ccode\u003ecur\u003c/code\u003e pointer. The\nlist is build in recursive function \u003ccode\u003ebuild(trail, cur)\u003c/code\u003e which returns\nlast node of the list we build.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebuild\u003c/code\u003e works as follows:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ewhen there is no \u003ccode\u003echild\u003c/code\u003e node: simply connect \u003ccode\u003etrail\u003c/code\u003e and \u003ccode\u003ecur\u003c/code\u003e and advance both\u003c/li\u003e\n\u003cli\u003ewhen there is a \u003ccode\u003echild\u003c/code\u003e node, then recursively call itself with \u003ccode\u003ebuild( trail = cur, cur = cur.child )\u003c/code\u003e. The call would connect \u003ccode\u003ecur\u003c/code\u003e node with the \u003ccode\u003elist in the next level\u003c/code\u003e. It would return the last node in next level. Then we assign \u003ccode\u003etrail = last node in next level\u003c/code\u003e and \u003ccode\u003ecur = cur.next in current level\u003c/code\u003e. This ensures that the next iteration would connect \u003ccode\u003elast node in next level\u003c/code\u003e to \u003ccode\u003enext node in current level\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003ewhen \u003ccode\u003ecur\u003c/code\u003e becomes \u003ccode\u003enull\u003c/code\u003e \u003ccode\u003etrail\u003c/code\u003e is the last node in current level. \u003ccode\u003ereturn trail\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"code\"\u003eCode\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003eflatten\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ehead\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kr\"\u003econst\u003c/span\u003e   \u003cspan class=\"nx\"\u003esave\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ehead\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003esaveNext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003elastNodeFromChildList\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003esaveNext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003elastNodeFromChildList\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"complexity\"\u003eComplexity\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTime complexity:  $$O(n)$$\u003c/p\u003e","title":"Leetcode 430: Flattening a multilevel linked list"},{"content":"Below is my solution for the leetcode 154: Find minimum in rotated sorted array problem\nIntuition Fact is, that you cannot solve this question in O(log n) time. The reason is because of duplicates.\nConsider a situation like:\n$$ [2,2,2,2,1,2,2] $$\nwhere mid is at 3 and the minium number here is clearly $$1$$. But our binary search algorithm will not be able to figure out in which direction it should go, since starting, ending and middle values are all same. In this case the best we can do is increment mid which makes the worst running time: O(n)\nHowever, it is possible to solve this problem in O(n/2) as explain below.\nApproach We will make use of the fact that a sorted array follows the (min) heap property i.e. in a sorted array, at all parent nodes are smaller than their children.\nAnd if this sorted array is rotated, then the place at which the first violation occurs is the subtree where the answer will be found.\nComplexity Time complexity: $$O(n/2)$$ Space complexity: $$O(1)$$ Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 var findMin = function(a) { /** Approach: You cannot solve this problem in O(log n) since it contains duplicate values. But you can actually solve this problem in O(n/2) by using the fact that a sorted array follows heap property. And if a sorted array is rotated then the heap property no longer holds. to find the minium element traverse the array, and find the first subtree where the heap property does not hold. the minium of the 2 values where the heap property does not satisfy is also minium in the array. Time: O(n/2) Space: O(1) */ let A = a.length; let i = 0; while ( i \u0026lt;= Math.floor(A/2)-1 ) { let root = i; let lc = 2*i + 1; let rc = 2*i + 2; let smallest = root; if ( lc \u0026lt; A \u0026amp;\u0026amp; a[lc] \u0026lt; a[smallest] ) smallest = lc; if ( rc \u0026lt; A \u0026amp;\u0026amp; a[rc] \u0026lt; a[smallest] ) smallest = rc; if ( smallest != root ) /* violation found. the value at smallest is minium */ return a[smallest]; i++; } /* no violation found. Either the array is sorted ar there it is all duplicates, in either case, return the first element. */ return a[0]; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_154_find_minimum_in_rotated_sorted_array/","summary":"\u003cp\u003eBelow is my solution for the \u003ca href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/\"\u003eleetcode 154: Find minimum in rotated\nsorted array problem\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"intuition\"\u003eIntuition\u003c/h1\u003e\n\u003c!-- Describe your first thoughts on how to solve this problem. --\u003e\n\u003cp\u003eFact is, that you \u003cstrong\u003ecannot\u003c/strong\u003e solve this question in \u003cstrong\u003eO(log n)\u003c/strong\u003e time. The reason is because of duplicates.\u003c/p\u003e\n\u003cp\u003eConsider a situation like:\u003c/p\u003e\n\u003cp\u003e$$\n[2,2,2,2,1,2,2]\n$$\u003c/p\u003e\n\u003cp\u003ewhere mid is at 3 and the minium number here is clearly $$1$$. But our binary search algorithm will not be able to figure out in which direction it should go, since starting, ending and middle values are all same. In this case the best we can do is increment mid which makes the worst running time: \u003cstrong\u003eO(n)\u003c/strong\u003e\u003c/p\u003e","title":"Leetcode 154: Find minimum in rotated sorted array"},{"content":"Here\u0026rsquo;s my solution to the Leetcode 315: Count of Smaller Numbers After Self problem using standard merge sort. I just change one line to count while merge procedure.\nSolution Let\u0026rsquo;s build the solution step by step.\nInput: nums = $$[5,2,6,1]$$\nFirst, turn the numbers into [number, index] tuple. So it looks like:\narray = $$ [ [ 5, 0 ], [ 2, 1 ], [ 6, 2 ], [ 1, 3 ] ] $$\nSecond, just write standard merge sort algorithm and sort the array in ascending order by first values.\nThe output is: $$ [ [ 1, 3 ], [ 2, 1 ], [ 5, 0 ], [ 6, 2 ] ] $$\nHere\u0026rsquo;s the trace of the algorithm:\nSimple merge sort implemented 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { tmp.push( a[j] ); j++; } else { tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); merge_sort( array, 0, array.length-1 ); }; So far so good.\nNow let\u0026rsquo;s get back to the question. The question is asking: For each index $$i$$, count all numbers at index $$j$$ such that $$i \u0026lt; j$$ and $$a[i] \u0026gt; a[j]$$. Or, simply put: for each number, find all numbers that appear after it and are smaller than it.\nNow, look at the visualization again, pay attention to the merge procedure (in magenta colour) and observe the following:\nat each merge procedure, we merge 2 consecutive partitions. all numbers in the left partition appear before numbers in right partition in the original array. The partitions are sorted in increasing order. Now, suppose we are merging 2 partitions where, the pointer of left partition is at $$x$$ and pointer of right partition is at $$y$$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [....a,b,c, x ,d,e,f....] [...h,i,j, y, k,l,m....] ^ ^ i j Suppose x \u0026gt; y It follows from observation 2 that: y is one of the numbers that appear to the right of x and is smaller than x ---(1) Also, since partitions are sorted (observation 3): d, e, f .... (i.e. all number that appear to the right of x) are greater than x. ----(2) From (1) and (2) we can conclude that: x, d, e, f, ... (i.e. all numbers to the right of x including x) appear before y. And y is smaller than all these numbers. Hence, required condition satisfied! Now, we just need a counter for each variable, and whenever the condition same as above occurs, we increment the counter for each x,d,e,\u0026hellip;\n1 2 3 4 5 6 7 [....a,b,c, x ,d,e,f....] [...h,i,j, y, k,l,m....] ^ ^ i j while merging: if x \u0026gt; y increment the counters of x, d, e, f, ... Single line changed in standard merge sort algorithm We can use the index at the second position to access the counter of that particular number.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 let counts; const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { /* ____(x \u0026gt; y) so increment counters of x,d,e,...____*/ for ( let p=i; p\u0026lt;=mid; p++ ) counts[ a[p][1] ]++; /*_______________INSERT THIS LINE_____________________*/ tmp.push( a[j] ); j++; } else { tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); counts = new Array(nums.length).fill(0); merge_sort( array, 0, array.length-1 ); return counts; }; That is the whole idea behind this question. Now the above implementation won\u0026rsquo;t work because at each iteration, we are updating whole left partition after i. Making it O(n^2) Optimize To avoid updating the whole partition, we keep a running counter cnt.\nFinal implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 let counts; const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; let cnt = 0; // keep running counter while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { cnt++; // increment counter tmp.push( a[j] ); j++; } else { counts[ a[i][1] ] += cnt; // no more numbers that are // smaller than i tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { counts[ a[i][1] ] += cnt; // if left partition is not over // update left over number counts tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); counts = nums; counts.fill(0); merge_sort( array, 0, array.length-1 ); return counts; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def countSmaller(nums): counts = [0] * len(nums) array = [(num, i) for i, num in enumerate(nums)] def merge_sort(start, end): if start == end: return mid = (start + end) // 2 merge_sort(start, mid) merge_sort(mid + 1, end) merge(start, mid, end) def merge(start, mid, end): temp = [] i, j = start, mid + 1 cnt = 0 while i \u0026lt;= mid and j \u0026lt;= end: if array[i][0] \u0026gt; array[j][0]: cnt += 1 temp.append(array[j]) j += 1 else: counts[array[i][1]] += cnt temp.append(array[i]) i += 1 while i \u0026lt;= mid: counts[array[i][1]] += cnt temp.append(array[i]) i += 1 while j \u0026lt;= end: temp.append(array[j]) j += 1 for i in range(len(temp)): array[start + i] = temp[i] merge_sort(0, len(nums) - 1) return counts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; countSmaller(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; counts(nums.size(), 0); vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; array; for (int i = 0; i \u0026lt; nums.size(); i++) { array.emplace_back(nums[i], i); } function\u0026lt;void(int, int)\u0026gt; merge_sort = [\u0026amp;](int start, int end) { if (start == end) return; int mid = start + (end - start) / 2; merge_sort(start, mid); merge_sort(mid + 1, end); merge(start, mid, end); }; function\u0026lt;void(int, int, int)\u0026gt; merge = [\u0026amp;](int start, int mid, int end) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; temp; int i = start, j = mid + 1; int cnt = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end) { if (array[i].first \u0026gt; array[j].first) { cnt++; temp.push_back(array[j]); j++; } else { counts[array[i].second] += cnt; temp.push_back(array[i]); i++; } } while (i \u0026lt;= mid) { counts[array[i].second] += cnt; temp.push_back(array[i]); i++; } while (j \u0026lt;= end) { temp.push_back(array[j]); j++; } for (int k = 0; k \u0026lt; temp.size(); k++) { array[start + k] = temp[k]; } }; merge_sort(0, nums.size() - 1); return counts; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import java.util.*; class Solution { private int[] counts; private int[][] array; public List\u0026lt;Integer\u0026gt; countSmaller(int[] nums) { counts = new int[nums.length]; array = new int[nums.length][2]; for (int i = 0; i \u0026lt; nums.length; i++) { array[i][0] = nums[i]; array[i][1] = i; } mergeSort(0, nums.length - 1); List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (int count : counts) { result.add(count); } return result; } private void mergeSort(int start, int end) { if (start == end) return; int mid = start + (end - start) / 2; mergeSort(start, mid); mergeSort(mid + 1, end); merge(start, mid, end); } private void merge(int start, int mid, int end) { List\u0026lt;int[]\u0026gt; temp = new ArrayList\u0026lt;\u0026gt;(); int i = start, j = mid + 1; int cnt = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end) { if (array[i][0] \u0026gt; array[j][0]) { cnt++; temp.add(array[j]); j++; } else { counts[array[i][1]] += cnt; temp.add(array[i]); i++; } } while (i \u0026lt;= mid) { counts[array[i][1]] += cnt; temp.add(array[i]); i++; } while (j \u0026lt;= end) { temp.add(array[j]); j++; } for (int k = 0; k \u0026lt; temp.size(); k++) { array[start + k] = temp.get(k); } } } Time: $$O(n\\ log\\ n)$$ Space: $$O(n)$$ ","permalink":"http://localhost:45763/personal_website/posts/leetcode_315_count_of_smaller_numbers_after_self/","summary":"\u003cp\u003eHere\u0026rsquo;s my solution to the \u003ca href=\"https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/\"\u003eLeetcode 315: Count of Smaller Numbers After\nSelf problem\u003c/a\u003e using standard merge sort. I just change one line to\ncount while merge procedure.\u003c/p\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\n\u003cp\u003eLet\u0026rsquo;s build the solution step by step.\u003c/p\u003e\n\u003cp\u003eInput: nums = $$[5,2,6,1]$$\u003c/p\u003e\n\u003cp\u003eFirst, turn the numbers into \u003cstrong\u003e[number, index]\u003c/strong\u003e tuple. So it looks like:\u003c/p\u003e\n\u003cp\u003earray = $$ [ [ 5, 0 ], [ 2, 1 ], [ 6, 2 ], [ 1, 3 ] ] $$\u003c/p\u003e","title":"Leetcode 315: Count of Smaller Numbers After Self"},{"content":"Here\u0026rsquo;s my explanation for the leetcode 306: Additive Number problem\nAdditive Number Problem Problem Recap An additive number is a string of digits where the sequence of numbers formed by splitting the string satisfies the condition that each number (after the first two) is the sum of the two preceding numbers.\nExamples: \u0026quot;112358\u0026quot; is additive because the sequence is 1, 1, 2, 3, 5, 8, and:\n1 + 1 = 2 1 + 2 = 3 2 + 3 = 5 3 + 5 = 8 \u0026quot;199100199\u0026quot; is additive because the sequence is 1, 99, 100, 199, and:\n1 + 99 = 100 99 + 100 = 199 Solution Approach The solution uses a backtracking approach to try all possible splits of the string into sequences of numbers and checks if any of these sequences form an additive sequence.\nDetailed Explanation Helper Function isValid This recursive function checks if the remaining part of the string s forms a valid additive sequence given the first two numbers a and b.\nBase Case: If the remaining string s is empty, it means we\u0026rsquo;ve successfully formed an additive sequence, so return true.\nRecursive Step:\nCompute the sum of a and b and convert it to a string sum. Check if the remaining string s starts with sum: If not, the sequence is invalid  return false. If yes, recursively check the next part of the string with the new pair (b, sum) and the remaining string after removing sum. Main Function isAdditiveNumber Initialization: Get the length of the input string num. Nested Loops: The outer loop (i) determines the end index of the first number a (from index 0 to i). The inner loop (j) determines the end index of the second number b (from index i to j). Leading Zero Check: Skip any splits where a or b have leading zeros unless they are exactly \u0026quot;0\u0026quot;. Example: \u0026quot;02\u0026quot; is invalid, but \u0026quot;0\u0026quot; is valid. Validation: For each valid pair (a, b), call isValid to check if the remaining part of the string forms a valid additive sequence starting with a and b. If isValid returns true, immediately return true from the main function. Final Check: If no valid sequence is found after all possible splits, return false. Example Walkthrough Let\u0026rsquo;s walk through the example num = \u0026quot;112358\u0026quot;:\nFirst Iteration (i = 1, j = 2): a = \u0026quot;1\u0026quot;, b = \u0026quot;1\u0026quot;. No leading zeros  proceed. isValid(1, 1, \u0026quot;2358\u0026quot;): Sum of 1 + 1 = 2. Check if \u0026quot;2358\u0026quot; starts with \u0026quot;2\u0026quot;  Yes. Recursively call isValid(1, 2, \u0026quot;358\u0026quot;): Sum of 1 + 2 = 3. Check if \u0026quot;358\u0026quot; starts with \u0026quot;3\u0026quot;  Yes. Recursively call isValid(2, 3, \u0026quot;58\u0026quot;): Sum of 2 + 3 = 5. Check if \u0026quot;58\u0026quot; starts with \u0026quot;5\u0026quot;  Yes. Recursively call isValid(3, 5, \u0026quot;8\u0026quot;): Sum of 3 + 5 = 8. Check if \u0026quot;8\u0026quot; starts with \u0026quot;8\u0026quot;  Yes. Recursively call isValid(5, 8, \u0026quot;\u0026quot;): Empty string  return true. Since isValid returned true, the main function returns true. Edge Cases Leading Zeros: Correctly skips invalid splits (e.g., \u0026quot;02\u0026quot; unless it\u0026rsquo;s \u0026quot;0\u0026quot;). Single Digit: If input length \u0026lt; 3, returns false. Large Numbers: Uses parseInt, but BigInt is better for very large numbers to avoid precision issues. Time Complexity Nested loops: O(n), where n is the string length. isValid function: O(n) per pair (a, b). Overall: O(n), feasible for reasonably sized strings. Space Complexity O(n) due to recursion stack in the worst case. Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var isAdditiveNumber = function(num) { const isValid = (a, b, s) =\u0026gt; { if (s.length === 0) return true; const sum = (a + b).toString(); return s.startsWith(sum) \u0026amp;\u0026amp; isValid(b, parseInt(sum), s.slice(sum.length)); }; const n = num.length; for (let i = 1; i \u0026lt; n; i++) { for (let j = i + 1; j \u0026lt; n; j++) { const a = num.slice(0, i); const b = num.slice(i, j); if ((a.startsWith(\u0026#39;0\u0026#39;) \u0026amp;\u0026amp; a.length \u0026gt; 1) || (b.startsWith(\u0026#39;0\u0026#39;) \u0026amp;\u0026amp; b.length \u0026gt; 1)) continue; if (isValid(parseInt(a), parseInt(b), num.slice(j))) return true; } } return false; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 var isAdditiveNumber = function(num) { let N = num.length; let check = ( a ) =\u0026gt; { /** check if numbers in an array form fibonacci seqence **/ let A = a.length; if ( A \u0026lt; 3 ) return false; for ( let i=2; i \u0026lt; A; i++ ) if ( Number(a[i]) != Number(a[i-1]) + Number(a[i-2]) || ( a[i].length \u0026gt; 1 \u0026amp;\u0026amp; a[i].startsWith(\u0026#39;0\u0026#39;) ) || ( a[i-1].length \u0026gt; 1 \u0026amp;\u0026amp; a[i-1].startsWith(\u0026#39;0\u0026#39;) ) || ( a[i-2].length \u0026gt; 1 \u0026amp;\u0026amp; a[i-2].startsWith(\u0026#39;0\u0026#39;) ) ) return false; return true; }; let bt_search = ( i, cur = [] ) =\u0026gt; { if ( i \u0026gt; N ) return false; if ( i === N \u0026amp;\u0026amp; check(cur) ) return true; // num[i] starts a new number, explore path cur.push( num[i] ); let new_start = bt_search( i+1, cur ); if ( new_start ) return true; // backtrack, num[i] continues the previous number cur.pop(); if ( i \u0026gt; 0 ) { cur[ cur.length-1 ] += num[i]; let add_prev = bt_search( i+1, cur ); if ( add_prev ) return true; } return false; }; return bt_search( 0 ); }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_306_additive_number/","summary":"\u003cp\u003eHere\u0026rsquo;s my explanation for the \u003ca href=\"https://leetcode.com/problems/additive-number/description/\"\u003eleetcode 306: Additive Number problem\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"additive-number-problem\"\u003eAdditive Number Problem\u003c/h2\u003e\n\u003ch3 id=\"problem-recap\"\u003eProblem Recap\u003c/h3\u003e\n\u003cp\u003eAn \u003cstrong\u003eadditive number\u003c/strong\u003e is a string of digits where the sequence of numbers formed by splitting the string satisfies the condition that each number (after the first two) is the sum of the two preceding numbers.\u003c/p\u003e\n\u003ch4 id=\"examples\"\u003eExamples:\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026quot;112358\u0026quot;\u003c/code\u003e is additive because the sequence is \u003ccode\u003e1, 1, 2, 3, 5, 8\u003c/code\u003e, and:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e1 + 1 = 2\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e1 + 2 = 3\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e2 + 3 = 5\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e3 + 5 = 8\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026quot;199100199\u0026quot;\u003c/code\u003e is additive because the sequence is \u003ccode\u003e1, 99, 100, 199\u003c/code\u003e, and:\u003c/p\u003e","title":"Leetcode 306: Additive number"},{"content":"Here are all possible solutions I could come up with for the longest increasing subsequence problem. leetcode 300\nApproach 1: Generate all possible increasing subsequences We will keep track of a subsequence in an array named cur_subsequence or cur_sub. For each element (a[i]) we have the following 2 options:\nAdd the element to the end of current subsequence.\nNote: The current element can only be included if either the current subsequence is empty or the last element of the current subsequence is smaller than the current element. This is important to maintain the increasing subsequence property.\nIgnore the current element and explore without a[i]\nTime complexity: $$ O(2^N) $$ Space complexity: $$ O(N) $$ // recursion stack + auxilary array 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 var lengthOfLIS = function(a) { let A = a.length; // maximum length of a subsequence seen so far let max_len = 1; let bt_search = ( i, cur_sub = [] ) =\u0026gt; { if ( i \u0026gt;= A ) { max_len = Math.max( max_len, cur_sub.length ); return; } // either select the ith element, or ignore it. // a[i] can be taken when either subsequencee is empty or // last inserted element is smaller if ( !cur_sub.length || cur_sub[ cur_sub.length-1 ] \u0026lt; a[i] ) { cur_sub.push( a[i] ); bt_search( i+1, cur_sub ); cur_sub.pop(); // backtrack } // explore without a[i] included bt_search( i+1, cur_sub ); }; bt_search(0); return max_len; } Approach 2 (Version 1) : Generating all possible subsequences, but change the structure of the recursion to allow memoization Currently, we are keeping track of the current subsequence in an array cur_sub which makes it difficult for us to implement memoization. Notice that we only need previously selected element (to compare if current element is larger) and current length (to find the subsequence length). Hence, we will only use 3 variables: index, previous element index, current length.\nTime complexity: $$ O( N^2 ) $$ Space complexity: $$O( N^3 )$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 var lengthOfLIS = function(a) { /** Write a recurrence relation. Either you take the element @i or your ignore it. In either case, your pick the maximum length. generating all possible increasing subsequences, but not storing the subsequence and using only 3 variables. for each call(index, prev_selected, cur_length) we try to find the maximum length we can form by either selecting or rejecting a[i] This configuration is easy to memoize. **/ let A = a.length; let memo = new Map(); let bt_search = ( i, prev, cur_len = 0 ) =\u0026gt; { // inputs of the function are memoized by turning // them into a String `key` let key = JSON.stringify( [i, prev, cur_len] ); if (memo.has(key)) return memo.get(key); if ( i \u0026gt;= A ) return cur_len; let take = -1, not_take = -1; // a[i] can be taken if prev=null / cur_len=0 // or prev \u0026lt; a[i] if ( cur_len == 0 || prev \u0026lt; a[i] ) take = bt_search( i+1, a[i], cur_len+1 ); // backtrack. do not take a[i] not_take = bt_search( i+1, prev, cur_len ); let res = Math.max( take, not_take ); memo.set(key, res); return memo.get(key); }; return bt_search(0); } Approach 2 (Version 2): Yet another recursive solution, but with better memoization This solution memoizes using only: index of current element (i), index of previously selected element (prev_i).\nThe memoization is done in a matrix of size $$N$$X$$(N+1)$$.\nTime complexity: $$ O( N^2 ) $$ Space complexity: $$O( N^2 )$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 var lengthOfLIS = function(a) { /** Approach 2 (version 2): Instead of storing 3 variables, just store 2 variables. This will enable memoization table to be an NxN matrix. **/ let A = a.length; let memo = new Array( A ).fill(null).map( () =\u0026gt; new Array( A+1 ).fill( null ) ); let bt_search = ( i, prev_i = -1 ) =\u0026gt; { // y is remapped since prev_i is in range [-1,n-1] // but our array ranges is in range [0, n] let x = i, y = prev_i + 1; if ( i \u0026gt;= A ) return 0; if ( memo[x][y] !== null ) return memo[x][y]; let take = -1, not_take = -1; // a[i] can be taken if prev_i = -1 / cur_len=0 or // a[prev_i] \u0026lt; a[i] if ( prev_i == -1 || a[prev_i] \u0026lt; a[i] ) take = 1 + bt_search( i+1, i ); // backtrack. do not take a[i]. The length remains same not_take = bt_search( i+1, prev_i ); let res = Math.max( take, not_take ); memo[x][y] = res; return memo[x][y]; }; return bt_search(0); } Approach 3: Dynamic programming Declare a lis(longest increasing subsequence) array, where lis[i] denotes the length of longest increasing subsequence starting at i and ending at the end of the array. Fill this table from second last element towards first element.\nTo find lis[i] for an element a[i] use the following algorithm:\nFor each i \u0026lt;- n-2 - 0 // find if index i can form an increasing subsequence // with any element on the right of it max_len = 1 For each j \u0026lt;- i+1 - n if ( a[i] \u0026lt; a[j] ) // a[j] is a potential connection point max_len = MAX( max_len, 1 + lis[j] ) lis[i] = max_len The basic intuition behind it is, that we explore all elements to the right of a[i] which can connect with a[i] to form an increasing subsequence. The length of such a subsequence is given by:\n1 (length of a[i]) + length of longest subsequence from a[j] up until the end of the array\nwhich is same as: 1 + lcs[j]\nTime: $$O(n^2)$$ Space: $$O(n)$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 let MAX = Math.max; var lengthOfLIS = function(a) { /** Appraoch 3: Build the dp table manually using loops **/ let A = a.length; let lis = new Array( A ).fill(1); // global maximum, subsequence length from a[i] until end let gmax = 1; for ( let i = A-2; i \u0026gt;= 0; i-- ) { let max_len = 1; for ( let j = i+1; j \u0026lt; A; j++ ) { if ( a[i] \u0026lt; a[j] ) max_len = MAX( max_len, 1+lis[j] ); } lis[i] = max_len; gmax = MAX( max_len, gmax ); } return gmax; } Approach 4: Build an auxilary array, such that the minium elements are always at the end of it Here, we are basically trying to kick out large elements and inserting small elements whereever possible, so that new incoming elements feel welcome attaching themselves to the existing subsequence.\nBuild a auxilary array using the following algorithm:\nsubsequence = [] For each i \u0026lt;- 0 to A-1 if subsequence.last_element \u0026lt; a[i] subsequence.push( a[i] ) else { replace the largest element smaller than or equal to a[i] in subsequence using binary search. } the length of the subsequence is the length of the largest increasing subsequence. Time: $$O(n\\ log n)$$ // n for iteration, and for each iteration binary search O(log n) Space: $$O(n)$$ // auxilary array Note that the array that we actually build here does not represent a valid increasing subsequence. Nor is it the longest increasing subsequence, we just insert the elements using a particularly methodology which ensures its validity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 let MAX = Math.max; let FLOOR = Math.floor; var b_search = ( a, target ) =\u0026gt; { // return the index pf the number \u0026gt;= target let i = 0, j = a.length-1; while ( i \u0026lt;= j ) { let mid = i + FLOOR( (j-i)/2 ); if ( a[mid] == target ) return mid; else if ( a[mid] \u0026lt; target ) i = mid+1; else j = mid-1; } return i; }; var lengthOfLIS = function(a) { /** Approach 4: The idea is to keep the minium elements, such that validity of lis(longest increasing subsequence) for new incoming elements can be calculated quickly **/ let A = a.length; let sub = [ a[0] ]; for ( let i=1; i \u0026lt; A; i++ ) { let lst = sub.length-1; if ( sub[ lst ] \u0026lt; a[i] ) sub.push( a[i] ); else { // find a \u0026#34;write index\u0026#34; where we replace a[i] let wi = b_search( sub, a[i] ); sub[wi] = a[i]; } } return sub.length; } Approach 5: In place algorithm for approach 4 Time: $$O(n\\ logn)$$ Space: $$O(1)$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 let MAX = Math.max; let FLOOR = Math.floor; /* this version is for searching within the same array starting and ending position are requirede */ var b_search = ( a, start, end, target ) =\u0026gt; { // return the index pf the number \u0026gt;= target let i = start, j = end; while ( i \u0026lt;= j ) { let mid = i + FLOOR( (j-i)/2 ); if ( a[mid] == target ) return mid; else if ( a[mid] \u0026lt; target ) i = mid+1; else j = mid-1; } return i; }; var lengthOfLIS = function(a) { /*** Approach 5: Same as the above approach, but in place Hence saving auxilary space. The idea is to keep a variable to mark the end of the subsequence in a itself. **/ let A = a.length; let S = 1; // variable to mark the end of the subsequence for ( let i=1; i \u0026lt; A; i++ ) { if ( a[S-1] \u0026lt; a[i] ) { a[S] = a[i]; S++; } else { // find a \u0026#34;write index\u0026#34; where we replace a[i] let wi = b_search( a, 0, S-1, a[i] ); a[wi] = a[i]; } } return S; } ","permalink":"http://localhost:45763/personal_website/posts/all_possible_solutions_to_longest_increasing_subsequence_problem_leetcode_300/","summary":"\u003cp\u003eHere are all possible solutions I could come up with for the longest\nincreasing subsequence problem. \u003ca href=\"https://leetcode.com/problems/factorial-trailing-zeroes/description/\"\u003eleetcode\n300\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"approach-1-generate-all-possible-increasing-subsequences\"\u003eApproach 1: Generate all possible increasing subsequences\u003c/h1\u003e\n\u003cp\u003eWe will keep track of a subsequence in an array named \u003ccode\u003ecur_subsequence\u003c/code\u003e\nor \u003ccode\u003ecur_sub\u003c/code\u003e. For each element (\u003ccode\u003ea[i]\u003c/code\u003e)  we have the following 2\noptions:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eAdd the element to the end of current subsequence.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eNote: The current element can only be included if\neither the current subsequence is empty or the last\nelement of the current subsequence is smaller than\nthe current element. This is important to maintain\nthe increasing subsequence property.\u003c/em\u003e\u003c/p\u003e","title":"All possible solutions to longest increasing subsequence problem: leetcode 300"},{"content":"Problem link: leetcode 70: climbing stairs\nIntuition You need to climb n stairs, taking 1 or 2 stairs at a time.\nIf n = 2, you can climb like:\n$$1+1 = 2\\times (1) + 0 \\times(2)$$ $$2 = 0 \\times (1) + 1\\times(2) $$ if n = 3, you can climb like:\n$$1+1+1 = 3\\times(1) + 0\\times(2)$$ $$1+2 = 1\\times(1) + 1\\times(2)$$ $$2+1 = 1\\times(1) + 1\\times(2) $$ Basically you first need to decide how many steps of size 1 will you take and how many of size 2 do you need:\nHence, your first task is to solve the equation:\n$$ x \\times 1 + y \\times 2 = n $$\nTo decide the number of 1s and 2s. After you decide upon x and y then you will have calculate $$ \\frac{(x + y)!}{x! , y!} $$\nWhich is nothing but ways of chosing how exactly you will proceed. This is because we are trying to adjust x identical objects and y identical objects in x+y positions. Think of the number of ways you can arrange x men and y women in x + y positions.\nAs an example $$n=3, x=1 $$ and $$y=1$$\nThen you will have $$\\frac{(1 + 1)!}{1! , 1!} =2$$. see above, they are: $$ 1+2 \\ 2+1 $$\nApproach $$ y \\in [0, n/2] $$\nFor each , calculate the corresponding values of $$x$$ using the equation: $$ x \\times 1 + y \\times 2 = n \\ x = n - (2 \\times y ) $$\nthen calculate $$ \\frac{(x + y)!}{x! , y!} $$\nand add this to your counter variable.\nreturn counter.\nComplexity Time complexity: Time: O($$n^2$$)\nSpace: O(1)\nBut it can be reduced, if you can store calculated factorials. Hence, making the time complexity of calculating $$ \\frac{(x + y)!}{x! , y!} $$ -\u0026gt; O(1) and Space complexity O(n)\nTime complexity: O(n) Space complexity: O(n)\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 var permute = (x,y) =\u0026gt; { /* compute (x+y)! / x! y! without computing factorials */ /* which is basically computing x+y x+y-1 x+y-2 .. y+1 / x! */ var denom = 1; for (var i=1; i \u0026lt;= x; i++) denom *= i; var numi = 1; for (var i = y+1; i \u0026lt;= x+y; i++) numi *= i; return numi/denom; }; var climbStairs = function(n) { /* The number of ways in which we can get n by adding only 1 and 2 Let, 1x + 2y = n ---(1) then we need to find the number of integer solutions to this equation. that is S = {x,y | x,y in integers} we need to return |S| i.e. the number of elements in this solution set. from (1) it implies x = n - 2y ---(2) y in range [0,n/2] i.e. consequently x in range [0,n] hence, iterate over y from 0 to n/2 such that y is integer. we find the corrosponding solution using equation 2 */ let n_solutions = 0 ; for (var y=0; y \u0026lt;= Math.floor(n/2); y++ ) { var x = n - (2 * y); n_solutions += permute(x,y); } return (n_solutions); }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_70/","summary":"\u003cp\u003eProblem link: \u003ca href=\"https://leetcode.com/problems/climbing-stairs/description/\"\u003eleetcode 70: climbing stairs\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"intuition\"\u003eIntuition\u003c/h1\u003e\n\u003c!-- Describe your first thoughts on how to solve this problem. --\u003e\n\u003cp\u003eYou need to climb \u003ccode\u003en\u003c/code\u003e stairs, taking 1 or 2 stairs at a time.\u003c/p\u003e\n\u003cp\u003eIf n = 2, you can climb like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$$1+1 = 2\\times (1) + 0 \\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$2 = 0 \\times (1) + 1\\times(2) $$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eif n = 3, you can climb like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$$1+1+1 =  3\\times(1) + 0\\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$1+2   =  1\\times(1) + 1\\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$2+1   =  1\\times(1) + 1\\times(2) $$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBasically you first need to decide how many steps of size 1 will you take and how many of size 2 do you need:\u003c/p\u003e","title":"Leetcode 70: Climbing Stairs"},{"content":"Below is my C solution for the Leetcode problem candy.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 static inline void previous_kids_started_crying(int* kid, int continous_decrease_start, int continous_decrease_end, int* candy) { /* * To satisfy the condition that each child with higher rating than * it\u0026#39;s neighbors must get more candies. We give all children in range * [continous_decrease_start, continous_decrease_end] an extra candy * if the he has candies lower or equal to the kid after it. * * Note that we do not bother the kid before it, since it is known * that the kid before it has more rating than this kid */ if (continous_decrease_start == -1) { exit(1); } for (int i = continous_decrease_end; i \u0026gt;= continous_decrease_start; i--) { if (kid[i] \u0026lt;= kid[i+1]) { int before = kid[i]; kid[i]++; int after = kid[i]; *candy += after - before;; } else { /* chain is broken. We found a satisfied non protesting kid the kids before it must also be non-protesting */ return; } } } int candy(int* kid, int n) { /* * Few things to take care of: * * 1. At a time take a look at 2 children. i.e. iterate the children * in window of 2. * * 2. Each time a candy is given, check if previous child has more * rating, since he will start crying. He/she will protest that the * kid in front of him has less rating than him/her and still got * more/equal candies than him/her. It might even trigger a chain * where the kid previous to the previous kid might also see this * changed state, and if he had a rating more then the kid after him. * then he will also start asking more candies. And the kid behind * that and so on. * * The algorithm runs in linear time, however, if the children are * arranged in decreasing order of rating, then at each iteration all * previous children will start crying. Hence, everybofy needs to be * given more candies. In that case it becomes quadratic * * Space required is constant. * * Best case: * Time: O(n) * Space: O(1) * * Worst Case: * Time: O(n^2) * Space: O(1) */ int candies = 0; int continous_decrease_from = -1; /* First child gets a candy, but save his rating first */ int previous_child_rating = kid[0]; kid[0] = 1; candies++; for (int i = 1; i \u0026lt; n; i++) { if (kid[i] \u0026gt; previous_child_rating) { /* Since this child has more rating than the previous child, this child gets 1 more candy than previous child */ previous_child_rating = kid[i]; kid[i] = kid[i-1]+1; candies += kid[i]; continous_decrease_from = -1; } else if (kid[i] == previous_child_rating){ /* Since this child has equal rating than the previous child, give him 1 candy */ previous_child_rating = kid[i]; kid[i] = 1; candies++; continous_decrease_from = -1; } else { /* Previous child has more rating. Give this child one candy, and after giving : if the previous child had less candy, then we must initiate a chain reaction to do justice to all previous kids to previous children the problem here is that if this child has less rating then his predecessor then he will also start crying. And, the predecesor of this child also has more score then he will also start crying. Hence, we must give candies to them as well to maintain rule. Hence, check if the rule is disturbed, */ if (continous_decrease_from == -1) { /* A period of continous decrease started */ /* Hence, give this child 1 candy and if the previous child will also get 1 candy if he gets */ continous_decrease_from = i-1; previous_child_rating = kid[i]; kid[i] = 1; if (kid[i-1] \u0026gt; kid[i]) { candies ++; } else { kid[i-1] = kid[i] + 1; candies += 2; } } else { /* Give this child a candy, but mind the children behind this child */ previous_child_rating = kid[i]; kid[i] = 1; candies++; previous_kids_started_crying(kid, continous_decrease_from, i-1, \u0026amp;candies); } } } return candies; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_135/","summary":"\u003cp\u003eBelow is my C solution for the Leetcode problem \u003ca href=\"https://leetcode.com/problems/climbing-stairs/description/\"\u003ecandy\u003c/a\u003e.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e  1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 35\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 36\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 37\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 38\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 39\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 40\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 41\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 42\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 43\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 44\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 45\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 46\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 47\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 48\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 49\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 50\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 51\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 52\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 53\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 54\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 55\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 56\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 57\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 58\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 59\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 60\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 61\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 62\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 63\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 64\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 65\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 66\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 67\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 68\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 69\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 70\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 71\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 72\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 73\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 74\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 75\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 76\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 77\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 78\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 79\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 80\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 81\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 82\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 83\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 84\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 85\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 86\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 87\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 88\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 89\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 90\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 91\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 92\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 93\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 94\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 95\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 96\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 97\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 98\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 99\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e100\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e101\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e102\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e103\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e104\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e105\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e106\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e107\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e108\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e109\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e110\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e111\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e112\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e113\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e114\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e115\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e116\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e117\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e118\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e119\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e120\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e121\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e122\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e123\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e124\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e125\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e126\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e127\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e128\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e129\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e130\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e131\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e132\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e133\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e134\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kr\"\u003einline\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eprevious_kids_started_crying\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_end\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ecandy\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * To satisfy the condition that each child with higher rating than\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * it\u0026#39;s neighbors must get more candies. We give all children in range\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * [continous_decrease_start, continous_decrease_end] an extra candy\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * if the he has candies lower or equal to the kid after it.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Note that we do not bother the kid before it, since it is known\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * that the kid before it has more rating than this kid\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e        */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nf\"\u003eexit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_end\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ebefore\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eafter\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ecandy\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003eafter\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ebefore\u003c/span\u003e\u003cspan class=\"p\"\u003e;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* chain is broken. We found a satisfied non protesting kid\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                          the kids before it must also be non-protesting */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ecandy\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Few things to take care of:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * 1. At a time take a look at 2 children. i.e. iterate the children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * in window of 2.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * 2. Each time a candy is given, check if previous child has more\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * rating, since he will start crying. He/she will protest that the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * kid in front of him has less rating than him/her and still got\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * more/equal candies than him/her. It might even trigger a chain\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * where the kid previous to the previous kid might also see this\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * changed state, and if he had a rating more then the kid after him.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * then he will also start asking more candies. And the kid behind\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * that and so on.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * The algorithm runs in linear time, however, if the children are\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * arranged in decreasing order of rating, then at each iteration all\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * previous children will start crying. Hence, everybofy needs to be\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * given more candies. In that case it becomes quadratic\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space required is constant.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Best case:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Time: O(n)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space: O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Worst Case:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Time: O(n^2)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space: O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e         */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/* First child gets a candy, but save his rating first */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Since this child has more rating than the previous\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         child, this child gets 1 more candy than previous\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         child */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Since this child has equal rating than the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         previous child, give him 1 candy */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Previous child has more rating. Give this child one\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candy, and after giving : if the previous child had less\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candy, then we must initiate a chain reaction to do\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        justice to all previous kids to previous children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        the problem here is that if this child has less rating\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        then his predecessor then he will also start crying.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        And, the predecesor of this child also has more score\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        then he will also start crying. Hence, we must give\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candies to them as well to maintain rule. Hence, check\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        if the rule is disturbed,\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* A period of continous decrease started */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* Hence, give this child 1 candy and if the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                                   previous child will also get 1 candy if he gets  */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* Give this child a candy, but mind the children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                                  behind this child */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"nf\"\u003eprevious_kids_started_crying\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Leetcode 135: Candy"},{"content":"Introduction Linux is the kernel that powers the modern computing world. Its everywherefrom all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isnt about why Linux dominates the tech world; its about how I started contributing to the Linux Kerneland how you can too.\nHow Kernel Development Works Kernel development thrives on the Linux Kernel Mailing List (LKML), the nerve center of Linuxs open-source ecosystem. The beauty of open source? Anyone can contribute. Your task is to send patches (essentially the output of git diff refurbushed into an email).\nIf your patch solves a real problem or adds value, experienced developers will jump in with questions about your intent and rationale. Heres a pro tip: dont explain the how of your code; let the code speak for itself. Instead, focus on explaining why your change is needed.\nThe LKML community is incredibly supportive \u0026ndash; theyll critique your code, point out mistakes, and suggest improvements. Sure, it might feel overwhelming initially, but resources like the LFD103 course can guide you through the basics: generating patches, submitting them to LKML, compiling, and booting the kernel.\nFor me, just setting up my mail client and understanding LKML discussions took about a month. But once you clear these initial hurdles, things get easier. If youre struggling, feel free to check out my notesthey might save you some time.\nMy Background For years, kernel developers seemed like magicians to medoing impossibly cool things with computers. My fascination started after I stumbled upon a video of someone working on the kernel. It was mesmerizing!\nIn my second semester, I discovered the book The C Programming Language, and it sparked my love for C. The control C offers is unmatched, but it comes with its fair share of challengesbugs galore!\nSurprisingly, I wasnt a Linux user until recently. When I finally switched from Windows to Linux, everything just clicked. Concepts that once felt abstract suddenly made sense. On Windows, troubleshooting often felt like solving a mystery even Microsoft couldnt decode. On Linux, it felt like someone handed me the keys to the entire system.\nWhile working on kernel contributions, I read Linux Device Drivers, a book authored by seasoned kernel developers. It gave me a deeper understanding of the kernels inner workings. If youre serious about kernel development or writing drivers, this book is a must-read.\nWhat to Contribute The hardest part of contributing to the Linux Kernel is figuring out what to work on. The kernel is vasttheres everything from GPU drivers to network stack development.\nSince the kernels primary job is managing hardware, driver development is a hotspot of activity. New devices constantly hit the market, and they need drivers. If you have an electronics background and access to hardware, driver development is an excellent starting point.\nIf hardware isnt your thing (like in my case), here are some alternatives:\nkselftest: A testing framework for kernel functionality. Core subsystems: The backbone of the kernela great way to learn the essentials. syzbot reports: A kernel fuzzer that uncovers bugs by feeding the kernel random data. These reports are a goldmine for learning about common mistakes. Another beginner-friendly option is upgrading deprecated APIs. These updates are highly appreciated because they improve the kernels maintainability and security. Its not always a simple find-and-replaceyoull need to understand the codebut its a rewarding way to start.\nAnd dont underestimate fixing spelling and grammar errors in the documentation or comments. While it might sound trivial, its a fantastic way to learn the workflow: creating patches, submitting them, and receiving feedback. Tools like codespell can help you automate finding these errors.\nMy first-ever patch was a simple typo fix, but I made the classic rookie mistake of introducing two changes while documenting only one. Lesson learned!\nOnce you start contributing, youll notice issues everywhere. Even just following discussions on LKML can teach you a ton about how seasoned developers think and work.\nConclusion Kernel development might seem intimidating at first, but trust me, its worth the effort. Youll not only become a stronger developer but also gain a deep understanding of how computers work. Youll build expertise in both kernel and userspace development, and your Git skills will level up immenselya must-have for any programmer.\nThe learning opportunities in kernel development are unparalleled, often rivaling (or even exceeding) those at top tech companies. So if youre considering it, dont hesitatedive in! You might be surprised by how much youll grow.\nGood Luck!\nReferences ","permalink":"http://localhost:45763/personal_website/posts/highlights_from_linux_kernel_mentorship_program_2024/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux is the kernel that powers the modern computing world. Its everywherefrom all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isnt about \u003cem\u003ewhy\u003c/em\u003e Linux dominates the tech world; its about how I started contributing to the Linux Kerneland how you can too.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"how-kernel-development-works\"\u003eHow Kernel Development Works\u003c/h2\u003e\n\u003cp\u003eKernel development thrives on the Linux Kernel Mailing List (LKML), the\nnerve center of Linuxs open-source ecosystem. The beauty of open\nsource? Anyone can contribute. Your task is to send patches (essentially\nthe output of \u003ccode\u003egit diff\u003c/code\u003e refurbushed into an email).\u003c/p\u003e","title":"Highlights from Linux Kernel Mentorship Program 2024 by Abdul Rahim"},{"content":"Introduction Computer memory is usually implemented as a file system. While tampering with data is easy to detect, unauthorized access to memory is a more complex task falling within the domain of Intrusion Detection Systems (IDS). Most intrusion detection systems focus on analyzing network traffic or using machine learning techniques to identify suspicious patterns, we explore if we can employ merkel trees for this task.\nIf unauthorized memory access cannot be detected, users would never know that the system was compromised. Detecting tampered files is straightforward: you can hash the contents of a file, and if the hash changes you might conclude that the file changed. However, detecting memory access is more complicated. Although Linux keeps track of the last access timestamp, available via the stat command1, it only tracks file accesses that use the read() syscall2.\nMerkel Trees Merkle trees are a data structure in which hashes are stored rather than data. Leaf nodes store hashes of particular data blocks, while other nodes store hashes of their children. Merkle trees are widely used in blockchains for their ability to detect data tampering. They provide a robust mechanism to detect tampering in multiple distinct data items. If any data item in a leaf node changes, the whole tree becomes invalidated because it changes the hashes of all nodes up the tree.\nFig. 1: A Merkle tree is a data structure in which each node contains a hash. All non-leaf nodes contain hashes of their children, and all leaf nodes contain hashes of the underlying data.\nMerkel tree as directory tree Now, what we want to do is to augment the directory tree as a merkel tree. To be exact the inode structure (See inode doc for more details).\nDoing this would make us have hashes for children in directory tree. And the benefit of that is whenever the child inodes change, the current inode would change. And there\u0026rsquo;s 2 fields that each node would contain, the last seen hash (expected hash) of it\u0026rsquo;s child and the current hash of the same child. And when the current hash changes to a different value from expected hash, then we can imply that the child inode changed.\nBut one question is that if memory can be accessed bare metal, then the protections done in software doesn\u0026rsquo;t really make any sense. One possible solution to this problem is employing encryption.\nThe encryption should be performed in hardware, and the memory access system calls should define protocols for decrypting the underlying memory. The same system call would update necessary variables of the file in question, such as access time. The memory access system call needs to be implemented so that when one accesses memory, the data is decrypted and other functions are performed.\nBelow is a detailed description.\nArchitecture File system in most operating systems follow a hierarchical structure. We augment this with a Merkle tree, where a node is attached to each file in the file system. These nodes form a Merkle tree, where each node contains the hash of its children (in the case of non-leaf nodes) or the hash of the file data (in the case of files). Additionally, a pollution flag is attached to each node to detect illegal access.\nEach node will also has an expected hash, which is the hash of the node when the subtree below that node was last valid.\nWorking The pollution flag is set if expected_hash != hash, which occurs only on illegal access. I will explain this in a moment.\nWhen a user or process requests memory, it will go through the memory access system call, requiring authentication. Once the authentication is successful, the underlying data is decrypted and returned, the access time is updated, and all the hashes up to the root are updated along with the expected hash (note that the expected hash changes on authorized access). The tree remains valid.\nIf the authentication fails, the memory is not returned, but the access time changes. Consequently, when the tree is re-evaluated, the hash of this node changes since it incorporates the access time, but the expected hash remains the same, setting the pollution flag for this node.\nSince the parent of this node uses its hash, the parent\u0026rsquo;s hash also changes. However, its expected hash remains the same, leading to its invalidation. This process continues up the tree, invalidating the whole tree.\nThe benefit of this approach is that all other nodes remain valid. If one tries to determine which file was accessed and the timestamp, it is easy to identify the exact file by following the invalid nodes from top to bottom.\nRefrences stat man page\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nread syscall\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:45763/personal_website/posts/merkel_trees_and_computer_memory/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003c!-- mine\nComputer memory is usually implemented as a file system. While tampering\nof data is easy to detect, unauthorised access to memory is a more\ncomplex task. A problem that lies in the domain of Intrusion Detection\nSystems. While, most intrusion detection focus on analyzing network\ntraffic, or machine learning techniques to identify suspicious patterns.\nWe propose a method that works within the system, providing robust\naccess detection.\n--\u003e\n\u003cp\u003eComputer memory is usually implemented as a file system. While tampering\nwith data is easy to detect, unauthorized access to memory is a more\ncomplex task falling within the domain of Intrusion Detection Systems\n(IDS). Most intrusion detection systems focus on analyzing network traffic or\nusing machine learning techniques to identify suspicious patterns, we\nexplore if we can employ merkel trees for this task.\u003c/p\u003e","title":"Merkel Trees and computer memory"},{"content":"Introduction When you install vim, a usual requirement as with all text editors is the ability to copy to/from system clipboard so you can lets say, copy something into your vim session from firefox or vice versa, however copy pasting in terminal editors is not as straight forward as with GUI editors. In vim if you want to copy something into an auxilary space (anticipating it would be used later, so you can paste from this auxilary space) is achieved by registers.\nThe register that represents system clipboard is + register. Anything that you copy into this register is available in system clipboard.\nHow to use registers to copy/paste To copy a text into a register, select it in visual mode and press \u0026quot;\u0026lt;register_name\u0026gt;y to yank the contents into the given register. And to paste the contents of a particular register at current position, use \u0026quot;\u0026lt;register_name\u0026gt;p.\nTo use system clipboard, you just have to substitute \u0026ldquo;+\u0026rdquo; for register name in the above commands.\nclipboard support But the + register wont work unless you have clipboard support with your vim installation. By default there is no clipboard support in vim.\nTo check if your vim installation has clipboard support use:\n1 2 3 $ vim --version | grep clipboard +clipboard +keymap +printer +vertsplit +ex_extra +mouse_netterm +syntax +xterm_clipboard or inside of vim, you can run the command:\n1 :echo has(\u0026#39;clipboard\u0026#39;) If the output is 0, your installation doesnt have clipboard support.\nCompiling vim Now there are 2 solutions to this problem:\nEither install gvim: Or compile vim from sources with clipboard support Let\u0026rsquo;s see how each of them can be done.\nInstall gvim To install gvim run:\nOn Debian:\n1 sudo apt install vim-gtk On Fedora\n1 sudo dnf install gvim To compile vim with clipboard support Below are the simple steps:\nStep 1: Grab the sources Clone the repository:\n1 2 git clone https://github.com/vim/vim.git vim cd vim Step 2: Install dependencies Install the required libraries and tools to build vim, for example gcc, x11 etc. Note that you only need them to compile vim and you are free to delete them once you are done.\nOn Debian:\n1 sudo apt install build-essential libx11-dev libncurses5-dev On Fedora:\n1 2 3 4 sudo dnf groupinstall \u0026#34;Development Tools\u0026#34; sudo yum install gcc sudo yum groupinstall \u0026#34;X Software Development\u0026#34; sudo dnf install libX11-devel ncurses-devel Also, you need to remove the existing installation(if any).\nOn Debian\n1 sudo apt remove vim On Fedora\n1 sudo dnf remove vim gvim Step 3: Configure and Compile Configure vim with features of your choice\n1 2 3 4 5 6 7 ./configure \\\\ --enable-cscope \\\\ --enable-gui=auto \\\\ --enable-gtk2-check \\\\ --enable-gnome-check \\\\ --with-features=huge \\\\ --with-x Then compile and install with:\n1 2 make sudo make install Conclusion In this article we learned how can we compile vim with clipboard support, you can also tweak configuration according to your requirements. There are many configuration options available.\n","permalink":"http://localhost:45763/personal_website/posts/how_to_compile_vim_with_clipboard_support/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eWhen you install vim, a usual requirement as with all text editors is\nthe ability to copy to/from system clipboard so you can lets say, copy\nsomething into your vim session from firefox or vice versa, however copy\npasting in terminal editors is not as straight forward as with GUI\neditors. In vim if you want to copy something into an auxilary space\n(anticipating it would be used later, so you can paste from this\nauxilary space) is achieved by \u003cstrong\u003eregisters\u003c/strong\u003e.\u003c/p\u003e","title":"How to compile vim with clipboard support"},{"content":" Introduction I had an unused phone lying around for some time, and I began contemplating how I could repurpose it. This led me to reflect on the impressive performance of modern smartphones and consider whether they could be utilized as servers.\nSmartphones are equipped with ARM-based processors and run on Android, which is itself built on the Linux kernel. ARM processors are renowned for their energy efficiency1 and have recently found applications in the server space2.\nAs someone who enjoys exploring the full potential of devices, I embarked on a journey to discover how I could leverage the full potential of smartphones.\nSetup Although, you would like to run your programs on phones, but programming on phones typing on screen is a horrifying idea. Fortunately, you dont have to type on your phone, what you can do is you can access its terminal, using protocols like ssh/telnet etc.\nSo, firstly you would need a terminal to control a machine remotely. Unfortunately, there are not, alot of choices available in phone space when it comes to terminal emulators. Termux is one of the few available options.\nAfter you manage to open a terminal remotely, then from there its pretty frictionless. You can install the software of your choice and write, compile and run your programs. You might also find it helpful to root your phone for root privilages, which will help you run all commands. But please beware that rooting can null your warrenty, check with local expert. If termux does\u0026rsquo;nt work for you then there are also other options like kali net hunter.\nSo, in total, we need to install termux, then we would setup ssh.\nTermux Termux is an open source terminal emulator for android. In essence, it provides you with a linux environment, within android, The only difference between actual linux environment and termex is that it is not FHS(File System Hierarcy) compliant, i.e. it does not strictly follow linux file system conventions. The consequences of that are that #! /usr/bin/sh may not work, so you have to watch out the paths. Other than that, it supports almost all commands on linux.\nMoreover, It is an app that does\u0026rsquo;nt interfere with your system so you can run your android as normal, moreover it runs without root privilages. It comes with a large repository of software found at packages.termux.dev.\nBelow are the steps to setup ssh in termux Step 1: Download texmux on playstore, f-droid or from github releases\nStep 2: Update using pkg:\n1 2 pkg update # update the repositories pkg upgrade # upgrade all to latest versions Run this commands\nStep 3: Install ssh 1 pkg install ssh install ssh\nStep 4: Set a password Setup a password that you will use to login\n1 passwd set password and note username\nStep 5: Note your username You will require username and ip address when logging in using ssh, hence note them. Run the command whoami the know your username. This will generally start with \u0026ldquo;a0_\u0026rdquo;\n1 whoami Step 6: Note your IP address You can check your IP address in:\n1 2 3 settings \u0026gt; Wi-Fi \u0026gt; click on the (i) button, on the wifi you are connected to and Look for IPv4 address Step 7: Run ssh doemon in termux On your phone, run the ssh daemon using\n1 sshd Step 8: Login form your computer On your computer, use the following command to login into your phone and access its terminal\n1 ssh \u0026lt;user_name\u0026gt;@\u0026lt;IP_address\u0026gt; -p 8022 The username and IP address we already determined in step 5 and 6 resp. Note that it will promt you for password\nAftermath You can use scp command to transfer files between your computer and phone. In case you want to do development, there are a number of programming packages available in termux, you can find rust, nodejs, python, C/C++ and tools for many other programming languages.\nConclusion So, now you have successfully installed ssh in your android phone. You might find it useful to install vim, git, gcc etc. There is a large repository of packages in termux, which covers pretty much everything your would need.\nFurther Reads Simili, Emanuele, et al. \u0026ldquo;Power Efficiency in HEP (x86 vs. arm).\u0026rdquo; Power (W) 350.400 (2023): 450\u0026#160;\u0026#x21a9;\u0026#xfe0e;\narm_server\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:45763/personal_website/posts/how_to_turn_your_old_smartphone_into_a_home_server/","summary":"\u003c!--\n---\ndate: '2025-07-15T22:33:11+05:30'\ndate: ''\ntitle: 'How_to_turn_your_old_smartphone_into_a_home_server'\n---\n--\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eI had an unused phone lying around for some time, and I began\ncontemplating how I could repurpose it. This led me to reflect on the\nimpressive performance of modern smartphones and consider whether they\ncould be utilized as servers.\u003c/p\u003e\n\u003cp\u003eSmartphones are equipped with ARM-based processors and run on Android,\nwhich is itself built on the Linux kernel. ARM processors are renowned\nfor their energy efficiency\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e and have recently found\napplications in the server space\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e","title":"How to turn your old smartphone into a home server"},{"content":"When nums[i] \u0026gt; nums[j], it is global inversion. Local inversion is special case of global inversion with j=i+1\nConsider the array: [0,1,2,3,4,5]\nIf i swap a random element by 2 positions (either to left or right). I will always create 2 inversions.\nLikewise, if I swap a random element by 3 positions. I end up creating 3 inversions.\nSimilarly if I swap an element by 4 positions. I end up creating 4 inversions.\nNote that for each swap made above, we created a single local inversion. This means that whever we swap 2 elements, we end up creating 1 local inversion and k global inversions. Where k means element swapped k number of positions away.\nNow, we need number of local inversions = number of global inversions. This can only happen when local inversion is itself the global inversion.\nHence, for each swap we should only create 1 inversion, THEREFORE K=1\n1 2 3 4 5 6 7 8 bool isIdealPermutation(int* nums, int numsSize) { for (int i=0; i \u0026lt; numsSize; i++) { if ( abs(nums[i]-i) \u0026gt; 1 ) return false; } return true; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_775_global_and_local_inversions_solution/","summary":"\u003cp\u003eWhen \u003ccode\u003enums[i] \u0026gt; nums[j]\u003c/code\u003e, it is global inversion. Local inversion is special case of global inversion with \u003ccode\u003ej=i+1\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eConsider the array: \u003ccode\u003e[0,1,2,3,4,5]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/2f3eb772-cc4d-4006-adec-d2937264734b_1752435521.47083.png\"\u003e\u003c/p\u003e\n\u003cp\u003eIf i swap a random element by 2 positions (either to left or right). I will always create 2 inversions.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/36424827-47b3-4fab-b464-6a02cbd9a953_1752435463.2740006.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/c9cefbb6-24e0-419e-8e4e-69178894068a_1752435700.7604558.png\"\u003e\u003c/p\u003e\n\u003cp\u003eLikewise, if I swap a random element by 3 positions. I end up creating 3 inversions.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/a5633f7f-c730-4671-8262-daed0eba9b80_1752435799.3669355.png\"\u003e\u003c/p\u003e\n\u003cp\u003eSimilarly if I swap an element by 4 positions. I end up creating 4 inversions.\u003c/p\u003e","title":"Leetcode 775: Global and local inversions solution"},{"content":"We need to divide the array nums into k subsets such that the sum of each subset is same.\n$$ k \\times sum\\ of\\ each\\ subset = total\\ sum\\ sum\\ of\\ each\\ subset = total\\ sum\\ \\div k\\ target = total\\ sum\\ \\div k $$\nNow our task is to find all the k subsets in nums whose sum is target.\nMy idea is to structure this as multi-level recursion. We first try to find the $$k^{th}$$ subset, then $$(k-1)^{th}$$, then $$(k-2)^{th} \u0026hellip;$$ until there is only one subset left. The last subset will naturally sum to target. You can only go to $$(k-1)^{th}$$ level when you are able to successfully find $$k^{th}$$ level subset,\nFor example,\n1 2 3 4 5 6 7 .. .. find the 5th subset find the 4th subset find the 3rd subset find the 2nd subset return true Seeing the recursive structure.\n1 2 3 4 5 6 7 8 9 nums = [4,3,2,3,5,2,1] k=4 target = 20 / 4 = 5 suppose you find the 4th subset as: {3,2} from [4,3,2,3,5,2,1] Now your task reduces to finding 3 subsets in [4, ,3,4,2,1] that sum to target=5 recursive call: nums=[4, ,3,4,2,1] k=3 When finding the kth subset. You can simply use pick/not pick backtracking approach. It is important to understant the distinction between same level recursion (at any given k) which operates by deciding weather to pick/drop nums@i.\nAnd the k levels recursion which succeeds/fails by checking if we can form the $$k^{th}$$ subset.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution: def __init__(self): self.nums, self.target, self.used = None, None, None def canPartitionKSubsets(self, nums: List[int], k: int) -\u0026gt; bool: self.nums = nums total = sum(self.nums) self.target = total // k self.used = [False] * len(nums) if total % k != 0: return False self.nums.sort(reverse=True) return self.bt_search(0, k, 0) def bt_search(self, i: int, k: int, cur_sum: int) -\u0026gt; bool: if k == 1: # last subset is sure to sum upto target return True if i \u0026gt;= len(self.nums) or cur_sum \u0026gt; self.target: return False if cur_sum == self.target: # current subset found, return self.bt_search(0, k-1, 0) # explore the next level of k # try picking nums@i in current subset if not self.used[i] and cur_sum + self.nums[i] \u0026lt;= self.target: self.used[i] = True # explore in same level if self.bt_search(i+1, k, cur_sum + self.nums[i]): return True self.used[i] = False # on failure, skip duplicates of nums@i while i+1 \u0026lt; len(self.nums) and self.nums[i] == self.nums[i+1]: i += 1 # do not pick nums@i -\u0026gt; explore in same level return self.bt_search(i+1, k, cur_sum) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_698_partition_to_k_equal_sum_subsets/","summary":"\u003cp\u003eWe need to divide the array \u003ccode\u003enums\u003c/code\u003e into \u003ccode\u003ek\u003c/code\u003e subsets such that the sum of each subset is same.\u003c/p\u003e\n\u003cp\u003e$$\nk \\times sum\\ of\\ each\\ subset = total\\ sum\\\nsum\\ of\\ each\\ subset = total\\ sum\\ \\div k\\\ntarget = total\\ sum\\ \\div k\n$$\u003c/p\u003e\n\u003cp\u003eNow our task is to \u003cstrong\u003efind all the \u003ccode\u003ek\u003c/code\u003e subsets in nums whose sum is \u003ccode\u003etarget\u003c/code\u003e\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eMy idea is to structure this as multi-level recursion. We first try to find the $$k^{th}$$ subset, then $$(k-1)^{th}$$, then $$(k-2)^{th} \u0026hellip;$$ until there is only one subset left. The last subset will naturally sum to \u003ccode\u003etarget\u003c/code\u003e. You can only go to $$(k-1)^{th}$$ level when you are able to successfully find $$k^{th}$$ level subset,\u003c/p\u003e","title":"Leetcode 698: Partition into k equal sum subsets: The art of recursion: mastering double recursion in a single function"},{"content":"For each possible word, we ask the question: What possible queries can lead to this word?.\nFor example consider the word: abd. Below are the possible (prefix, suffix) queries that can return abd\n1 2 3 4 5 6 7 8 9 10 (prefix, suffix) a abd a bd a d ab abd ab bd ab d abd abd abd bd abd d Now, given word.length \u0026lt;= 7. Each word can at maximum generate 7*7=49 such pairs. Can we store all of them in a hashmap? Yes, because the total storage = 49 * number of words = O(n) Which is acceptable for this problem.\nWhat if there is already a value for (prefix,suffix) in current word. Shall we override it. We need the latest index right?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class WordFilter: def __init__(self, words: List[str]): self.map = {} for widx, w in enumerate(words): for i in range( len(w) ): prefix = w[:i+1] for j in range( len(w) ): suffix = w[j:] # for all possible prefix suffix queries that might route # to current word. We set it in dictionary overriding previously # inserted values to get the maximum index key = prefix + \u0026#39;|\u0026#39; + suffix self.map[key] = widx def f(self, pref: str, suff: str) -\u0026gt; int: key = pref + \u0026#39;|\u0026#39; + suff return self.map.get(key, -1) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_745_prefix_and_suffix_search_solution/","summary":"\u003cp\u003eFor each possible word, we ask the question: \u003cstrong\u003eWhat possible queries can lead to this word?\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor example consider the word: \u003ccode\u003eabd\u003c/code\u003e. Below are the possible (prefix, suffix) queries that can return \u003ccode\u003eabd\u003c/code\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(prefix, suffix)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ea    d\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eab  d\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  abd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  bd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eabd  d\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eNow, given word.length \u0026lt;= 7. Each word can at maximum generate \u003ccode\u003e7*7=49\u003c/code\u003e such pairs. Can we store all of them in a hashmap? Yes, because the total storage = \u003ccode\u003e49 * number of words = O(n)\u003c/code\u003e Which is acceptable for this problem.\u003c/p\u003e","title":"Leetcode 745: prefix and suffix search solution"},{"content":"This problem is very similar to lc543, which is about finding the longest edge path in a tree. You can just copy over that code, and add 2 lines in it.\nHere we are doing the same thing as in lc543, however, when we encounter a non-matching child. We treat it as null.\nFor example, here the longest path at root node is highlighted below in red with 6 edges.\nOur algorithm views the tree like this. The longest path of 3 edges is highlighted in red.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int edges( struct TreeNode* node ); int longest_path; int longestUnivaluePath(struct TreeNode* root) { longest_path = 0; edges(root); return longest_path; } int edges( struct TreeNode* node ) { if ( !node ) return -1; int left = edges(node-\u0026gt;left), right = edges(node-\u0026gt;right); // treat child as null if it doesn\u0026#39;t match parent left = (node-\u0026gt;left \u0026amp;\u0026amp; node-\u0026gt;val == node-\u0026gt;left-\u0026gt;val) ? left : -1; right = (node-\u0026gt;right \u0026amp;\u0026amp; node-\u0026gt;val == node-\u0026gt;right-\u0026gt;val) ? right : -1; longest_path = fmax(longest_path, 1+left + 1+right); return 1 + fmax( left, right); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution: def __init__(self): self.ans = 0 def longestUnivaluePath(self, root: Optional[TreeNode]) -\u0026gt; int: self.edges( root ) return self.ans def edges(self, node: Optional[TreeNode]) -\u0026gt; int: if not node: return -1 left, right = self.edges( node.left ), self.edges( node.right ) # if the child is illegitimate. Discard it if not node.left or node.left.val != node.val: left = -1 # treat as null if not node.right or node.right.val != node.val: right = -1 self.ans = max( self.ans, ( 1+left ) + ( 1 + right ) ) return 1 + max( left, right ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function longestUnivaluePath(root: TreeNode | null): number { let ans = 0; const edges = ( node: TreeNode|null ): number =\u0026gt; { if ( !node ) return -1; let left = edges( node.left ), right = edges( node.right ); // if child value doesn\u0026#39;t match -\u0026gt; treat as null left = (node.left \u0026amp;\u0026amp; node.val == node.left.val) ? left : -1; right = (node.right \u0026amp;\u0026amp; node.val == node.right.val) ? right : -1; ans = Math.max( ans, (1 + left) + (1 + right) ); return 1 + Math.max( left, right ); } edges( root ); return ans; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function longestUnivaluePath(root) { let ans = 0; const edges = ( node ) =\u0026gt; { if ( !node ) return -1; let left = edges( node.left ), right = edges( node.right ); // if child value doesn\u0026#39;t match -\u0026gt; treat as null left = (node.left \u0026amp;\u0026amp; node.val == node.left.val) ? left : -1; right = (node.right \u0026amp;\u0026amp; node.val == node.right.val) ? right : -1; ans = Math.max( ans, (1 + left) + (1 + right) ); return 1 + Math.max( left, right ); } edges( root ); return ans; }; ","permalink":"http://localhost:45763/personal_website/posts/solution_to_leetcode_687_longest_univalue_path/","summary":"\u003cp\u003eThis problem is very similar to\n\u003ca href=\"https://leetcode.com/problems/diameter-of-binary-tree/solutions/6824338/solution-for-dummies-by-abdulrahim2002-yzrs/\"\u003elc543\u003c/a\u003e,\nwhich is about finding the longest edge path in a tree. You can just\ncopy over that code, and add 2 lines in it.\u003c/p\u003e\n\u003cp\u003eHere we are doing the same thing as in lc543, however, when we encounter a non-matching child. We treat it as null.\u003c/p\u003e\n\u003cp\u003eFor example, here the longest path at root node is highlighted below in red with 6 edges.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/148ffbfd-0ead-48cd-b45d-8c2575bafd11_1751999234.494938.png\"\u003e\u003c/p\u003e","title":"Solution to Leetcode 687: Longest Univalue Path"},{"content":"I keep track of the top k elements in sorted list. The kth largest element is the smallest of the top k elements.\ne.g. top k(=6) elements: [3,5,7,10,42,56] in sorted order. The kth largest element = 6th largest element = smallest element in above list.\nWhen I insert an element, I simply check if it can make it\u0026rsquo;s place among k largest elements already present in the list. Which it can, if it can defeat the smallest element in our list.\nFor example, we cannot add 2 in the array above since it fails to defeat 3.\nHowever, A number like 15 can be inserted. In which case, we remove the smallest element i.e. 3, to keep the list length=k\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class KthLargest: def __init__(self, k: int, nums: List[int]): self.scores = SortedList() self.limit = k for num in nums: self.add(num) def add(self, val: int) -\u0026gt; int: # if the current element can make space in top k elements if len(self.scores) \u0026lt; self.limit or self.scores[0] \u0026lt; val: self.scores.add(val) # remove smallest if len(self.scores) \u0026gt; self.limit: self.scores.pop(0) # return smallest return self.scores[0] ","permalink":"http://localhost:45763/personal_website/posts/leetcode_703_kth_largest_element_in_a_stream/","summary":"\u003cp\u003eI keep track of the top k elements in sorted list.\nThe kth largest element is the \u003cstrong\u003esmallest of the top k elements\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003ee.g. top k(=6) elements: \u003ccode\u003e[3,5,7,10,42,56]\u003c/code\u003e in sorted order.\nThe kth largest element = 6th largest element = smallest element in above list.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/070564ea-afa3-4108-92e6-7fa76c2fb981_1752504996.0140414.png\"\u003e\u003c/p\u003e\n\u003cp\u003eWhen I insert an element, I simply check if it can make it\u0026rsquo;s place among k largest elements already present in the list. Which it can, if it can defeat the smallest element in our list.\u003c/p\u003e","title":"Leetcode 703: kth largest element in a stream solution in python"},{"content":"When numbers from $$\\in$$ [0,n-1] are sorted in an array of size n. Their sorted position is equal to their index.\nSubset of numbers in array[i:j] can form a partition, if all elements in [i,j) are available in array[i:j].\nFor example [2,0,1] can form a partition, since they are at index 0, 1, 2 respectively. Sorted will involving swapping them at their correct position.\nThe basic idea behind this solution is that we try to identify such partitions, where all elements required to be sorted in [i, j] are available in current partition.\nHere\u0026rsquo;s the visualization of the algorithm, i points to the start of the group and j iterates through the group and checks if the current group needs to be expanded. e points to the end of the current group.\nSince, array[j]=1, we found a number greater than current boundaries. We need to expand the boundary. Hence, new group end is e = array[j].\nIncrement j. We find that array[1] = 0 which is \u0026lt; current end. Increment j again, j=2, Hence, no we exhaust the current group and we move forward to finding the next partition. Increase, current group ending, and reinitialize i=e/\nIn the second group, we have array[j]=2 and we are at index 2. Hence, we do not need to expand this group, since 2 is at right position.\nSimilarly we find the next 2 partitions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int maxChunksToSorted(int* arr, int arrSize) { int cur_gp_end = 0, cnt_gps = 0, i = 0; while ( i \u0026lt; arrSize ) { int j = i; // try to terminate the current group while ( j \u0026lt;= cur_gp_end ) { cur_gp_end = fmax( cur_gp_end, arr[j] ); j++; } i = ++cur_gp_end; cnt_gps++; } return cnt_gps; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_769_max_chunks_to_make_sorted/","summary":"\u003cp\u003eWhen numbers from $$\\in$$ \u003ccode\u003e[0,n-1]\u003c/code\u003e are sorted in an array of size n. Their sorted position is equal to their index.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/07a3b1d2-9478-486f-9f62-3a67e6dde1b3_1752513551.205261.png\"\u003e\u003c/p\u003e\n\u003cp\u003eSubset of numbers in \u003ccode\u003earray[i:j]\u003c/code\u003e can form a partition, if all elements in \u003ccode\u003e[i,j)\u003c/code\u003e are available in \u003ccode\u003earray[i:j]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFor example \u003ccode\u003e[2,0,1]\u003c/code\u003e can form a partition, since they are at index \u003ccode\u003e0, 1, 2\u003c/code\u003e respectively. Sorted will involving swapping them at their correct position.\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://assets.leetcode.com/users/images/77d9235f-d72a-416a-bd77-d8802d7567b0_1752513786.651974.png\"\u003e\u003c/p\u003e\n\u003cp\u003eThe basic idea behind this solution is that we try to identify such partitions, where all elements required to be sorted in \u003ccode\u003e[i, j]\u003c/code\u003e are available in current partition.\u003c/p\u003e","title":"Leetcode 769: Max chunks to make sorted solution"},{"content":"For each word, we basically store all versions of it after removal of 1 character. For example,\n1 2 3 4 5 6 hello -\u0026gt; ello -\u0026gt; removed h@0 hllo -\u0026gt; removed e@1 helo -\u0026gt; removed l@2 helo -\u0026gt; removed l@3 hell -\u0026gt; removed o@4 We can store: wordAfterRemoval,indexOfRemoval in hashmap. So whenever we search for a word like: hexlo then we can try removing it\u0026rsquo;s 2nd index and search: helo,2 in the map, which we will find.\nIn the value we can store the removed character. For example, store key=helo,2 with value=l to indicate that l was removed.\nSo when you match a word like hexlo. Try to search helo,2 in the hashmap. It gives value=l which is !='x' i.e. the removed character in hexlo.\nHowever, there is one problem with this approach. When you add 2 words like: hello and hallo in the map. Then hllo,1 will give e in the first insertion and a in the second. The second overides the first so hello is forgetten by the structure. To avoid this issue, we store both of them (e, a) in a list.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class MagicDictionary { private map = new Map\u0026lt;string,string[]\u0026gt;(); buildDict(dictionary: string[]): void { for ( const word of dictionary ) { for ( let i=0; i \u0026lt; word.length; i++ ) { const wordAfterRemoval = word.slice(0, i) + word.slice(i+1); // key stores wordAfterRemoval,indexOfRemoval as value const key = `${wordAfterRemoval},${i}`; if ( !this.map.has(key) ) this.map.set(key,[]); // values have the removed character this.map.get(key).push( word[i] ) } } } search(word: string): boolean { for ( let i=0; i \u0026lt; word.length; i++ ) { const wordAfterRemoval = word.slice(0, i) + word.slice(i+1); const key = `${wordAfterRemoval},${i}`; if ( !this.map.has(key) ) continue; const removedChars = this.map.get(key); // If there was a word with removed character != word[i] for ( let j=0; j \u0026lt; removedChars.length; j++ ) { if ( removedChars[j] !== word[i] ) return true; } } return false; } } You can also embed the index information by replacing the removed word with _ like in this pyton version:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class MagicDictionary: def __init__(self): self.map = {} def buildDict(self, dictionary: List[str]) -\u0026gt; None: for word in dictionary: for i in range(len(word)): key = word[0:i] + \u0026#39;_\u0026#39; + word[i+1:] if not key in self.map: self.map[key] = [] self.map[key].append(word[i]) def search(self, searchWord: str) -\u0026gt; bool: for i in range(len(searchWord)): key = searchWord[0:i] + \u0026#39;_\u0026#39; + searchWord[i+1:] if key not in self.map: continue for c in self.map[key]: if c != searchWord[i]: return True return False # Your MagicDictionary object will be instantiated and called as such: # obj = MagicDictionary() # obj.buildDict(dictionary) # param_2 = obj.search(searchWord) ","permalink":"http://localhost:45763/personal_website/posts/leetcode_676_magic_dictionary/","summary":"\u003cp\u003eFor each word, we basically store all versions of it after removal of 1 character. For example,\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehello -\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eello -\u0026gt; removed h@0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehllo -\u0026gt; removed e@1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehelo -\u0026gt; removed l@2\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehelo -\u0026gt; removed l@3\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ehell -\u0026gt; removed o@4\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003eWe can store: \u003ccode\u003ewordAfterRemoval,indexOfRemoval\u003c/code\u003e in hashmap. So whenever we search for a word like: \u003ccode\u003ehexlo\u003c/code\u003e then we can try removing it\u0026rsquo;s 2nd index and search: \u003ccode\u003ehelo,2\u003c/code\u003e in the map, which we will find.\u003c/p\u003e","title":"Leetcode 676: magic dictionary"},{"content":"consider the word \u0026ldquo;catsdogcats\u0026rdquo;. We have the dictionary: [\u0026quot;cat\u0026quot;,\u0026quot;cats\u0026quot;,\u0026quot;catsdogcats\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;dogcatsdog\u0026quot;,\u0026quot;hippopotamuses\u0026quot;,\u0026quot;rat\u0026quot;,\u0026quot;ratcatdogcat\u0026quot;]\nWe iterate over the word: catsdogcats and at each iteration, we ask if the prefix is contained in dictionary.\nIf the prefix is in the dictionary, we recursively call the function on the remaining word (excluding matched prefix)\nis c in dictionary ? is ca in dictionary ? is cat in dictionary ? -\u0026gt; YES call( sdogcats ) \u0026ndash;[1] Prefix cat matched so recursively call with sdogcats\nis s in dictionary ? is sd in dictionary ? \u0026hellip;. is sdogcats in dictionary ? NO We exhausted the word so we return false. Nothing was matched\nBack at the first call, this time we try to match cats Return to [1]\nis cats in dictionary -\u0026gt; YES recursively call on dogcats\nis d in dictionary ?\nis do in dictionary ?\nis dog in dictionary ? -\u0026gt; YES, recursively call on cats\nis c in dictionary ?\nis ca in dictionary ?\nis cat in dictionary ? YES , recursively call(s) \u0026ndash;[2]\nis s in dictionary ? NO -\u0026gt; word exhausted, return false;\nBack at recursive call [2]\nis cats in dictionary ? YES recursively call(``) i.e. empty string When we reach empty string, it means whole of string can be constructed using words in dictionary. Hence return true.\nImport considerations:\nThe dictionary has all the words, which means that catsdogcats will match with itself completely. To avoid words matching with themselves, we tell the function to ignore the catsdogcats word to avoid matching it with itself. Also, we can memoize the results since, dictionary remains the same, only target word and ignore word changes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function findAllConcatenatedWordsInADict(words: string[]): string[] { const dict = new Set\u0026lt;string\u0026gt;( words ); return words.filter( curWord =\u0026gt; canChunk( curWord, curWord, dict ) ); }; function canChunk( target: string, ignore: string, dict: Set\u0026lt;string\u0026gt;, memo = new Map\u0026lt;string, boolean\u0026gt;() ): boolean { if ( !target.length ) return true; const key = target + ignore; if ( memo.has( key ) ) return memo.get( key ); for ( let i=1; i \u0026lt;= target.length; i++ ) { const prefix = target.slice( 0, i ); if ( prefix !== ignore \u0026amp;\u0026amp; dict.has( prefix ) \u0026amp;\u0026amp; canChunk( target.slice( i ), ignore, dict, memo ) ) { memo.set( key, true ); return true; } } memo.set( key, false ); return false; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_472_concatenated_words/","summary":"\u003cp\u003econsider the word \u0026ldquo;catsdogcats\u0026rdquo;. We have the dictionary: \u003ccode\u003e[\u0026quot;cat\u0026quot;,\u0026quot;cats\u0026quot;,\u0026quot;catsdogcats\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;dogcatsdog\u0026quot;,\u0026quot;hippopotamuses\u0026quot;,\u0026quot;rat\u0026quot;,\u0026quot;ratcatdogcat\u0026quot;]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWe iterate over the word: \u003ccode\u003ecatsdogcats\u003c/code\u003e and at each iteration, we ask if the prefix is contained in dictionary.\u003c/p\u003e\n\u003cp\u003eIf the prefix is in the dictionary, we recursively call the function on the remaining word (excluding matched prefix)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eis \u003ccode\u003ec\u003c/code\u003e in dictionary ?\u003c/li\u003e\n\u003cli\u003eis \u003ccode\u003eca\u003c/code\u003e in dictionary ?\u003c/li\u003e\n\u003cli\u003eis \u003ccode\u003ecat\u003c/code\u003e in dictionary ? -\u0026gt; YES       call( \u003ccode\u003esdogcats\u003c/code\u003e ) \u0026ndash;[1]\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePrefix \u003ccode\u003ecat\u003c/code\u003e matched so recursively call with \u003ccode\u003esdogcats\u003c/code\u003e\u003c/p\u003e","title":"Leetcode 472: Concatenated words"},{"content":"The task is to find a subarray with sum of elements = k\nTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\nThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\n$$ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k] $$\nNow we are looking for sub of subarray = T(target). Therefore:\n$$ sum\\ of\\ subarray = prefix\\ [j]\\ -\\ prefix\\ [i-1] = T\\ \\ prefix\\ [i-1] = prefix\\ [j]\\ - T $$\nTherefore, we iterate the prefix array. And at each prefix[j], we search for a previously inserted prefix[i-1] such that prefix[i-1] = prefix[j] - T. We also need the count of such subarrays. At a particular j the number of subarrays where sum=T is the number of i that occured previously such that prefix[i-1] = prefix[j] - T. Index j will form a subarray with each of such previous i\u0026rsquo;s.\nWe must store the mapping: ( prefix[x], count ) in a map.\nSo far so good. But what happens when $$i=0$$. In this case, sum of subarray between indices [0, j] is defined as:\n$$ prefix\\ [j] = \\sum_{k=0}^j nums\\ [k] = T $$\nAt each index j, the code will try to look for prefix[j] - T in the map. When prefix[j]=T itself, then it would look for T-T=0 into the map. Therefore we must keep prefix= 0, count= 1 into the map to account for subarrays starting at index 0.\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 function subarraySum(nums: number[], k: number): number { const map = new Map\u0026lt;number, number\u0026gt;([ [0, 1] ]); let sumk = 0; for ( let j=0; j \u0026lt; nums.length; j++ ) { nums[j] = ( j==0 ) ? nums[j] : nums[j-1] + nums[j]; sumk += map.get( nums[j] - k ) ?? 0; map.set( nums[j], ( map.get(nums[j]) ?? 0 ) + 1 ); } return sumk; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_560_subarray_sub_equal_k_solution/","summary":"\u003cp\u003eThe task is to find a subarray with \u003ccode\u003esum of elements = k\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\u003c/p\u003e\n\u003cp\u003eThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\u003c/p\u003e\n\u003cp\u003e$$\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k]\n$$\u003c/p\u003e","title":"Leetcode 560: Subarray sum equals k"},{"content":"Consider the array: [0,1,1,0,0,1,1,0,1,1] The idea is to turn the 0\u0026rsquo;s into -1\u0026rsquo;s\narray: [-1,1,1,-1,-1,1,1,-1,1,1]\nNow, the task is to find a subarray with sum of elements = 0\nTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\nThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\n$$ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\ prefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k] $$\nAnd the length of the subarray between indices $$[i,j]$$ is defined as: $$length(i,j) = j-i+1 = j-(i-1) $$\nNow we are looking for sub of subarray = 0. Therefore:\n$$ sum\\ of\\ subarray = prefix\\ [j]\\ -\\ prefix\\ [i-1] = 0\\ prefix\\ [j]\\ =\\ prefix\\ [i-1] $$\nTherefore, we iterate the prefix array. And at each prefix[j], we search for a previously inserted prefix[i-1] such that prefix[j]=prefix[i-1]. We record the length of the current subarray as: length = j-(i-1).\nWe must store the mapping: ( prefix[k], k ) in a map to achieve this.\nSo far so good. But what happens when $$i=0$$. In this case, sum of subarray between indices [0, j] is defined as:\n$$ prefiix\\ [j] = \\sum_{k=0}^j nums\\ [k] $$\nAnd the length of the subarray [0,j] is: $$j+1 = j-(-1)$$\nTherefore we keep a superficial (prefix = 0, index = -1) in the map.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function findMaxLength(nums: number[]): number { const map = new Map\u0026lt;number, number\u0026gt;( [ [0, -1], ] ); let maxLen = 0; for ( let j=0; j \u0026lt; nums.length; j++ ) { let cur = ( nums[j] == 1 ) ? 1 : -1; nums[j] = ( j==0 ) ? cur : cur + nums[j-1]; // prefix sum occured previously at i. Length = j-i if ( map.has( nums[j] ) ) { let i = map.get( nums[j] ); maxLen = Math.max( maxLen, j - i ); } // put the current prefix sum into map if ( !map.has( nums[j] ) ) map.set( nums[j], j ); } return maxLen; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_525_contiguous_array/","summary":"\u003cp\u003eConsider the array: \u003ccode\u003e[0,1,1,0,0,1,1,0,1,1] \u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe idea is to turn the 0\u0026rsquo;s into -1\u0026rsquo;s\u003c/p\u003e\n\u003cp\u003earray: \u003ccode\u003e[-1,1,1,-1,-1,1,1,-1,1,1]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eNow, the task is to find a subarray with \u003ccode\u003esum of elements = 0\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo do this, we can build the prefix array with: $$ prefix\\ [x] = \\sum_{k=0}^x nums\\ [k] $$\u003c/p\u003e\n\u003cp\u003eThe sum of elements between subarray indices $$[i, j]$$ where $$j \u0026gt; i$$ is defined as:\u003c/p\u003e\n\u003cp\u003e$$\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=0}^{j} nums\\ [k] - \\sum_{k=0}^{i-1} nums\\ [k]\\\nprefix\\ [j]\\ -\\ prefix\\ [i-1] = \\sum_{k=i}^{j} nums\\ [k]\n$$\u003c/p\u003e","title":"Leetcode_525_contiguous_array"},{"content":"The idea is to keep 2 pointers. trail pointer and cur pointer. The list is build in recursive function build(trail, cur) which returns last node of the list we build.\nbuild works as follows:\nwhen there is no child node: simply connect trail and cur and advance both when there is a child node, then recursively call itself with build( trail = cur, cur = cur.child ). The call would connect cur node with the list in the next level. It would return the last node in next level. Then we assign trail = last node in next level and cur = cur.next in current level. This ensures that the next iteration would connect last node in next level to next node in current level. when cur becomes null trail is the last node in current level. return trail Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function flatten(head: _Node | null): _Node | null { const save: _Node = new _Node( -1 ); build( save, head ); if ( save.next ) save.next.prev = null; return save.next; }; function build( trail: _Node | null, cur: _Node | null ): _Node | null { while ( cur ) { if ( !cur.child ) { trail.next = cur; cur.prev = trail; trail = trail.next; cur = cur.next; } else { trail.next = cur; cur.prev = trail; const saveNext = cur.next; const lastNodeFromChildList = build( cur, cur.child ); cur.child = null; cur = saveNext; trail = lastNodeFromChildList; } } return trail; } Complexity Time complexity: $$O(n)$$\nSpace complexity: $$O(n)$$ {recursion stack}\n","permalink":"http://localhost:45763/personal_website/posts/leetcode_430_flattening_multilevel_linked_list/","summary":"\u003cp\u003eThe idea is to keep 2 pointers. \u003ccode\u003etrail\u003c/code\u003e pointer and \u003ccode\u003ecur\u003c/code\u003e pointer. The\nlist is build in recursive function \u003ccode\u003ebuild(trail, cur)\u003c/code\u003e which returns\nlast node of the list we build.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebuild\u003c/code\u003e works as follows:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ewhen there is no \u003ccode\u003echild\u003c/code\u003e node: simply connect \u003ccode\u003etrail\u003c/code\u003e and \u003ccode\u003ecur\u003c/code\u003e and advance both\u003c/li\u003e\n\u003cli\u003ewhen there is a \u003ccode\u003echild\u003c/code\u003e node, then recursively call itself with \u003ccode\u003ebuild( trail = cur, cur = cur.child )\u003c/code\u003e. The call would connect \u003ccode\u003ecur\u003c/code\u003e node with the \u003ccode\u003elist in the next level\u003c/code\u003e. It would return the last node in next level. Then we assign \u003ccode\u003etrail = last node in next level\u003c/code\u003e and \u003ccode\u003ecur = cur.next in current level\u003c/code\u003e. This ensures that the next iteration would connect \u003ccode\u003elast node in next level\u003c/code\u003e to \u003ccode\u003enext node in current level\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003ewhen \u003ccode\u003ecur\u003c/code\u003e becomes \u003ccode\u003enull\u003c/code\u003e \u003ccode\u003etrail\u003c/code\u003e is the last node in current level. \u003ccode\u003ereturn trail\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"code\"\u003eCode\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e24\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-typescript\" data-lang=\"typescript\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003eflatten\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ehead\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kr\"\u003econst\u003c/span\u003e   \u003cspan class=\"nx\"\u003esave\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ehead\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003esave\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunction\u003c/span\u003e \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e: \u003cspan class=\"kt\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nx\"\u003e_Node\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eprev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003esaveNext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"kr\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003elastNodeFromChildList\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003ebuild\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003echild\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003ecur\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003esaveNext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003elastNodeFromChildList\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003etrail\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"complexity\"\u003eComplexity\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTime complexity:  $$O(n)$$\u003c/p\u003e","title":"Leetcode 430: Flattening a multilevel linked list"},{"content":"DFS intuition First we must build a graph where airports are vertices and an edge airport1 -\u0026gt; airport2 denotes that the person travelled from airport1 -\u0026gt; airport2\nTo find a valid sequence of vertices/airports that covers all the edges/tickets, we traverse the graph using depth first search like traversal. The idea is:\nAt each vertex, move to the next lexicographically smallest vertex. delete the edge used To maintain lexicographical order, we sort the neighbours of each vertex lexicographically.\nAlgorithm: Step 1: Build an adjacency list, where the neighbours of each node are sorted lexicographically\nStep 2: Traverse using DFS starting from \u0026ldquo;JFK\u0026rdquo; airport. Remove edges as you move through the graph.\nIncorrect approach 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * @param {string[][]} tickets * @return {string[]} */ var findItinerary = function(tickets) { const graph = {}; for ( const [from, to] of tickets ) { if ( !graph[from] ) graph[from] = []; graph[from].push(to); } for ( const node of Object.keys(graph) ) graph[node].sort(); const path = []; const dfs = ( node = \u0026#34;JFK\u0026#34; ) =\u0026gt; { path.push(node); const to_where = graph[node] || []; while ( to_where.length ) { // remove the edge and visit the next smallest dfs( to_where.shift() ); } }; dfs(); return path; }; Why it does not work: Consider this example: [[\u0026ldquo;JFK\u0026rdquo;,\u0026ldquo;KUL\u0026rdquo;],[\u0026ldquo;JFK\u0026rdquo;,\u0026ldquo;NRT\u0026rdquo;],[\u0026ldquo;NRT\u0026rdquo;,\u0026ldquo;JFK\u0026rdquo;]]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 +---+ +---+ |JFK|----\u0026gt;|KUL| +---+ +---+ | ^ | | v | +---+ |NRT| +---+ path = [] # algorithm starts at JFK @JFK -\u0026gt; add(JFK) neighbours -\u0026gt; [KUL, NRT] explore(KUL) and remove edge JFK-\u0026gt;KUL ----(call 1) graph becomes: path = [JFK] +---+ +---+ |JFK| |KUL| +---+ +---+ | ^ | | v | +---+ |NRT| +---+ @KUL -\u0026gt; add(KUL) there are no neighbours so return to call(1) graph becomes: path = [JFK, KUL] +---+ +---+ |JFK| |KUL| +---+ +---+ | ^ | | v | +---+ |NRT| +---+ # So you see, we are again at JFK, even though there # is no edge from KUL to JFK @JFK again neighbours now -\u0026gt; [NRT] explore(NRT) and remove edge JFK-\u0026gt;NRT ----(call 2) +---+ +---+ |JFK| |KUL| +---+ +---+ ^ | | +---+ |NRT| +---+ @NRT -\u0026gt; add(NRT) neighbours -\u0026gt; [JFK] explore(JFK) and delete NRT -\u0026gt; JFK --- call(3) graph becomes: +---+ +---+ path = [JFK, KUL, NRT] |JFK| |KUL| +---+ +---+ +---+ |NRT| +---+ @ JFK -\u0026gt; add(JFK) no neighnour so return to call(3) graph becomes: +---+ +---+ path = [JFK, KUL, NRT, JFK] |JFK| |KUL| +---+ +---+ +---+ |NRT| +---+ @NRT (call 3) -\u0026gt; no more neighbours so return to call 2 @JFK (call 2) -\u0026gt; no more neighbours so algorithm ends The final path is: [JFK,KUL,NRT,JFK]\nIf we look at our tickets again: [[JFK, KUL],[JFK, NRT],[NRT, JFK]]\nWe go from JFK to KUL using the ticket [JFK, KUL]. Then we move from KUL to NRT even though there is no direct ticket [KUL, NRT].\nFrom our dry run, we saw how the algorithm transported us back from KUL to JFK, by magically teleporting us.\nCorrect approach So how to fix the problem above. The fix is simple, we shall only add a vertex, if all subgraph containing that vertex has been fully explored. This approach ensures that we are only using continous links.\nThis code is just 2 lines away from the dfs code above. I added comments on what changed and why.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * @param {string[][]} tickets * @return {string[]} */ var findItinerary = function(tickets) { const graph = {}; for ( const [from, to] of tickets ) { if ( !graph[from] ) graph[from] = []; graph[from].push(to); } for ( const node of Object.keys(graph) ) graph[node].sort(); const path = []; const dfs = ( node = \u0026#34;JFK\u0026#34; ) =\u0026gt; { const to_where = graph[node] || []; while ( to_where.length ) dfs( to_where.shift() ); path.push(node); // add node only after all // the subgraph has been explored }; dfs(); // we changed the order of insertion, and // we must reverse the path to obtain the original // itinerary return path.reverse(); }; Complexity Time: $$O( E )$$ Space: $$ O( V*E ) $$ // for storing the graph Additional info: An Eulerian trail or Euler walk, in an undirected graph is a walk that uses each edge exactly once. There are mainly 2 algorithms to solve this problem: Fleury\u0026rsquo;s algorithm, Hierholzer\u0026rsquo;s algorithm. [source: https://en.wikipedia.org/wiki/Eulerian_path]\nWhat we did above is a varient of Heirholzer\u0026rsquo;s algorithm.\n","permalink":"http://localhost:45763/personal_website/posts/leetcode_332_reconstruct_itenary/","summary":"\u003ch2 id=\"dfs-intuition\"\u003eDFS intuition\u003c/h2\u003e\n\u003cp\u003eFirst we must build a graph where airports are vertices and  an edge \u003ccode\u003eairport1 -\u0026gt; airport2\u003c/code\u003e denotes that the person travelled from \u003ccode\u003eairport1 -\u0026gt; airport2\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eTo find a valid sequence of \u003ccode\u003evertices/airports\u003c/code\u003e \u003cstrong\u003ethat covers all the \u003ccode\u003eedges/tickets\u003c/code\u003e\u003c/strong\u003e, we traverse the graph using depth first search like traversal. The idea is:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAt each vertex, move to the next lexicographically smallest vertex.\u003c/li\u003e\n\u003cli\u003edelete the edge used\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo maintain lexicographical order, we sort the neighbours of each vertex lexicographically.\u003c/p\u003e","title":"Leetcode 332: Reconstruct Itinerary. Eulerian path and Dfs"},{"content":"Below is my solution for the leetcode 154: Find minimum in rotated sorted array problem\nIntuition Fact is, that you cannot solve this question in O(log n) time. The reason is because of duplicates.\nConsider a situation like:\n$$ [2,2,2,2,1,2,2] $$\nwhere mid is at 3 and the minium number here is clearly $$1$$. But our binary search algorithm will not be able to figure out in which direction it should go, since starting, ending and middle values are all same. In this case the best we can do is increment mid which makes the worst running time: O(n)\nHowever, it is possible to solve this problem in O(n/2) as explain below.\nApproach We will make use of the fact that a sorted array follows the (min) heap property i.e. in a sorted array, at all parent nodes are smaller than their children.\nAnd if this sorted array is rotated, then the place at which the first violation occurs is the subtree where the answer will be found.\nComplexity Time complexity: $$O(n/2)$$ Space complexity: $$O(1)$$ Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 var findMin = function(a) { /** Approach: You cannot solve this problem in O(log n) since it contains duplicate values. But you can actually solve this problem in O(n/2) by using the fact that a sorted array follows heap property. And if a sorted array is rotated then the heap property no longer holds. to find the minium element traverse the array, and find the first subtree where the heap property does not hold. the minium of the 2 values where the heap property does not satisfy is also minium in the array. Time: O(n/2) Space: O(1) */ let A = a.length; let i = 0; while ( i \u0026lt;= Math.floor(A/2)-1 ) { let root = i; let lc = 2*i + 1; let rc = 2*i + 2; let smallest = root; if ( lc \u0026lt; A \u0026amp;\u0026amp; a[lc] \u0026lt; a[smallest] ) smallest = lc; if ( rc \u0026lt; A \u0026amp;\u0026amp; a[rc] \u0026lt; a[smallest] ) smallest = rc; if ( smallest != root ) /* violation found. the value at smallest is minium */ return a[smallest]; i++; } /* no violation found. Either the array is sorted ar there it is all duplicates, in either case, return the first element. */ return a[0]; }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_154_find_minimum_in_rotated_sorted_array/","summary":"\u003cp\u003eBelow is my solution for the \u003ca href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/\"\u003eleetcode 154: Find minimum in rotated\nsorted array problem\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"intuition\"\u003eIntuition\u003c/h1\u003e\n\u003c!-- Describe your first thoughts on how to solve this problem. --\u003e\n\u003cp\u003eFact is, that you \u003cstrong\u003ecannot\u003c/strong\u003e solve this question in \u003cstrong\u003eO(log n)\u003c/strong\u003e time. The reason is because of duplicates.\u003c/p\u003e\n\u003cp\u003eConsider a situation like:\u003c/p\u003e\n\u003cp\u003e$$\n[2,2,2,2,1,2,2]\n$$\u003c/p\u003e\n\u003cp\u003ewhere mid is at 3 and the minium number here is clearly $$1$$. But our binary search algorithm will not be able to figure out in which direction it should go, since starting, ending and middle values are all same. In this case the best we can do is increment mid which makes the worst running time: \u003cstrong\u003eO(n)\u003c/strong\u003e\u003c/p\u003e","title":"Leetcode 154: Find minimum in rotated sorted array"},{"content":"Here\u0026rsquo;s my solution to the Leetcode 315: Count of Smaller Numbers After Self problem using standard merge sort. I just change one line to count while merge procedure.\nSolution Let\u0026rsquo;s build the solution step by step.\nInput: nums = $$[5,2,6,1]$$\nFirst, turn the numbers into [number, index] tuple. So it looks like:\narray = $$ [ [ 5, 0 ], [ 2, 1 ], [ 6, 2 ], [ 1, 3 ] ] $$\nSecond, just write standard merge sort algorithm and sort the array in ascending order by first values.\nThe output is: $$ [ [ 1, 3 ], [ 2, 1 ], [ 5, 0 ], [ 6, 2 ] ] $$\nHere\u0026rsquo;s the trace of the algorithm:\nSimple merge sort implemented 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { tmp.push( a[j] ); j++; } else { tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); merge_sort( array, 0, array.length-1 ); }; So far so good.\nNow let\u0026rsquo;s get back to the question. The question is asking: For each index $$i$$, count all numbers at index $$j$$ such that $$i \u0026lt; j$$ and $$a[i] \u0026gt; a[j]$$. Or, simply put: for each number, find all numbers that appear after it and are smaller than it.\nNow, look at the visualization again, pay attention to the merge procedure (in magenta colour) and observe the following:\nat each merge procedure, we merge 2 consecutive partitions. all numbers in the left partition appear before numbers in right partition in the original array. The partitions are sorted in increasing order. Now, suppose we are merging 2 partitions where, the pointer of left partition is at $$x$$ and pointer of right partition is at $$y$$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [....a,b,c, x ,d,e,f....] [...h,i,j, y, k,l,m....] ^ ^ i j Suppose x \u0026gt; y It follows from observation 2 that: y is one of the numbers that appear to the right of x and is smaller than x ---(1) Also, since partitions are sorted (observation 3): d, e, f .... (i.e. all number that appear to the right of x) are greater than x. ----(2) From (1) and (2) we can conclude that: x, d, e, f, ... (i.e. all numbers to the right of x including x) appear before y. And y is smaller than all these numbers. Hence, required condition satisfied! Now, we just need a counter for each variable, and whenever the condition same as above occurs, we increment the counter for each x,d,e,\u0026hellip;\n1 2 3 4 5 6 7 [....a,b,c, x ,d,e,f....] [...h,i,j, y, k,l,m....] ^ ^ i j while merging: if x \u0026gt; y increment the counters of x, d, e, f, ... Single line changed in standard merge sort algorithm We can use the index at the second position to access the counter of that particular number.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 let counts; const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { /* ____(x \u0026gt; y) so increment counters of x,d,e,...____*/ for ( let p=i; p\u0026lt;=mid; p++ ) counts[ a[p][1] ]++; /*_______________INSERT THIS LINE_____________________*/ tmp.push( a[j] ); j++; } else { tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); counts = new Array(nums.length).fill(0); merge_sort( array, 0, array.length-1 ); return counts; }; That is the whole idea behind this question. Now the above implementation won\u0026rsquo;t work because at each iteration, we are updating whole left partition after i. Making it O(n^2) Optimize To avoid updating the whole partition, we keep a running counter cnt.\nFinal implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 let counts; const merge_sort = ( a, i, j ) =\u0026gt; { if ( i === j ) return; const mid = i + Math.floor( (j-i)/2 ); merge_sort( a, i, mid ); merge_sort( a, mid+1, j ); merge( a, i, mid, j ); }; const merge = (a, start, mid, end) =\u0026gt; { const tmp = []; let i = start, j = mid+1; let cnt = 0; // keep running counter while ( i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end ) { if ( a[i][0] \u0026gt; a[j][0] ) { cnt++; // increment counter tmp.push( a[j] ); j++; } else { counts[ a[i][1] ] += cnt; // no more numbers that are // smaller than i tmp.push( a[i] ); i++; } } while ( i \u0026lt;= mid ) { counts[ a[i][1] ] += cnt; // if left partition is not over // update left over number counts tmp.push( a[i] ); i++; } while ( j \u0026lt;= end ) { tmp.push( a[j] ); j++; } for ( let i=0; i \u0026lt; tmp.length; i++ ) a[start+i] = tmp[i]; }; var countSmaller = function( nums ) { const array = nums.map( (val, ind) =\u0026gt; [val, ind] ); counts = nums; counts.fill(0); merge_sort( array, 0, array.length-1 ); return counts; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def countSmaller(nums): counts = [0] * len(nums) array = [(num, i) for i, num in enumerate(nums)] def merge_sort(start, end): if start == end: return mid = (start + end) // 2 merge_sort(start, mid) merge_sort(mid + 1, end) merge(start, mid, end) def merge(start, mid, end): temp = [] i, j = start, mid + 1 cnt = 0 while i \u0026lt;= mid and j \u0026lt;= end: if array[i][0] \u0026gt; array[j][0]: cnt += 1 temp.append(array[j]) j += 1 else: counts[array[i][1]] += cnt temp.append(array[i]) i += 1 while i \u0026lt;= mid: counts[array[i][1]] += cnt temp.append(array[i]) i += 1 while j \u0026lt;= end: temp.append(array[j]) j += 1 for i in range(len(temp)): array[start + i] = temp[i] merge_sort(0, len(nums) - 1) return counts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; countSmaller(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; counts(nums.size(), 0); vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; array; for (int i = 0; i \u0026lt; nums.size(); i++) { array.emplace_back(nums[i], i); } function\u0026lt;void(int, int)\u0026gt; merge_sort = [\u0026amp;](int start, int end) { if (start == end) return; int mid = start + (end - start) / 2; merge_sort(start, mid); merge_sort(mid + 1, end); merge(start, mid, end); }; function\u0026lt;void(int, int, int)\u0026gt; merge = [\u0026amp;](int start, int mid, int end) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; temp; int i = start, j = mid + 1; int cnt = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end) { if (array[i].first \u0026gt; array[j].first) { cnt++; temp.push_back(array[j]); j++; } else { counts[array[i].second] += cnt; temp.push_back(array[i]); i++; } } while (i \u0026lt;= mid) { counts[array[i].second] += cnt; temp.push_back(array[i]); i++; } while (j \u0026lt;= end) { temp.push_back(array[j]); j++; } for (int k = 0; k \u0026lt; temp.size(); k++) { array[start + k] = temp[k]; } }; merge_sort(0, nums.size() - 1); return counts; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 import java.util.*; class Solution { private int[] counts; private int[][] array; public List\u0026lt;Integer\u0026gt; countSmaller(int[] nums) { counts = new int[nums.length]; array = new int[nums.length][2]; for (int i = 0; i \u0026lt; nums.length; i++) { array[i][0] = nums[i]; array[i][1] = i; } mergeSort(0, nums.length - 1); List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (int count : counts) { result.add(count); } return result; } private void mergeSort(int start, int end) { if (start == end) return; int mid = start + (end - start) / 2; mergeSort(start, mid); mergeSort(mid + 1, end); merge(start, mid, end); } private void merge(int start, int mid, int end) { List\u0026lt;int[]\u0026gt; temp = new ArrayList\u0026lt;\u0026gt;(); int i = start, j = mid + 1; int cnt = 0; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= end) { if (array[i][0] \u0026gt; array[j][0]) { cnt++; temp.add(array[j]); j++; } else { counts[array[i][1]] += cnt; temp.add(array[i]); i++; } } while (i \u0026lt;= mid) { counts[array[i][1]] += cnt; temp.add(array[i]); i++; } while (j \u0026lt;= end) { temp.add(array[j]); j++; } for (int k = 0; k \u0026lt; temp.size(); k++) { array[start + k] = temp.get(k); } } } Time: $$O(n\\ log\\ n)$$ Space: $$O(n)$$ ","permalink":"http://localhost:45763/personal_website/posts/leetcode_315_count_of_smaller_numbers_after_self/","summary":"\u003cp\u003eHere\u0026rsquo;s my solution to the \u003ca href=\"https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/\"\u003eLeetcode 315: Count of Smaller Numbers After\nSelf problem\u003c/a\u003e using standard merge sort. I just change one line to\ncount while merge procedure.\u003c/p\u003e\n\u003ch2 id=\"solution\"\u003eSolution\u003c/h2\u003e\n\u003cp\u003eLet\u0026rsquo;s build the solution step by step.\u003c/p\u003e\n\u003cp\u003eInput: nums = $$[5,2,6,1]$$\u003c/p\u003e\n\u003cp\u003eFirst, turn the numbers into \u003cstrong\u003e[number, index]\u003c/strong\u003e tuple. So it looks like:\u003c/p\u003e\n\u003cp\u003earray = $$ [ [ 5, 0 ], [ 2, 1 ], [ 6, 2 ], [ 1, 3 ] ] $$\u003c/p\u003e","title":"Leetcode 315: Count of Smaller Numbers After Self"},{"content":"Here\u0026rsquo;s my explanation for the leetcode 306: Additive Number problem\nAdditive Number Problem Problem Recap An additive number is a string of digits where the sequence of numbers formed by splitting the string satisfies the condition that each number (after the first two) is the sum of the two preceding numbers.\nExamples: \u0026quot;112358\u0026quot; is additive because the sequence is 1, 1, 2, 3, 5, 8, and:\n1 + 1 = 2 1 + 2 = 3 2 + 3 = 5 3 + 5 = 8 \u0026quot;199100199\u0026quot; is additive because the sequence is 1, 99, 100, 199, and:\n1 + 99 = 100 99 + 100 = 199 Solution Approach The solution uses a backtracking approach to try all possible splits of the string into sequences of numbers and checks if any of these sequences form an additive sequence.\nDetailed Explanation Helper Function isValid This recursive function checks if the remaining part of the string s forms a valid additive sequence given the first two numbers a and b.\nBase Case: If the remaining string s is empty, it means we\u0026rsquo;ve successfully formed an additive sequence, so return true.\nRecursive Step:\nCompute the sum of a and b and convert it to a string sum. Check if the remaining string s starts with sum: If not, the sequence is invalid  return false. If yes, recursively check the next part of the string with the new pair (b, sum) and the remaining string after removing sum. Main Function isAdditiveNumber Initialization: Get the length of the input string num. Nested Loops: The outer loop (i) determines the end index of the first number a (from index 0 to i). The inner loop (j) determines the end index of the second number b (from index i to j). Leading Zero Check: Skip any splits where a or b have leading zeros unless they are exactly \u0026quot;0\u0026quot;. Example: \u0026quot;02\u0026quot; is invalid, but \u0026quot;0\u0026quot; is valid. Validation: For each valid pair (a, b), call isValid to check if the remaining part of the string forms a valid additive sequence starting with a and b. If isValid returns true, immediately return true from the main function. Final Check: If no valid sequence is found after all possible splits, return false. Example Walkthrough Let\u0026rsquo;s walk through the example num = \u0026quot;112358\u0026quot;:\nFirst Iteration (i = 1, j = 2): a = \u0026quot;1\u0026quot;, b = \u0026quot;1\u0026quot;. No leading zeros  proceed. isValid(1, 1, \u0026quot;2358\u0026quot;): Sum of 1 + 1 = 2. Check if \u0026quot;2358\u0026quot; starts with \u0026quot;2\u0026quot;  Yes. Recursively call isValid(1, 2, \u0026quot;358\u0026quot;): Sum of 1 + 2 = 3. Check if \u0026quot;358\u0026quot; starts with \u0026quot;3\u0026quot;  Yes. Recursively call isValid(2, 3, \u0026quot;58\u0026quot;): Sum of 2 + 3 = 5. Check if \u0026quot;58\u0026quot; starts with \u0026quot;5\u0026quot;  Yes. Recursively call isValid(3, 5, \u0026quot;8\u0026quot;): Sum of 3 + 5 = 8. Check if \u0026quot;8\u0026quot; starts with \u0026quot;8\u0026quot;  Yes. Recursively call isValid(5, 8, \u0026quot;\u0026quot;): Empty string  return true. Since isValid returned true, the main function returns true. Edge Cases Leading Zeros: Correctly skips invalid splits (e.g., \u0026quot;02\u0026quot; unless it\u0026rsquo;s \u0026quot;0\u0026quot;). Single Digit: If input length \u0026lt; 3, returns false. Large Numbers: Uses parseInt, but BigInt is better for very large numbers to avoid precision issues. Time Complexity Nested loops: O(n), where n is the string length. isValid function: O(n) per pair (a, b). Overall: O(n), feasible for reasonably sized strings. Space Complexity O(n) due to recursion stack in the worst case. Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var isAdditiveNumber = function(num) { const isValid = (a, b, s) =\u0026gt; { if (s.length === 0) return true; const sum = (a + b).toString(); return s.startsWith(sum) \u0026amp;\u0026amp; isValid(b, parseInt(sum), s.slice(sum.length)); }; const n = num.length; for (let i = 1; i \u0026lt; n; i++) { for (let j = i + 1; j \u0026lt; n; j++) { const a = num.slice(0, i); const b = num.slice(i, j); if ((a.startsWith(\u0026#39;0\u0026#39;) \u0026amp;\u0026amp; a.length \u0026gt; 1) || (b.startsWith(\u0026#39;0\u0026#39;) \u0026amp;\u0026amp; b.length \u0026gt; 1)) continue; if (isValid(parseInt(a), parseInt(b), num.slice(j))) return true; } } return false; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 var isAdditiveNumber = function(num) { let N = num.length; let check = ( a ) =\u0026gt; { /** check if numbers in an array form fibonacci seqence **/ let A = a.length; if ( A \u0026lt; 3 ) return false; for ( let i=2; i \u0026lt; A; i++ ) if ( Number(a[i]) != Number(a[i-1]) + Number(a[i-2]) || ( a[i].length \u0026gt; 1 \u0026amp;\u0026amp; a[i].startsWith(\u0026#39;0\u0026#39;) ) || ( a[i-1].length \u0026gt; 1 \u0026amp;\u0026amp; a[i-1].startsWith(\u0026#39;0\u0026#39;) ) || ( a[i-2].length \u0026gt; 1 \u0026amp;\u0026amp; a[i-2].startsWith(\u0026#39;0\u0026#39;) ) ) return false; return true; }; let bt_search = ( i, cur = [] ) =\u0026gt; { if ( i \u0026gt; N ) return false; if ( i === N \u0026amp;\u0026amp; check(cur) ) return true; // num[i] starts a new number, explore path cur.push( num[i] ); let new_start = bt_search( i+1, cur ); if ( new_start ) return true; // backtrack, num[i] continues the previous number cur.pop(); if ( i \u0026gt; 0 ) { cur[ cur.length-1 ] += num[i]; let add_prev = bt_search( i+1, cur ); if ( add_prev ) return true; } return false; }; return bt_search( 0 ); }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_306_additive_number/","summary":"\u003cp\u003eHere\u0026rsquo;s my explanation for the \u003ca href=\"https://leetcode.com/problems/additive-number/description/\"\u003eleetcode 306: Additive Number problem\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"additive-number-problem\"\u003eAdditive Number Problem\u003c/h2\u003e\n\u003ch3 id=\"problem-recap\"\u003eProblem Recap\u003c/h3\u003e\n\u003cp\u003eAn \u003cstrong\u003eadditive number\u003c/strong\u003e is a string of digits where the sequence of numbers formed by splitting the string satisfies the condition that each number (after the first two) is the sum of the two preceding numbers.\u003c/p\u003e\n\u003ch4 id=\"examples\"\u003eExamples:\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026quot;112358\u0026quot;\u003c/code\u003e is additive because the sequence is \u003ccode\u003e1, 1, 2, 3, 5, 8\u003c/code\u003e, and:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e1 + 1 = 2\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e1 + 2 = 3\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e2 + 3 = 5\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e3 + 5 = 8\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003e\u0026quot;199100199\u0026quot;\u003c/code\u003e is additive because the sequence is \u003ccode\u003e1, 99, 100, 199\u003c/code\u003e, and:\u003c/p\u003e","title":"Leetcode 306: Additive number"},{"content":"Here are all possible solutions I could come up with for the longest increasing subsequence problem. leetcode 300\nApproach 1: Generate all possible increasing subsequences We will keep track of a subsequence in an array named cur_subsequence or cur_sub. For each element (a[i]) we have the following 2 options:\nAdd the element to the end of current subsequence.\nNote: The current element can only be included if either the current subsequence is empty or the last element of the current subsequence is smaller than the current element. This is important to maintain the increasing subsequence property.\nIgnore the current element and explore without a[i]\nTime complexity: $$ O(2^N) $$ Space complexity: $$ O(N) $$ // recursion stack + auxilary array 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 var lengthOfLIS = function(a) { let A = a.length; // maximum length of a subsequence seen so far let max_len = 1; let bt_search = ( i, cur_sub = [] ) =\u0026gt; { if ( i \u0026gt;= A ) { max_len = Math.max( max_len, cur_sub.length ); return; } // either select the ith element, or ignore it. // a[i] can be taken when either subsequencee is empty or // last inserted element is smaller if ( !cur_sub.length || cur_sub[ cur_sub.length-1 ] \u0026lt; a[i] ) { cur_sub.push( a[i] ); bt_search( i+1, cur_sub ); cur_sub.pop(); // backtrack } // explore without a[i] included bt_search( i+1, cur_sub ); }; bt_search(0); return max_len; } Approach 2 (Version 1) : Generating all possible subsequences, but change the structure of the recursion to allow memoization Currently, we are keeping track of the current subsequence in an array cur_sub which makes it difficult for us to implement memoization. Notice that we only need previously selected element (to compare if current element is larger) and current length (to find the subsequence length). Hence, we will only use 3 variables: index, previous element index, current length.\nTime complexity: $$ O( N^2 ) $$ Space complexity: $$O( N^3 )$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 var lengthOfLIS = function(a) { /** Write a recurrence relation. Either you take the element @i or your ignore it. In either case, your pick the maximum length. generating all possible increasing subsequences, but not storing the subsequence and using only 3 variables. for each call(index, prev_selected, cur_length) we try to find the maximum length we can form by either selecting or rejecting a[i] This configuration is easy to memoize. **/ let A = a.length; let memo = new Map(); let bt_search = ( i, prev, cur_len = 0 ) =\u0026gt; { // inputs of the function are memoized by turning // them into a String `key` let key = JSON.stringify( [i, prev, cur_len] ); if (memo.has(key)) return memo.get(key); if ( i \u0026gt;= A ) return cur_len; let take = -1, not_take = -1; // a[i] can be taken if prev=null / cur_len=0 // or prev \u0026lt; a[i] if ( cur_len == 0 || prev \u0026lt; a[i] ) take = bt_search( i+1, a[i], cur_len+1 ); // backtrack. do not take a[i] not_take = bt_search( i+1, prev, cur_len ); let res = Math.max( take, not_take ); memo.set(key, res); return memo.get(key); }; return bt_search(0); } Approach 2 (Version 2): Yet another recursive solution, but with better memoization This solution memoizes using only: index of current element (i), index of previously selected element (prev_i).\nThe memoization is done in a matrix of size $$N$$X$$(N+1)$$.\nTime complexity: $$ O( N^2 ) $$ Space complexity: $$O( N^2 )$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 var lengthOfLIS = function(a) { /** Approach 2 (version 2): Instead of storing 3 variables, just store 2 variables. This will enable memoization table to be an NxN matrix. **/ let A = a.length; let memo = new Array( A ).fill(null).map( () =\u0026gt; new Array( A+1 ).fill( null ) ); let bt_search = ( i, prev_i = -1 ) =\u0026gt; { // y is remapped since prev_i is in range [-1,n-1] // but our array ranges is in range [0, n] let x = i, y = prev_i + 1; if ( i \u0026gt;= A ) return 0; if ( memo[x][y] !== null ) return memo[x][y]; let take = -1, not_take = -1; // a[i] can be taken if prev_i = -1 / cur_len=0 or // a[prev_i] \u0026lt; a[i] if ( prev_i == -1 || a[prev_i] \u0026lt; a[i] ) take = 1 + bt_search( i+1, i ); // backtrack. do not take a[i]. The length remains same not_take = bt_search( i+1, prev_i ); let res = Math.max( take, not_take ); memo[x][y] = res; return memo[x][y]; }; return bt_search(0); } Approach 3: Dynamic programming Declare a lis(longest increasing subsequence) array, where lis[i] denotes the length of longest increasing subsequence starting at i and ending at the end of the array. Fill this table from second last element towards first element.\nTo find lis[i] for an element a[i] use the following algorithm:\nFor each i \u0026lt;- n-2 - 0 // find if index i can form an increasing subsequence // with any element on the right of it max_len = 1 For each j \u0026lt;- i+1 - n if ( a[i] \u0026lt; a[j] ) // a[j] is a potential connection point max_len = MAX( max_len, 1 + lis[j] ) lis[i] = max_len The basic intuition behind it is, that we explore all elements to the right of a[i] which can connect with a[i] to form an increasing subsequence. The length of such a subsequence is given by:\n1 (length of a[i]) + length of longest subsequence from a[j] up until the end of the array\nwhich is same as: 1 + lcs[j]\nTime: $$O(n^2)$$ Space: $$O(n)$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 let MAX = Math.max; var lengthOfLIS = function(a) { /** Appraoch 3: Build the dp table manually using loops **/ let A = a.length; let lis = new Array( A ).fill(1); // global maximum, subsequence length from a[i] until end let gmax = 1; for ( let i = A-2; i \u0026gt;= 0; i-- ) { let max_len = 1; for ( let j = i+1; j \u0026lt; A; j++ ) { if ( a[i] \u0026lt; a[j] ) max_len = MAX( max_len, 1+lis[j] ); } lis[i] = max_len; gmax = MAX( max_len, gmax ); } return gmax; } Approach 4: Build an auxilary array, such that the minium elements are always at the end of it Here, we are basically trying to kick out large elements and inserting small elements whereever possible, so that new incoming elements feel welcome attaching themselves to the existing subsequence.\nBuild a auxilary array using the following algorithm:\nsubsequence = [] For each i \u0026lt;- 0 to A-1 if subsequence.last_element \u0026lt; a[i] subsequence.push( a[i] ) else { replace the largest element smaller than or equal to a[i] in subsequence using binary search. } the length of the subsequence is the length of the largest increasing subsequence. Time: $$O(n\\ log n)$$ // n for iteration, and for each iteration binary search O(log n) Space: $$O(n)$$ // auxilary array Note that the array that we actually build here does not represent a valid increasing subsequence. Nor is it the longest increasing subsequence, we just insert the elements using a particularly methodology which ensures its validity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 let MAX = Math.max; let FLOOR = Math.floor; var b_search = ( a, target ) =\u0026gt; { // return the index pf the number \u0026gt;= target let i = 0, j = a.length-1; while ( i \u0026lt;= j ) { let mid = i + FLOOR( (j-i)/2 ); if ( a[mid] == target ) return mid; else if ( a[mid] \u0026lt; target ) i = mid+1; else j = mid-1; } return i; }; var lengthOfLIS = function(a) { /** Approach 4: The idea is to keep the minium elements, such that validity of lis(longest increasing subsequence) for new incoming elements can be calculated quickly **/ let A = a.length; let sub = [ a[0] ]; for ( let i=1; i \u0026lt; A; i++ ) { let lst = sub.length-1; if ( sub[ lst ] \u0026lt; a[i] ) sub.push( a[i] ); else { // find a \u0026#34;write index\u0026#34; where we replace a[i] let wi = b_search( sub, a[i] ); sub[wi] = a[i]; } } return sub.length; } Approach 5: In place algorithm for approach 4 Time: $$O(n\\ logn)$$ Space: $$O(1)$$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 let MAX = Math.max; let FLOOR = Math.floor; /* this version is for searching within the same array starting and ending position are requirede */ var b_search = ( a, start, end, target ) =\u0026gt; { // return the index pf the number \u0026gt;= target let i = start, j = end; while ( i \u0026lt;= j ) { let mid = i + FLOOR( (j-i)/2 ); if ( a[mid] == target ) return mid; else if ( a[mid] \u0026lt; target ) i = mid+1; else j = mid-1; } return i; }; var lengthOfLIS = function(a) { /*** Approach 5: Same as the above approach, but in place Hence saving auxilary space. The idea is to keep a variable to mark the end of the subsequence in a itself. **/ let A = a.length; let S = 1; // variable to mark the end of the subsequence for ( let i=1; i \u0026lt; A; i++ ) { if ( a[S-1] \u0026lt; a[i] ) { a[S] = a[i]; S++; } else { // find a \u0026#34;write index\u0026#34; where we replace a[i] let wi = b_search( a, 0, S-1, a[i] ); a[wi] = a[i]; } } return S; } ","permalink":"http://localhost:45763/personal_website/posts/all_possible_solutions_to_longest_increasing_subsequence_problem_leetcode_300/","summary":"\u003cp\u003eHere are all possible solutions I could come up with for the longest\nincreasing subsequence problem. \u003ca href=\"https://leetcode.com/problems/factorial-trailing-zeroes/description/\"\u003eleetcode\n300\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"approach-1-generate-all-possible-increasing-subsequences\"\u003eApproach 1: Generate all possible increasing subsequences\u003c/h1\u003e\n\u003cp\u003eWe will keep track of a subsequence in an array named \u003ccode\u003ecur_subsequence\u003c/code\u003e\nor \u003ccode\u003ecur_sub\u003c/code\u003e. For each element (\u003ccode\u003ea[i]\u003c/code\u003e)  we have the following 2\noptions:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eAdd the element to the end of current subsequence.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eNote: The current element can only be included if\neither the current subsequence is empty or the last\nelement of the current subsequence is smaller than\nthe current element. This is important to maintain\nthe increasing subsequence property.\u003c/em\u003e\u003c/p\u003e","title":"All possible solutions to longest increasing subsequence problem: leetcode 300"},{"content":"Problem link: leetcode 70: climbing stairs\nIntuition You need to climb n stairs, taking 1 or 2 stairs at a time.\nIf n = 2, you can climb like:\n$$1+1 = 2\\times (1) + 0 \\times(2)$$ $$2 = 0 \\times (1) + 1\\times(2) $$ if n = 3, you can climb like:\n$$1+1+1 = 3\\times(1) + 0\\times(2)$$ $$1+2 = 1\\times(1) + 1\\times(2)$$ $$2+1 = 1\\times(1) + 1\\times(2) $$ Basically you first need to decide how many steps of size 1 will you take and how many of size 2 do you need:\nHence, your first task is to solve the equation:\n$$ x \\times 1 + y \\times 2 = n $$\nTo decide the number of 1s and 2s. After you decide upon x and y then you will have calculate $$ \\frac{(x + y)!}{x! , y!} $$\nWhich is nothing but ways of chosing how exactly you will proceed. This is because we are trying to adjust x identical objects and y identical objects in x+y positions. Think of the number of ways you can arrange x men and y women in x + y positions.\nAs an example $$n=3, x=1 $$ and $$y=1$$\nThen you will have $$\\frac{(1 + 1)!}{1! , 1!} =2$$. see above, they are: $$ 1+2 \\ 2+1 $$\nApproach $$ y \\in [0, n/2] $$\nFor each , calculate the corresponding values of $$x$$ using the equation: $$ x \\times 1 + y \\times 2 = n \\ x = n - (2 \\times y ) $$\nthen calculate $$ \\frac{(x + y)!}{x! , y!} $$\nand add this to your counter variable.\nreturn counter.\nComplexity Time complexity: Time: O($$n^2$$)\nSpace: O(1)\nBut it can be reduced, if you can store calculated factorials. Hence, making the time complexity of calculating $$ \\frac{(x + y)!}{x! , y!} $$ -\u0026gt; O(1) and Space complexity O(n)\nTime complexity: O(n) Space complexity: O(n)\nCode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 var permute = (x,y) =\u0026gt; { /* compute (x+y)! / x! y! without computing factorials */ /* which is basically computing x+y x+y-1 x+y-2 .. y+1 / x! */ var denom = 1; for (var i=1; i \u0026lt;= x; i++) denom *= i; var numi = 1; for (var i = y+1; i \u0026lt;= x+y; i++) numi *= i; return numi/denom; }; var climbStairs = function(n) { /* The number of ways in which we can get n by adding only 1 and 2 Let, 1x + 2y = n ---(1) then we need to find the number of integer solutions to this equation. that is S = {x,y | x,y in integers} we need to return |S| i.e. the number of elements in this solution set. from (1) it implies x = n - 2y ---(2) y in range [0,n/2] i.e. consequently x in range [0,n] hence, iterate over y from 0 to n/2 such that y is integer. we find the corrosponding solution using equation 2 */ let n_solutions = 0 ; for (var y=0; y \u0026lt;= Math.floor(n/2); y++ ) { var x = n - (2 * y); n_solutions += permute(x,y); } return (n_solutions); }; ","permalink":"http://localhost:45763/personal_website/posts/leetcode_70/","summary":"\u003cp\u003eProblem link: \u003ca href=\"https://leetcode.com/problems/climbing-stairs/description/\"\u003eleetcode 70: climbing stairs\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"intuition\"\u003eIntuition\u003c/h1\u003e\n\u003c!-- Describe your first thoughts on how to solve this problem. --\u003e\n\u003cp\u003eYou need to climb \u003ccode\u003en\u003c/code\u003e stairs, taking 1 or 2 stairs at a time.\u003c/p\u003e\n\u003cp\u003eIf n = 2, you can climb like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$$1+1 = 2\\times (1) + 0 \\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$2 = 0 \\times (1) + 1\\times(2) $$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eif n = 3, you can climb like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$$1+1+1 =  3\\times(1) + 0\\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$1+2   =  1\\times(1) + 1\\times(2)$$\u003c/li\u003e\n\u003cli\u003e$$2+1   =  1\\times(1) + 1\\times(2) $$\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBasically you first need to decide how many steps of size 1 will you take and how many of size 2 do you need:\u003c/p\u003e","title":"Leetcode 70: Climbing Stairs"},{"content":"Below is my C solution for the Leetcode problem candy.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 static inline void previous_kids_started_crying(int* kid, int continous_decrease_start, int continous_decrease_end, int* candy) { /* * To satisfy the condition that each child with higher rating than * it\u0026#39;s neighbors must get more candies. We give all children in range * [continous_decrease_start, continous_decrease_end] an extra candy * if the he has candies lower or equal to the kid after it. * * Note that we do not bother the kid before it, since it is known * that the kid before it has more rating than this kid */ if (continous_decrease_start == -1) { exit(1); } for (int i = continous_decrease_end; i \u0026gt;= continous_decrease_start; i--) { if (kid[i] \u0026lt;= kid[i+1]) { int before = kid[i]; kid[i]++; int after = kid[i]; *candy += after - before;; } else { /* chain is broken. We found a satisfied non protesting kid the kids before it must also be non-protesting */ return; } } } int candy(int* kid, int n) { /* * Few things to take care of: * * 1. At a time take a look at 2 children. i.e. iterate the children * in window of 2. * * 2. Each time a candy is given, check if previous child has more * rating, since he will start crying. He/she will protest that the * kid in front of him has less rating than him/her and still got * more/equal candies than him/her. It might even trigger a chain * where the kid previous to the previous kid might also see this * changed state, and if he had a rating more then the kid after him. * then he will also start asking more candies. And the kid behind * that and so on. * * The algorithm runs in linear time, however, if the children are * arranged in decreasing order of rating, then at each iteration all * previous children will start crying. Hence, everybofy needs to be * given more candies. In that case it becomes quadratic * * Space required is constant. * * Best case: * Time: O(n) * Space: O(1) * * Worst Case: * Time: O(n^2) * Space: O(1) */ int candies = 0; int continous_decrease_from = -1; /* First child gets a candy, but save his rating first */ int previous_child_rating = kid[0]; kid[0] = 1; candies++; for (int i = 1; i \u0026lt; n; i++) { if (kid[i] \u0026gt; previous_child_rating) { /* Since this child has more rating than the previous child, this child gets 1 more candy than previous child */ previous_child_rating = kid[i]; kid[i] = kid[i-1]+1; candies += kid[i]; continous_decrease_from = -1; } else if (kid[i] == previous_child_rating){ /* Since this child has equal rating than the previous child, give him 1 candy */ previous_child_rating = kid[i]; kid[i] = 1; candies++; continous_decrease_from = -1; } else { /* Previous child has more rating. Give this child one candy, and after giving : if the previous child had less candy, then we must initiate a chain reaction to do justice to all previous kids to previous children the problem here is that if this child has less rating then his predecessor then he will also start crying. And, the predecesor of this child also has more score then he will also start crying. Hence, we must give candies to them as well to maintain rule. Hence, check if the rule is disturbed, */ if (continous_decrease_from == -1) { /* A period of continous decrease started */ /* Hence, give this child 1 candy and if the previous child will also get 1 candy if he gets */ continous_decrease_from = i-1; previous_child_rating = kid[i]; kid[i] = 1; if (kid[i-1] \u0026gt; kid[i]) { candies ++; } else { kid[i-1] = kid[i] + 1; candies += 2; } } else { /* Give this child a candy, but mind the children behind this child */ previous_child_rating = kid[i]; kid[i] = 1; candies++; previous_kids_started_crying(kid, continous_decrease_from, i-1, \u0026amp;candies); } } } return candies; } ","permalink":"http://localhost:45763/personal_website/posts/leetcode_135/","summary":"\u003cp\u003eBelow is my C solution for the Leetcode problem \u003ca href=\"https://leetcode.com/problems/climbing-stairs/description/\"\u003ecandy\u003c/a\u003e.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e  1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e  9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 17\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 18\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 19\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 20\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 21\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 22\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 23\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 24\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 25\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 26\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 27\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 28\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 29\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 30\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 31\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 32\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 33\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 34\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 35\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 36\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 37\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 38\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 39\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 40\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 41\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 42\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 43\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 44\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 45\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 46\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 47\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 48\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 49\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 50\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 51\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 52\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 53\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 54\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 55\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 56\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 57\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 58\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 59\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 60\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 61\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 62\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 63\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 64\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 65\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 66\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 67\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 68\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 69\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 70\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 71\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 72\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 73\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 74\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 75\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 76\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 77\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 78\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 79\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 80\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 81\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 82\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 83\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 84\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 85\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 86\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 87\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 88\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 89\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 90\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 91\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 92\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 93\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 94\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 95\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 96\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 97\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 98\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 99\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e100\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e101\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e102\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e103\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e104\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e105\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e106\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e107\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e108\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e109\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e110\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e111\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e112\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e113\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e114\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e115\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e116\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e117\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e118\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e119\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e120\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e121\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e122\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e123\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e124\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e125\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e126\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e127\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e128\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e129\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e130\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e131\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e132\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e133\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e134\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c\" data-lang=\"c\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kr\"\u003einline\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eprevious_kids_started_crying\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_end\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ecandy\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * To satisfy the condition that each child with higher rating than\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * it\u0026#39;s neighbors must get more candies. We give all children in range\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * [continous_decrease_start, continous_decrease_end] an extra candy\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * if the he has candies lower or equal to the kid after it.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Note that we do not bother the kid before it, since it is known\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * that the kid before it has more rating than this kid\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e        */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nf\"\u003eexit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_end\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_start\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ebefore\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eafter\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ecandy\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003eafter\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003ebefore\u003c/span\u003e\u003cspan class=\"p\"\u003e;;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* chain is broken. We found a satisfied non protesting kid\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                          the kids before it must also be non-protesting */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ecandy\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/*\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Few things to take care of:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * 1. At a time take a look at 2 children. i.e. iterate the children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * in window of 2.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * 2. Each time a candy is given, check if previous child has more\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * rating, since he will start crying. He/she will protest that the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * kid in front of him has less rating than him/her and still got\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * more/equal candies than him/her. It might even trigger a chain\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * where the kid previous to the previous kid might also see this\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * changed state, and if he had a rating more then the kid after him.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * then he will also start asking more candies. And the kid behind\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * that and so on.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * The algorithm runs in linear time, however, if the children are\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * arranged in decreasing order of rating, then at each iteration all\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * previous children will start crying. Hence, everybofy needs to be\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * given more candies. In that case it becomes quadratic\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space required is constant.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Best case:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Time: O(n)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space: O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           *\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Worst Case:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Time: O(n^2)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e           * Space: O(1)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e         */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"cm\"\u003e/* First child gets a candy, but save his rating first */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Since this child has more rating than the previous\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         child, this child gets 1 more candy than previous\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         child */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Since this child has equal rating than the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                         previous child, give him 1 candy */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"cm\"\u003e/* Previous child has more rating. Give this child one\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candy, and after giving : if the previous child had less\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candy, then we must initiate a chain reaction to do\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        justice to all previous kids to previous children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        the problem here is that if this child has less rating\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        then his predecessor then he will also start crying.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        And, the predecesor of this child also has more score\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        then he will also start crying. Hence, we must give\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        candies to them as well to maintain rule. Hence, check\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        if the rule is disturbed,\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                        */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* A period of continous decrease started */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* Hence, give this child 1 candy and if the\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                                   previous child will also get 1 candy if he gets  */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\t\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"cm\"\u003e/* Give this child a candy, but mind the children\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cm\"\u003e                                  behind this child */\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003eprevious_child_rating\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                \u003cspan class=\"nf\"\u003eprevious_kids_started_crying\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"n\"\u003econtinous_decrease_from\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                             \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ecandies\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Leetcode 135: Candy"},{"content":"Introduction Linux is the kernel that powers the modern computing world. Its everywherefrom all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isnt about why Linux dominates the tech world; its about how I started contributing to the Linux Kerneland how you can too.\nHow Kernel Development Works Kernel development thrives on the Linux Kernel Mailing List (LKML), the nerve center of Linuxs open-source ecosystem. The beauty of open source? Anyone can contribute. Your task is to send patches (essentially the output of git diff refurbushed into an email).\nIf your patch solves a real problem or adds value, experienced developers will jump in with questions about your intent and rationale. Heres a pro tip: dont explain the how of your code; let the code speak for itself. Instead, focus on explaining why your change is needed.\nThe LKML community is incredibly supportive \u0026ndash; theyll critique your code, point out mistakes, and suggest improvements. Sure, it might feel overwhelming initially, but resources like the LFD103 course can guide you through the basics: generating patches, submitting them to LKML, compiling, and booting the kernel.\nFor me, just setting up my mail client and understanding LKML discussions took about a month. But once you clear these initial hurdles, things get easier. If youre struggling, feel free to check out my notesthey might save you some time.\nMy Background For years, kernel developers seemed like magicians to medoing impossibly cool things with computers. My fascination started after I stumbled upon a video of someone working on the kernel. It was mesmerizing!\nIn my second semester, I discovered the book The C Programming Language, and it sparked my love for C. The control C offers is unmatched, but it comes with its fair share of challengesbugs galore!\nSurprisingly, I wasnt a Linux user until recently. When I finally switched from Windows to Linux, everything just clicked. Concepts that once felt abstract suddenly made sense. On Windows, troubleshooting often felt like solving a mystery even Microsoft couldnt decode. On Linux, it felt like someone handed me the keys to the entire system.\nWhile working on kernel contributions, I read Linux Device Drivers, a book authored by seasoned kernel developers. It gave me a deeper understanding of the kernels inner workings. If youre serious about kernel development or writing drivers, this book is a must-read.\nWhat to Contribute The hardest part of contributing to the Linux Kernel is figuring out what to work on. The kernel is vasttheres everything from GPU drivers to network stack development.\nSince the kernels primary job is managing hardware, driver development is a hotspot of activity. New devices constantly hit the market, and they need drivers. If you have an electronics background and access to hardware, driver development is an excellent starting point.\nIf hardware isnt your thing (like in my case), here are some alternatives:\nkselftest: A testing framework for kernel functionality. Core subsystems: The backbone of the kernela great way to learn the essentials. syzbot reports: A kernel fuzzer that uncovers bugs by feeding the kernel random data. These reports are a goldmine for learning about common mistakes. Another beginner-friendly option is upgrading deprecated APIs. These updates are highly appreciated because they improve the kernels maintainability and security. Its not always a simple find-and-replaceyoull need to understand the codebut its a rewarding way to start.\nAnd dont underestimate fixing spelling and grammar errors in the documentation or comments. While it might sound trivial, its a fantastic way to learn the workflow: creating patches, submitting them, and receiving feedback. Tools like codespell can help you automate finding these errors.\nMy first-ever patch was a simple typo fix, but I made the classic rookie mistake of introducing two changes while documenting only one. Lesson learned!\nOnce you start contributing, youll notice issues everywhere. Even just following discussions on LKML can teach you a ton about how seasoned developers think and work.\nConclusion Kernel development might seem intimidating at first, but trust me, its worth the effort. Youll not only become a stronger developer but also gain a deep understanding of how computers work. Youll build expertise in both kernel and userspace development, and your Git skills will level up immenselya must-have for any programmer.\nThe learning opportunities in kernel development are unparalleled, often rivaling (or even exceeding) those at top tech companies. So if youre considering it, dont hesitatedive in! You might be surprised by how much youll grow.\nGood Luck!\nReferences ","permalink":"http://localhost:45763/personal_website/posts/highlights_from_linux_kernel_mentorship_program_2024/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux is the kernel that powers the modern computing world. Its everywherefrom all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isnt about \u003cem\u003ewhy\u003c/em\u003e Linux dominates the tech world; its about how I started contributing to the Linux Kerneland how you can too.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"how-kernel-development-works\"\u003eHow Kernel Development Works\u003c/h2\u003e\n\u003cp\u003eKernel development thrives on the Linux Kernel Mailing List (LKML), the\nnerve center of Linuxs open-source ecosystem. The beauty of open\nsource? Anyone can contribute. Your task is to send patches (essentially\nthe output of \u003ccode\u003egit diff\u003c/code\u003e refurbushed into an email).\u003c/p\u003e","title":"Highlights from Linux Kernel Mentorship Program 2024 by Abdul Rahim"},{"content":"Introduction Computer memory is usually implemented as a file system. While tampering with data is easy to detect, unauthorized access to memory is a more complex task falling within the domain of Intrusion Detection Systems (IDS). Most intrusion detection systems focus on analyzing network traffic or using machine learning techniques to identify suspicious patterns, we explore if we can employ merkel trees for this task.\nIf unauthorized memory access cannot be detected, users would never know that the system was compromised. Detecting tampered files is straightforward: you can hash the contents of a file, and if the hash changes you might conclude that the file changed. However, detecting memory access is more complicated. Although Linux keeps track of the last access timestamp, available via the stat command1, it only tracks file accesses that use the read() syscall2.\nMerkel Trees Merkle trees are a data structure in which hashes are stored rather than data. Leaf nodes store hashes of particular data blocks, while other nodes store hashes of their children. Merkle trees are widely used in blockchains for their ability to detect data tampering. They provide a robust mechanism to detect tampering in multiple distinct data items. If any data item in a leaf node changes, the whole tree becomes invalidated because it changes the hashes of all nodes up the tree.\nFig. 1: A Merkle tree is a data structure in which each node contains a hash. All non-leaf nodes contain hashes of their children, and all leaf nodes contain hashes of the underlying data.\nMerkel tree as directory tree Now, what we want to do is to augment the directory tree as a merkel tree. To be exact the inode structure (See inode doc for more details).\nDoing this would make us have hashes for children in directory tree. And the benefit of that is whenever the child inodes change, the current inode would change. And there\u0026rsquo;s 2 fields that each node would contain, the last seen hash (expected hash) of it\u0026rsquo;s child and the current hash of the same child. And when the current hash changes to a different value from expected hash, then we can imply that the child inode changed.\nBut one question is that if memory can be accessed bare metal, then the protections done in software doesn\u0026rsquo;t really make any sense. One possible solution to this problem is employing encryption.\nThe encryption should be performed in hardware, and the memory access system calls should define protocols for decrypting the underlying memory. The same system call would update necessary variables of the file in question, such as access time. The memory access system call needs to be implemented so that when one accesses memory, the data is decrypted and other functions are performed.\nBelow is a detailed description.\nArchitecture File system in most operating systems follow a hierarchical structure. We augment this with a Merkle tree, where a node is attached to each file in the file system. These nodes form a Merkle tree, where each node contains the hash of its children (in the case of non-leaf nodes) or the hash of the file data (in the case of files). Additionally, a pollution flag is attached to each node to detect illegal access.\nEach node will also has an expected hash, which is the hash of the node when the subtree below that node was last valid.\nWorking The pollution flag is set if expected_hash != hash, which occurs only on illegal access. I will explain this in a moment.\nWhen a user or process requests memory, it will go through the memory access system call, requiring authentication. Once the authentication is successful, the underlying data is decrypted and returned, the access time is updated, and all the hashes up to the root are updated along with the expected hash (note that the expected hash changes on authorized access). The tree remains valid.\nIf the authentication fails, the memory is not returned, but the access time changes. Consequently, when the tree is re-evaluated, the hash of this node changes since it incorporates the access time, but the expected hash remains the same, setting the pollution flag for this node.\nSince the parent of this node uses its hash, the parent\u0026rsquo;s hash also changes. However, its expected hash remains the same, leading to its invalidation. This process continues up the tree, invalidating the whole tree.\nThe benefit of this approach is that all other nodes remain valid. If one tries to determine which file was accessed and the timestamp, it is easy to identify the exact file by following the invalid nodes from top to bottom.\nRefrences stat man page\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nread syscall\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:45763/personal_website/posts/merkel_trees_and_computer_memory/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003c!-- mine\nComputer memory is usually implemented as a file system. While tampering\nof data is easy to detect, unauthorised access to memory is a more\ncomplex task. A problem that lies in the domain of Intrusion Detection\nSystems. While, most intrusion detection focus on analyzing network\ntraffic, or machine learning techniques to identify suspicious patterns.\nWe propose a method that works within the system, providing robust\naccess detection.\n--\u003e\n\u003cp\u003eComputer memory is usually implemented as a file system. While tampering\nwith data is easy to detect, unauthorized access to memory is a more\ncomplex task falling within the domain of Intrusion Detection Systems\n(IDS). Most intrusion detection systems focus on analyzing network traffic or\nusing machine learning techniques to identify suspicious patterns, we\nexplore if we can employ merkel trees for this task.\u003c/p\u003e","title":"Merkel Trees and computer memory"},{"content":"Introduction When you install vim, a usual requirement as with all text editors is the ability to copy to/from system clipboard so you can lets say, copy something into your vim session from firefox or vice versa, however copy pasting in terminal editors is not as straight forward as with GUI editors. In vim if you want to copy something into an auxilary space (anticipating it would be used later, so you can paste from this auxilary space) is achieved by registers.\nThe register that represents system clipboard is + register. Anything that you copy into this register is available in system clipboard.\nHow to use registers to copy/paste To copy a text into a register, select it in visual mode and press \u0026quot;\u0026lt;register_name\u0026gt;y to yank the contents into the given register. And to paste the contents of a particular register at current position, use \u0026quot;\u0026lt;register_name\u0026gt;p.\nTo use system clipboard, you just have to substitute \u0026ldquo;+\u0026rdquo; for register name in the above commands.\nclipboard support But the + register wont work unless you have clipboard support with your vim installation. By default there is no clipboard support in vim.\nTo check if your vim installation has clipboard support use:\n1 2 3 $ vim --version | grep clipboard +clipboard +keymap +printer +vertsplit +ex_extra +mouse_netterm +syntax +xterm_clipboard or inside of vim, you can run the command:\n1 :echo has(\u0026#39;clipboard\u0026#39;) If the output is 0, your installation doesnt have clipboard support.\nCompiling vim Now there are 2 solutions to this problem:\nEither install gvim: Or compile vim from sources with clipboard support Let\u0026rsquo;s see how each of them can be done.\nInstall gvim To install gvim run:\nOn Debian:\n1 sudo apt install vim-gtk On Fedora\n1 sudo dnf install gvim To compile vim with clipboard support Below are the simple steps:\nStep 1: Grab the sources Clone the repository:\n1 2 git clone https://github.com/vim/vim.git vim cd vim Step 2: Install dependencies Install the required libraries and tools to build vim, for example gcc, x11 etc. Note that you only need them to compile vim and you are free to delete them once you are done.\nOn Debian:\n1 sudo apt install build-essential libx11-dev libncurses5-dev On Fedora:\n1 2 3 4 sudo dnf groupinstall \u0026#34;Development Tools\u0026#34; sudo yum install gcc sudo yum groupinstall \u0026#34;X Software Development\u0026#34; sudo dnf install libX11-devel ncurses-devel Also, you need to remove the existing installation(if any).\nOn Debian\n1 sudo apt remove vim On Fedora\n1 sudo dnf remove vim gvim Step 3: Configure and Compile Configure vim with features of your choice\n1 2 3 4 5 6 7 ./configure \\\\ --enable-cscope \\\\ --enable-gui=auto \\\\ --enable-gtk2-check \\\\ --enable-gnome-check \\\\ --with-features=huge \\\\ --with-x Then compile and install with:\n1 2 make sudo make install Conclusion In this article we learned how can we compile vim with clipboard support, you can also tweak configuration according to your requirements. There are many configuration options available.\n","permalink":"http://localhost:45763/personal_website/posts/how_to_compile_vim_with_clipboard_support/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eWhen you install vim, a usual requirement as with all text editors is\nthe ability to copy to/from system clipboard so you can lets say, copy\nsomething into your vim session from firefox or vice versa, however copy\npasting in terminal editors is not as straight forward as with GUI\neditors. In vim if you want to copy something into an auxilary space\n(anticipating it would be used later, so you can paste from this\nauxilary space) is achieved by \u003cstrong\u003eregisters\u003c/strong\u003e.\u003c/p\u003e","title":"How to compile vim with clipboard support"},{"content":" Introduction I had an unused phone lying around for some time, and I began contemplating how I could repurpose it. This led me to reflect on the impressive performance of modern smartphones and consider whether they could be utilized as servers.\nSmartphones are equipped with ARM-based processors and run on Android, which is itself built on the Linux kernel. ARM processors are renowned for their energy efficiency1 and have recently found applications in the server space2.\nAs someone who enjoys exploring the full potential of devices, I embarked on a journey to discover how I could leverage the full potential of smartphones.\nSetup Although, you would like to run your programs on phones, but programming on phones typing on screen is a horrifying idea. Fortunately, you dont have to type on your phone, what you can do is you can access its terminal, using protocols like ssh/telnet etc.\nSo, firstly you would need a terminal to control a machine remotely. Unfortunately, there are not, alot of choices available in phone space when it comes to terminal emulators. Termux is one of the few available options.\nAfter you manage to open a terminal remotely, then from there its pretty frictionless. You can install the software of your choice and write, compile and run your programs. You might also find it helpful to root your phone for root privilages, which will help you run all commands. But please beware that rooting can null your warrenty, check with local expert. If termux does\u0026rsquo;nt work for you then there are also other options like kali net hunter.\nSo, in total, we need to install termux, then we would setup ssh.\nTermux Termux is an open source terminal emulator for android. In essence, it provides you with a linux environment, within android, The only difference between actual linux environment and termex is that it is not FHS(File System Hierarcy) compliant, i.e. it does not strictly follow linux file system conventions. The consequences of that are that #! /usr/bin/sh may not work, so you have to watch out the paths. Other than that, it supports almost all commands on linux.\nMoreover, It is an app that does\u0026rsquo;nt interfere with your system so you can run your android as normal, moreover it runs without root privilages. It comes with a large repository of software found at packages.termux.dev.\nBelow are the steps to setup ssh in termux Step 1: Download texmux on playstore, f-droid or from github releases\nStep 2: Update using pkg:\n1 2 pkg update # update the repositories pkg upgrade # upgrade all to latest versions Run this commands\nStep 3: Install ssh 1 pkg install ssh install ssh\nStep 4: Set a password Setup a password that you will use to login\n1 passwd set password and note username\nStep 5: Note your username You will require username and ip address when logging in using ssh, hence note them. Run the command whoami the know your username. This will generally start with \u0026ldquo;a0_\u0026rdquo;\n1 whoami Step 6: Note your IP address You can check your IP address in:\n1 2 3 settings \u0026gt; Wi-Fi \u0026gt; click on the (i) button, on the wifi you are connected to and Look for IPv4 address Step 7: Run ssh doemon in termux On your phone, run the ssh daemon using\n1 sshd Step 8: Login form your computer On your computer, use the following command to login into your phone and access its terminal\n1 ssh \u0026lt;user_name\u0026gt;@\u0026lt;IP_address\u0026gt; -p 8022 The username and IP address we already determined in step 5 and 6 resp. Note that it will promt you for password\nAftermath You can use scp command to transfer files between your computer and phone. In case you want to do development, there are a number of programming packages available in termux, you can find rust, nodejs, python, C/C++ and tools for many other programming languages.\nConclusion So, now you have successfully installed ssh in your android phone. You might find it useful to install vim, git, gcc etc. There is a large repository of packages in termux, which covers pretty much everything your would need.\nFurther Reads Simili, Emanuele, et al. \u0026ldquo;Power Efficiency in HEP (x86 vs. arm).\u0026rdquo; Power (W) 350.400 (2023): 450\u0026#160;\u0026#x21a9;\u0026#xfe0e;\narm_server\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:45763/personal_website/posts/how_to_turn_your_old_smartphone_into_a_home_server/","summary":"\u003c!--\n---\ndate: '2025-07-15T22:33:11+05:30'\ndate: ''\ntitle: 'How_to_turn_your_old_smartphone_into_a_home_server'\n---\n--\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eI had an unused phone lying around for some time, and I began\ncontemplating how I could repurpose it. This led me to reflect on the\nimpressive performance of modern smartphones and consider whether they\ncould be utilized as servers.\u003c/p\u003e\n\u003cp\u003eSmartphones are equipped with ARM-based processors and run on Android,\nwhich is itself built on the Linux kernel. ARM processors are renowned\nfor their energy efficiency\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e and have recently found\napplications in the server space\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e","title":"How to turn your old smartphone into a home server"}]