[{"content":"Introduction Linux is the kernel that powers the modern computing world. It’s everywhere—from all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isn’t about why Linux dominates the tech world; it’s about how I started contributing to the Linux Kernel—and how you can too.\nHow Kernel Development Works Kernel development thrives on the Linux Kernel Mailing List (LKML), the nerve center of Linux’s open-source ecosystem. The beauty of open source? Anyone can contribute. Your task is to send patches (essentially the output of git diff refurbushed into an email).\nIf your patch solves a real problem or adds value, experienced developers will jump in with questions about your intent and rationale. Here’s a pro tip: don’t explain the how of your code; let the code speak for itself. Instead, focus on explaining why your change is needed.\nThe LKML community is incredibly supportive \u0026ndash; they’ll critique your code, point out mistakes, and suggest improvements. Sure, it might feel overwhelming initially, but resources like the LFD103 course can guide you through the basics: generating patches, submitting them to LKML, compiling, and booting the kernel.\nFor me, just setting up my mail client and understanding LKML discussions took about a month. But once you clear these initial hurdles, things get easier. If you’re struggling, feel free to check out my notes—they might save you some time.\nMy Background For years, kernel developers seemed like magicians to me—doing impossibly cool things with computers. My fascination started after I stumbled upon a video of someone working on the kernel. It was mesmerizing!\nIn my second semester, I discovered the book The C Programming Language, and it sparked my love for C. The control C offers is unmatched, but it comes with its fair share of challenges—bugs galore!\nSurprisingly, I wasn’t a Linux user until recently. When I finally switched from Windows to Linux, everything just clicked. Concepts that once felt abstract suddenly made sense. On Windows, troubleshooting often felt like solving a mystery even Microsoft couldn’t decode. On Linux, it felt like someone handed me the keys to the entire system.\nWhile working on kernel contributions, I read Linux Device Drivers, a book authored by seasoned kernel developers. It gave me a deeper understanding of the kernel’s inner workings. If you’re serious about kernel development or writing drivers, this book is a must-read.\nWhat to Contribute The hardest part of contributing to the Linux Kernel is figuring out what to work on. The kernel is vast—there’s everything from GPU drivers to network stack development.\nSince the kernel’s primary job is managing hardware, driver development is a hotspot of activity. New devices constantly hit the market, and they need drivers. If you have an electronics background and access to hardware, driver development is an excellent starting point.\nIf hardware isn’t your thing (like in my case), here are some alternatives:\nkselftest: A testing framework for kernel functionality. Core subsystems: The backbone of the kernel—a great way to learn the essentials. syzbot reports: A kernel fuzzer that uncovers bugs by feeding the kernel random data. These reports are a goldmine for learning about common mistakes. Another beginner-friendly option is upgrading deprecated APIs. These updates are highly appreciated because they improve the kernel’s maintainability and security. It’s not always a simple find-and-replace—you’ll need to understand the code—but it’s a rewarding way to start.\nAnd don’t underestimate fixing spelling and grammar errors in the documentation or comments. While it might sound trivial, it’s a fantastic way to learn the workflow: creating patches, submitting them, and receiving feedback. Tools like codespell can help you automate finding these errors.\nMy first-ever patch was a simple typo fix, but I made the classic rookie mistake of introducing two changes while documenting only one. Lesson learned!\nOnce you start contributing, you’ll notice issues everywhere. Even just following discussions on LKML can teach you a ton about how seasoned developers think and work.\nConclusion Kernel development might seem intimidating at first, but trust me, it’s worth the effort. You’ll not only become a stronger developer but also gain a deep understanding of how computers work. You’ll build expertise in both kernel and userspace development, and your Git skills will level up immensely—a must-have for any programmer.\nThe learning opportunities in kernel development are unparalleled, often rivaling (or even exceeding) those at top tech companies. So if you’re considering it, don’t hesitate—dive in! You might be surprised by how much you’ll grow.\nGood Luck!\nReferences ","permalink":"http://localhost:1313/personal_website/posts/highlights_from_linux_kernel_mentorship_program_2024/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eLinux is the kernel that powers the modern computing world. It’s everywhere—from all the top 500 supercomputers running Linux, to over two-thirds of mobile phones using it, and more than 95% of servers relying on it. Impressive, right? But this blog isn’t about \u003cem\u003ewhy\u003c/em\u003e Linux dominates the tech world; it’s about how I started contributing to the Linux Kernel—and how you can too.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"how-kernel-development-works\"\u003eHow Kernel Development Works\u003c/h2\u003e\n\u003cp\u003eKernel development thrives on the Linux Kernel Mailing List (LKML), the\nnerve center of Linux’s open-source ecosystem. The beauty of open\nsource? Anyone can contribute. Your task is to send patches (essentially\nthe output of \u003ccode\u003egit diff\u003c/code\u003e refurbushed into an email).\u003c/p\u003e","title":"Highlights from Linux Kernel Mentorship Program 2024 by Abdul Rahim"},{"content":"Introduction Computer memory is usually implemented as a file system. While tampering with data is easy to detect, unauthorized access to memory is a more complex task falling within the domain of Intrusion Detection Systems (IDS). Most intrusion detection systems focus on analyzing network traffic or using machine learning techniques to identify suspicious patterns, we explore if we can employ merkel trees for this task.\nIf unauthorized memory access cannot be detected, users would never know that the system was compromised. Detecting tampered files is straightforward: you can hash the contents of a file, and if the hash changes you might conclude that the file changed. However, detecting memory access is more complicated. Although Linux keeps track of the last access timestamp, available via the stat command1, it only tracks file accesses that use the read() syscall2.\nMerkel Trees Merkle trees are a data structure in which hashes are stored rather than data. Leaf nodes store hashes of particular data blocks, while other nodes store hashes of their children. Merkle trees are widely used in blockchains for their ability to detect data tampering. They provide a robust mechanism to detect tampering in multiple distinct data items. If any data item in a leaf node changes, the whole tree becomes invalidated because it changes the hashes of all nodes up the tree.\nFig. 1: A Merkle tree is a data structure in which each node contains a hash. All non-leaf nodes contain hashes of their children, and all leaf nodes contain hashes of the underlying data.\nMerkel tree as directory tree Now, what we want to do is to augment the directory tree as a merkel tree. To be exact the inode structure (See inode doc for more details).\nDoing this would make us have hashes for children in directory tree. And the benefit of that is whenever the child inodes change, the current inode would change. And there\u0026rsquo;s 2 fields that each node would contain, the last seen hash (expected hash) of it\u0026rsquo;s child and the current hash of the same child. And when the current hash changes to a different value from expected hash, then we can imply that the child inode changed.\nBut one question is that if memory can be accessed bare metal, then the protections done in software doesn\u0026rsquo;t really make any sense. One possible solution to this problem is employing encryption.\nThe encryption should be performed in hardware, and the memory access system calls should define protocols for decrypting the underlying memory. The same system call would update necessary variables of the file in question, such as access time. The memory access system call needs to be implemented so that when one accesses memory, the data is decrypted and other functions are performed.\nBelow is a detailed description.\nArchitecture File system in most operating systems follow a hierarchical structure. We augment this with a Merkle tree, where a node is attached to each file in the file system. These nodes form a Merkle tree, where each node contains the hash of its children (in the case of non-leaf nodes) or the hash of the file data (in the case of files). Additionally, a pollution flag is attached to each node to detect illegal access.\nEach node will also has an expected hash, which is the hash of the node when the subtree below that node was last valid.\nWorking The pollution flag is set if expected_hash != hash, which occurs only on illegal access. I will explain this in a moment.\nWhen a user or process requests memory, it will go through the memory access system call, requiring authentication. Once the authentication is successful, the underlying data is decrypted and returned, the access time is updated, and all the hashes up to the root are updated along with the expected hash (note that the expected hash changes on authorized access). The tree remains valid.\nIf the authentication fails, the memory is not returned, but the access time changes. Consequently, when the tree is re-evaluated, the hash of this node changes since it incorporates the access time, but the expected hash remains the same, setting the pollution flag for this node.\nSince the parent of this node uses its hash, the parent\u0026rsquo;s hash also changes. However, its expected hash remains the same, leading to its invalidation. This process continues up the tree, invalidating the whole tree.\nThe benefit of this approach is that all other nodes remain valid. If one tries to determine which file was accessed and the timestamp, it is easy to identify the exact file by following the invalid nodes from top to bottom.\nRefrences stat man page\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nread syscall\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:1313/personal_website/posts/merkel_trees_and_computer_memory/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003c!-- mine\nComputer memory is usually implemented as a file system. While tampering\nof data is easy to detect, unauthorised access to memory is a more\ncomplex task. A problem that lies in the domain of Intrusion Detection\nSystems. While, most intrusion detection focus on analyzing network\ntraffic, or machine learning techniques to identify suspicious patterns.\nWe propose a method that works within the system, providing robust\naccess detection.\n--\u003e\n\u003cp\u003eComputer memory is usually implemented as a file system. While tampering\nwith data is easy to detect, unauthorized access to memory is a more\ncomplex task falling within the domain of Intrusion Detection Systems\n(IDS). Most intrusion detection systems focus on analyzing network traffic or\nusing machine learning techniques to identify suspicious patterns, we\nexplore if we can employ merkel trees for this task.\u003c/p\u003e","title":"Merkel Trees and computer memory"},{"content":"Introduction When you install vim, a usual requirement as with all text editors is the ability to copy to/from system clipboard so you can lets say, copy something into your vim session from firefox or vice versa, however copy pasting in terminal editors is not as straight forward as with GUI editors. In vim if you want to copy something into an auxilary space (anticipating it would be used later, so you can paste from this auxilary space) is achieved by registers.\nThe register that represents system clipboard is + register. Anything that you copy into this register is available in system clipboard.\nHow to use registers to copy/paste To copy a text into a register, select it in visual mode and press \u0026quot;\u0026lt;register_name\u0026gt;y to yank the contents into the given register. And to paste the contents of a particular register at current position, use \u0026quot;\u0026lt;register_name\u0026gt;p.\nTo use system clipboard, you just have to substitute \u0026ldquo;+\u0026rdquo; for register name in the above commands.\nclipboard support But the + register wont work unless you have clipboard support with your vim installation. By default there is no clipboard support in vim.\nTo check if your vim installation has clipboard support use:\n$ vim --version | grep clipboard +clipboard +keymap +printer +vertsplit +ex_extra +mouse_netterm +syntax +xterm_clipboard or inside of vim, you can run the command:\n:echo has(\u0026#39;clipboard\u0026#39;) If the output is 0, your installation doesnt have clipboard support.\nCompiling vim Now there are 2 solutions to this problem:\nEither install gvim: Or compile vim from sources with clipboard support Let\u0026rsquo;s see how each of them can be done.\nInstall gvim To install gvim run:\nOn Debian:\nsudo apt install vim-gtk On Fedora\nsudo dnf install gvim To compile vim with clipboard support Below are the simple steps:\nStep 1: Grab the sources Clone the repository:\ngit clone https://github.com/vim/vim.git vim cd vim Step 2: Install dependencies Install the required libraries and tools to build vim, for example gcc, x11 etc. Note that you only need them to compile vim and you are free to delete them once you are done.\nOn Debian:\nsudo apt install build-essential libx11-dev libncurses5-dev On Fedora:\nsudo dnf groupinstall \u0026#34;Development Tools\u0026#34; sudo yum install gcc sudo yum groupinstall \u0026#34;X Software Development\u0026#34; sudo dnf install libX11-devel ncurses-devel Also, you need to remove the existing installation(if any).\nOn Debian\nsudo apt remove vim On Fedora\nsudo dnf remove vim gvim Step 3: Configure and Compile Configure vim with features of your choice\n./configure \\\\ --enable-cscope \\\\ --enable-gui=auto \\\\ --enable-gtk2-check \\\\ --enable-gnome-check \\\\ --with-features=huge \\\\ --with-x Then compile and install with:\nmake sudo make install Conclusion In this article we learned how can we compile vim with clipboard support, you can also tweak configuration according to your requirements. There are many configuration options available.\n","permalink":"http://localhost:1313/personal_website/posts/how_to_compile_vim_with_clipboard_support/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eWhen you install vim, a usual requirement as with all text editors is\nthe ability to copy to/from system clipboard so you can lets say, copy\nsomething into your vim session from firefox or vice versa, however copy\npasting in terminal editors is not as straight forward as with GUI\neditors. In vim if you want to copy something into an auxilary space\n(anticipating it would be used later, so you can paste from this\nauxilary space) is achieved by \u003cstrong\u003eregisters\u003c/strong\u003e.\u003c/p\u003e","title":"How to compile vim with clipboard support"},{"content":" Introduction I had an unused phone lying around for some time, and I began contemplating how I could repurpose it. This led me to reflect on the impressive performance of modern smartphones and consider whether they could be utilized as servers.\nSmartphones are equipped with ARM-based processors and run on Android, which is itself built on the Linux kernel. ARM processors are renowned for their energy efficiency1 and have recently found applications in the server space2.\nAs someone who enjoys exploring the full potential of devices, I embarked on a journey to discover how I could leverage the full potential of smartphones.\nSetup Although, you would like to run your programs on phones, but programming on phones typing on screen is a horrifying idea. Fortunately, you dont have to type on your phone, what you can do is you can access its terminal, using protocols like ssh/telnet etc.\nSo, firstly you would need a terminal to control a machine remotely. Unfortunately, there are not, alot of choices available in phone space when it comes to terminal emulators. Termux is one of the few available options.\nAfter you manage to open a terminal remotely, then from there its pretty frictionless. You can install the software of your choice and write, compile and run your programs. You might also find it helpful to root your phone for root privilages, which will help you run all commands. But please beware that rooting can null your warrenty, check with local expert. If termux does\u0026rsquo;nt work for you then there are also other options like kali net hunter.\nSo, in total, we need to install termux, then we would setup ssh.\nTermux Termux is an open source terminal emulator for android. In essence, it provides you with a linux environment, within android, The only difference between actual linux environment and termex is that it is not FHS(File System Hierarcy) compliant, i.e. it does not strictly follow linux file system conventions. The consequences of that are that #! /usr/bin/sh may not work, so you have to watch out the paths. Other than that, it supports almost all commands on linux.\nMoreover, It is an app that does\u0026rsquo;nt interfere with your system so you can run your android as normal, moreover it runs without root privilages. It comes with a large repository of software found at packages.termux.dev.\nBelow are the steps to setup ssh in termux Step 1: Download texmux on playstore, f-droid or from github releases\nStep 2: Update using pkg:\npkg update # update the repositories pkg upgrade # upgrade all to latest versions Run this commands\nStep 3: Install ssh pkg install ssh install ssh\nStep 4: Set a password Setup a password that you will use to login\npasswd set password and note username\nStep 5: Note your username You will require username and ip address when logging in using ssh, hence note them. Run the command whoami the know your username. This will generally start with \u0026ldquo;a0_\u0026rdquo;\nwhoami Step 6: Note your IP address You can check your IP address in:\nsettings \u0026gt; Wi-Fi \u0026gt; click on the (i) button, on the wifi you are connected to and Look for IPv4 address Step 7: Run ssh doemon in termux On your phone, run the ssh daemon using\nsshd Step 8: Login form your computer On your computer, use the following command to login into your phone and access its terminal\nssh \u0026lt;user_name\u0026gt;@\u0026lt;IP_address\u0026gt; -p 8022 The username and IP address we already determined in step 5 and 6 resp. Note that it will promt you for password\nAftermath You can use scp command to transfer files between your computer and phone. In case you want to do development, there are a number of programming packages available in termux, you can find rust, nodejs, python, C/C++ and tools for many other programming languages.\nConclusion So, now you have successfully installed ssh in your android phone. You might find it useful to install vim, git, gcc etc. There is a large repository of packages in termux, which covers pretty much everything your would need.\nFurther Reads Simili, Emanuele, et al. \u0026ldquo;Power Efficiency in HEP (x86 vs. arm).\u0026rdquo; Power (W) 350.400 (2023): 450\u0026#160;\u0026#x21a9;\u0026#xfe0e;\narm_server\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"http://localhost:1313/personal_website/posts/how_to_turn_your_old_smartphone_into_a_home_server/","summary":"\u003c!--\n---\ndate: '2025-07-15T22:33:11+05:30'\ndate: ''\ntitle: 'How_to_turn_your_old_smartphone_into_a_home_server'\n---\n--\u003e\n\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eI had an unused phone lying around for some time, and I began\ncontemplating how I could repurpose it. This led me to reflect on the\nimpressive performance of modern smartphones and consider whether they\ncould be utilized as servers.\u003c/p\u003e\n\u003cp\u003eSmartphones are equipped with ARM-based processors and run on Android,\nwhich is itself built on the Linux kernel. ARM processors are renowned\nfor their energy efficiency\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e and have recently found\napplications in the server space\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e","title":"How to turn your old smartphone into a home server"}]